<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux系统编程学习笔记 | Kisugi Takumi</title><meta name="keywords" content="Linux,Linux系统编程"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux系统编程学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux系统编程学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="Linux系统编程学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/linux.png">
<meta property="article:published_time" content="2022-11-20T06:46:25.000Z">
<meta property="article:modified_time" content="2023-01-15T11:23:53.551Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Linux系统编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/linux.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux系统编程学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-15 19:23:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Linux系统编程学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-20T06:46:25.000Z" title="发表于 2022-11-20 14:46:25">2022-11-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T11:23:53.551Z" title="更新于 2023-01-15 19:23:53">2023-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">62.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>239分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux系统编程学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Linux系统编程学习笔记"><a href="#Linux系统编程学习笔记" class="headerlink" title="Linux系统编程学习笔记"></a>Linux系统编程学习笔记</h1><p>学习时间：2022年11月20日</p>
<p>学习来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yJ411S7r6?">Linux系统编程（李慧琴）</a></p>
<p>参考资料：Unix环境高级编程，Linux系统编程</p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><h3 id="1-1-环境"><a href="#1-1-环境" class="headerlink" title="1.1 环境"></a>1.1 环境</h3><p>平台：Centos7.6</p>
<p>工具：vim，gcc，make</p>
<h3 id="1-2-GCC"><a href="#1-2-GCC" class="headerlink" title="1.2 GCC"></a>1.2 GCC</h3><p>Linux系统下的GCC（<code>GNU Compiler Collection</code>）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。gcc是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%。</p>
<p>GCC编译器能将C、C++语言源程序、汇程式化序和目标程序编译、链接成可执行文件，如果没有给出可执行文件的名字，gcc将生成一个名为<code>a.out</code>的文件。</p>
<p>GCC编译器编译C源文件为可执行文件的步骤：</p>
<ul>
<li>C源文件—-&gt;预处理<code>.i</code>—-&gt;编译<code>.s</code>（生成汇编文件）—-&gt;汇编<code>.o/.obj</code>（生成目标文件）—-&gt;链接<code>.out</code>（生成可执行文件）—-&gt;可执行文件</li>
</ul>
<blockquote>
<p>gcc命令参数（选项）</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>-c</code></td>
<td style="text-align:left">对文件进行预处理、编译和汇编，生成obj文件</td>
<td style="text-align:left"><code>gcc -c hello.c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-S</code></td>
<td style="text-align:left">只进行预处理和编译，生成汇编代码</td>
<td style="text-align:left"><code>gcc -S hello.c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-E</code></td>
<td style="text-align:left">只进行预处理，这个选项不生成文件，可以使用重定向或者<code>-o</code>选项使其生成一个文件</td>
<td style="text-align:left"><code>gcc -E hello.c &gt; hello.i</code>或者<code>gcc -E hello.c -o hello.i</code></td>
</tr>
<tr>
<td style="text-align:left"><code>-o</code></td>
<td style="text-align:left">指定目标的名称，默认为a.out</td>
<td style="text-align:left"><code>gcc -o hello hello.c</code></td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>过程演示</p>
</blockquote>
<p>例如源代码<code>main.c</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>预编译：这个过程处理宏定义和include，去除注释，不会对语法进行检查。可以看到预编译后，源文件的代码从6行扩展了很多行，生成<code>main.i</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E main.c &gt; main.i <span class="comment"># 或者 gcc -E main.c -o main.i</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 只展示了一部分</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">ftrylockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span> </span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">funlockfile</span> <span class="params">(FILE *__stream)</span> __<span class="title">attribute__</span> <span class="params">((__nothrow__ , __leaf__))</span></span>;</span><br><span class="line"># <span class="number">943</span> <span class="string">&quot;/usr/include/stdio.h&quot;</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2</span> <span class="string">&quot;main.c&quot;</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译：这个阶段，检查语法，生成<strong>汇编</strong>代码<code>main.s</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S main.c -o main.s</span><br></pre></td></tr></table></figure>
<p><code>main.s</code>的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        .file   &quot;main.c&quot;</span><br><span class="line">        .section        .rodata</span><br><span class="line">.LC0:</span><br><span class="line">        .string &quot;Hello World!&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        call    puts</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  &quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<ul>
<li>汇编：这个阶段，生成目标代码<code>main.o</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.s -o main.o</span><br></pre></td></tr></table></figure>
<ul>
<li>链接：生成可执行代码<code>main</code>。<ul>
<li>链接分为两种，一种是静态链接，另外一种是动态链接。</li>
<li>使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。</li>
<li>使用动态链接的好处是，生成的程序比较小，占用较少的内存。</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.o -o main</span><br></pre></td></tr></table></figure>
<ul>
<li>运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng c]<span class="comment"># ./main</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<hr>
<p>一步到位：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o</span><br></pre></td></tr></table></figure>
<p>此时会默认生成一个名为<code>a.out</code>的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -o myHello</span><br></pre></td></tr></table></figure>
<p>此时会生成一个名为<code>myHello</code>的可执行文件</p>
<h3 id="1-3-make"><a href="#1-3-make" class="headerlink" title="1.3 make"></a>1.3 make</h3><p>make命令是GNU工程化中的一个编译工具。make是依赖于Makefile来编译多个源文件的工具。在Makefile里同样是用gcc（或者别的编译器）来编译程序。</p>
<p>可以使用以下命令直接生成可执行文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make main</span><br></pre></td></tr></table></figure>
<h3 id="1-4-makefile"><a href="#1-4-makefile" class="headerlink" title="1.4 makefile"></a>1.4 makefile</h3><p>一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，<code>makefile</code>定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221121035110927.png" alt="image-20221121035110927"></p>
<h4 id="1-4-1-使用gcc的例子"><a href="#1-4-1-使用gcc的例子" class="headerlink" title="1.4.1 使用gcc的例子"></a>1.4.1 使用gcc的例子</h4><ul>
<li>创建文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch main.c tool1.c tool1.h tool2.c tool2.h</span><br></pre></td></tr></table></figure>
<p>可以使用<code>vim * -p</code>打开当前目录下的所有文件。<code>-p</code>是打开多个文件的选项。</p>
<p>在命令模式下，<code>gt</code>切换到下一个标签页，<code>gT</code>切换到上一个标签页。</p>
<p>退出多个标签时，可加上<code>a</code>，例如<code>:qa</code>或者<code>:wqa</code>等</p>
<ul>
<li><code>tool1.h</code>和<code>tool1.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TOOL1_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TOOL1_H__</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mytool1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tool1.h&quot;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytool1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;tool1 print...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>tool2.h</code>和<code>tool2.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TOOL2_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TOOL2_H__</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mytool2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tool2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mytool2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tool2 print...\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tool1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tool2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    mytool1();</span><br><span class="line">    mytool2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对所有文件进行编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc *.c</span><br></pre></td></tr></table></figure>
<p>执行<code>a.out</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># ./a.out </span></span><br><span class="line">tool1 <span class="built_in">print</span>...</span><br><span class="line">tool2 <span class="built_in">print</span>...</span><br></pre></td></tr></table></figure>
<h4 id="1-4-2-语法规则"><a href="#1-4-2-语法规则" class="headerlink" title="1.4.2 语法规则"></a>1.4.2 语法规则</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标 ... : 依赖 ...</span><br><span class="line">	命令1</span><br><span class="line">	命令2</span><br><span class="line">	. . .</span><br></pre></td></tr></table></figure>
<ul>
<li>目标即要生成的文件。如果目标文件的更新时间晚于依赖文件更新时间，则说明依赖文件没有改动，目标文件不需要重新编译。否则会进行重新编译并更新目标文件。默认情况下Makefile的第一个目标为<strong>终极目标</strong>。</li>
<li>依赖：即目标文件由哪些文件生成。</li>
<li>命令：即通过执行命令由依赖文件生成目标文件。注意每条命令之前必须有一个tab保持缩进。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>新建makefile，<code>touch makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mytool:main.o tool1.o tool2.o</span></span><br><span class="line">    gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    gcc -c tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    gcc -c tool2.c -o tool2.o</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>make</code>即可。</li>
</ul>
<hr>
<p>makefile会监视哪些源文件发生了变化，一旦发生变化，则会在有这个变化文件的编译链上重新编译。</p>
<ul>
<li>假设没有变化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># make</span></span><br><span class="line">make: `mytool<span class="string">&#x27; is up to date.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>将<code>tool1.c</code>修改一点，再次make</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng makefile]<span class="comment"># make</span></span><br><span class="line">gcc -c tool1.c -o tool1.o</span><br><span class="line">gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line">[root@HongyiZeng makefile]<span class="comment"># ./mytool </span></span><br><span class="line">tool1.c is updated...</span><br><span class="line">tool2 <span class="built_in">print</span>...</span><br></pre></td></tr></table></figure>
<p>发现只有<code>tool1.c</code>影响到的地方被重新编译了，没有发生变化的地方则不会被重新编译。</p>
<hr>
<ul>
<li>代码清理<code>clean</code>：我们可以编译一条属于自己的clean语句，来清理make命令所产生的所有文件，例如：</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">mytool:main.o tool1.o tool2.o</span></span><br><span class="line">    gcc main.o tool1.o tool2.o -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    gcc -c tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    gcc -c tool2.c -o tool2.o</span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm *.o mytool -rf</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li><p>变量：<code>$</code>符号表示取变量的值，当变量名多于一个字符时，使用<code>()</code></p>
</li>
<li><p>变量赋值：</p>
<ul>
<li><p><code>=</code>：最普通的等号，在Makefile中容易搞错赋值等号，使用 <code>=</code>进行赋值，变量的值是整个Makefile中<strong>最后被指定</strong>的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A = AA</span><br></pre></td></tr></table></figure>
<p>经过上面的赋值后，最后VIR_B的值是<code>AA B</code>，而不是<code>A B</code>，在make时，会把整个Makefile展开，来决定变量的值</p>
</li>
<li><p><code>:=</code>：表示直接赋值，赋予当前位置的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VIR_A := A</span><br><span class="line">VIR_B := <span class="variable">$(VIR_A)</span> B</span><br><span class="line">VIR_A := AA</span><br></pre></td></tr></table></figure>
<p>最后BIR_B的值是<code>A B</code>，即根据当前位置进行赋值。</p>
</li>
<li><p><code>?=</code>：表示如果该变量没有被赋值，赋值予等号后面的值。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VIR ?= new_value</span><br></pre></td></tr></table></figure>
<p>如果VIR在之前没有被赋值，那么VIR的值就为new_value。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VIR := old_value</span><br><span class="line">VIR ?= new_value</span><br></pre></td></tr></table></figure>
<p>这种情况下，VIR的值就是old_value</p>
</li>
<li><p><code>+=</code>：和平时写代码的理解是一样的，表示将符号后面的值添加到前面的变量上</p>
</li>
</ul>
</li>
<li><p>预定义变量<code>CC</code>：c编译器的名称，默认值为<code>gcc</code></p>
</li>
</ul>
<blockquote>
<p>GCC编译选项<code>CFLAGS</code>参数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-c</code></td>
<td>用于把源码文件编译成 .o 对象文件,不进行链接过程</td>
</tr>
<tr>
<td><code>-o</code></td>
<td>用于连接生成可执行文件，在其后可以指定输出文件的名称</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>用于在生成的目标可执行文件中，添加调试信息，可以使用GDB进行调试</td>
</tr>
<tr>
<td><code>-Wall</code></td>
<td>生成常见的所有告警信息，且停止编译，具体是哪些告警信息，请参见GCC手册，一般用这个足矣！</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>关闭所有告警信息</td>
</tr>
<tr>
<td><code>-O</code></td>
<td>表示编译优化选项，其后可跟优化等级0\1\2\3，默认是0，不优化</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>GCC链接选项<code>LDFLAGS</code>参数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-llibrary</code></td>
<td>链接时在标准搜索目录中寻找库文件，搜索名为liblibrary.a 或 liblibrary.so</td>
</tr>
<tr>
<td><code>-Ldir</code></td>
<td>用于把新目录添加到库搜索路径上，可以使用相对和绝对路径，“-L.”、“-L./include”、“-L/opt/include”</td>
</tr>
<tr>
<td><code>-static</code></td>
<td>使用静态库链接生成目标文件，避免使用共享库，生成目标文件会比使用动态链接库大</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：例如posix线程中，查看创建线程的介绍<code>pthread_create</code>中：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115162552592.png" alt="image-20230115162552592"></p>
<p>需要在编译和链接的选项中加上<code>-pthread</code>，因此，在编写makefile时需要加上：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br></pre></td></tr></table></figure>
<p>执行make时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -pthread -phread test.c -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>改造后的makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g <span class="comment"># 编译选项</span></span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(OBJS)</span> -o mytool</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> main.c -o main.o</span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> tool1.c -o tool1.o</span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> tool2.c -o tool2.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></table></figure>
<p><code>$</code>的其他用法：</p>
<ul>
<li><code>$^</code> 表示所有的依赖文件</li>
<li><code>$@</code> 表示生成的目标文件</li>
<li><code>$&lt;</code> 代表第一个依赖文件</li>
</ul>
<blockquote>
<p>再次改造后的makefile</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">tool1.o:tool1.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">tool2.o:tool2.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></table></figure>
<hr>
<p>实际上上面的三段代码都有固定的模式，如下：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">xxx.o:xxx.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>相同的部分<code>xxx</code>可以用通配符<code>%</code>代替。可以简化为：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OBJS=main.o tool1.o tool2.o</span><br><span class="line">CFLAGS+=-c -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">mytool:<span class="variable">$(OBJS)</span></span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line">    </span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o mytool -rf</span><br></pre></td></tr></table></figure>
<h3 id="1-5-POSIX"><a href="#1-5-POSIX" class="headerlink" title="1.5 POSIX"></a>1.5 POSIX</h3><p>来源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/392588996">https://zhuanlan.zhihu.com/p/392588996</a> 侵权必删</p>
<h4 id="1-5-1-简介"><a href="#1-5-1-简介" class="headerlink" title="1.5.1 简介"></a>1.5.1 简介</h4><p>POSIX：可移植操作系统接口（<code>Portable Operating System Interface of UNIX</code>，缩写为 POSIX ）；</p>
<p>发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。</p>
<p>POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。</p>
<h4 id="1-5-2-历史"><a href="#1-5-2-历史" class="headerlink" title="1.5.2 历史"></a>1.5.2 历史</h4><p>POSIX是Unix的标准。</p>
<p>1974年，贝尔实验室正式对外发布Unix。因为涉及到反垄断等各种原因，加上早期的Unix不够完善，于是贝尔实验室以慷慨的条件向学校提供源代码，所以Unix在大专院校里获得了很多支持并得以持续发展。</p>
<p>于是出现了好些独立开发的与Unix基本兼容但又不完全兼容的OS，通称Unix-like OS。包括：</p>
<ol>
<li>美国加州大学伯克利分校的Unix4.xBSD(Berkeley Software Distribution)。</li>
<li>贝尔实验室发布的自己的版本，称为System V Unix。</li>
<li>其他厂商的版本，比如Sun Microsystems的Solaris系统,则是从这些原始的BSD和System V版本中衍生而来。</li>
</ol>
<p>20世纪80年代中期，Unix厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同。</p>
<p>为了提高兼容性和应用程序的可移植性，阻止这种趋势， IEEE开始努力标准化Unix的开发，后来由 Richard Stallman命名为<code>Posix</code>。</p>
<p>这套标准涵盖了很多方面，比如Unix系统调用的C语言接口、shell程序和工具、线程及网络编程。</p>
<h4 id="1-5-3-可移植性"><a href="#1-5-3-可移植性" class="headerlink" title="1.5.3 可移植性"></a>1.5.3 可移植性</h4><h5 id="①-系统调用和库函数"><a href="#①-系统调用和库函数" class="headerlink" title="① 系统调用和库函数"></a>① 系统调用和库函数</h5><p>Linux下对文件操作有两种方式：<strong>系统调用</strong>（system call）和<strong>库函数调用</strong>（Library functions）。</p>
<ul>
<li>系统调用：系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。</li>
<li>库函数调用：库函数（Library function）是把函数放到库里，供别人使用的一种方式。</li>
</ul>
<p>方法是把一些常用到的函数编完放到一个文件里，供不同的人进行调用。一般放在<code>.lib</code>文件中。</p>
<p>库函数调用则是面向应用开发的，库函数可分为两类：</p>
<ol>
<li>一类是C语言标准规定的库函数，</li>
<li>一类是编译器特定的库函数。</li>
</ol>
<p>(由于版权原因，库函数的源代码一般是不可见的，但在头文件中你可以看到它对外的接口)。</p>
<p><code>glibc</code> 是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库，即运行时库。这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的。</p>
<p>glibc 为程序员提供丰富的 API（Application Programming Interface），这些API都是遵循POSIX标准的，API的函数名，返回值，参数类型等都必须按照POSIX标准来定义。</p>
<p><strong>POSIX兼容也就指定这些接口函数兼容，但是并不管API具体如何实现。</strong></p>
<h5 id="②-区别"><a href="#②-区别" class="headerlink" title="② 区别"></a>② 区别</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-3a61e1a67e92a89bd5a4e5f050ee406f_r.jpg" alt="img"></p>
<p>如上图所示：</p>
<ul>
<li>库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分</li>
<li>库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系统调用属于系统时间，库函数开销较小，系统调用开销较大</li>
<li>系统调用依赖于平台，库函数并不依赖</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>函数库调用</th>
<th>系统调用</th>
</tr>
</thead>
<tbody>
<tr>
<td>定义差别</td>
<td>在所有的ANSI C编译器版本中，C函数库是相同的</td>
<td>各个操作系统的系统调用是不同的</td>
</tr>
<tr>
<td>调用差别</td>
<td>它调用函数库中的一段程序或函数</td>
<td>调用系统内核的服务</td>
</tr>
<tr>
<td>运行空间</td>
<td>用户地址空间</td>
<td>内核地址空间</td>
</tr>
<tr>
<td>开销</td>
<td>属于过程调用，开销小</td>
<td>需要在用户空间和内核空间上下文切换，开销较大</td>
</tr>
<tr>
<td>个数</td>
<td>在C函数库libc中大约有300个函数</td>
<td>在Linux中大约有100多个系统调用</td>
</tr>
<tr>
<td>典型调用</td>
<td>pringf，fread，malloc</td>
<td>chdir，fork，write，brk</td>
</tr>
</tbody>
</table>
</div>
<p><strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。</strong></p>
<p><strong>库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性好。</strong></p>
<h4 id="1-5-4-实例"><a href="#1-5-4-实例" class="headerlink" title="1.5.4 实例"></a>1.5.4 实例</h4><p>当应用程序调用printf()函数时，printf函数会调用C库中的printf，继而调用C库中的write，C库最后调用内核的write()。</p>
<p>而另一些则不会使用系统调用，比如strlen, strcat, memcpy等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-7f5eb3c97342632b5975493cbdd45b9f_r.jpg" alt="img"></p>
<p>printf函数执行过程中，程序运行状态切换如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户态–&gt;系统调用–&gt;内核态–&gt;返回用户态</span><br></pre></td></tr></table></figure>
<p>printf函数、glibc库和系统调用在系统中关系图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/v2-a8315ef7d9a895bb4649fe3cd6f3e96a_r.jpg" alt="img"></p>
<h2 id="2-标准IO"><a href="#2-标准IO" class="headerlink" title="2 标准IO"></a>2 标准IO</h2><p>该节对应<code>APUE</code>的第五章——标准IO库</p>
<h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>IO分为标准IO（<code>stdio</code>）和系统调用IO（<code>sysio</code>）；</p>
<p>系统调用IO根据操作系统的实现方式而定，对于程序员来说会造成很大困扰（例如打开文件，Linux的系统调用为<code>open</code>，而Windows的系统调用为<code>opendir</code>），于是又有了标准IO，提供了一套标准的IO实现的库函数（例如<code>pringtf</code>，<code>fopen</code>等），它实际上也是调用了系统IO进行操作，但是屏蔽了系统调用IO，方便程序员调用。</p>
<p>常用的标准IO库函数如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>打开关闭文件</th>
<th>输入输出流</th>
<th>文件指针操作</th>
<th>缓存相关</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fopen</code></td>
<td><code>fgetc</code>,<code>fputc</code></td>
<td><code>fseek</code></td>
<td><code>fflush</code></td>
</tr>
<tr>
<td><code>fclose</code></td>
<td><code>fgets</code>,<code>fputs</code></td>
<td><code>ftell</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>fread</code>,<code>fwrite</code></td>
<td><code>rewind</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td><code>printf</code>族,<code>scanf</code>族</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>注意<code>FILE</code>类型贯穿始终；</p>
<h3 id="2-2-fopen"><a href="#2-2-fopen" class="headerlink" title="2.2 fopen"></a>2.2 fopen</h3><p>C 库函数 <code>fopen</code> 使用给定的模式 <strong>mode</strong> 打开 <strong>filename</strong> 所指向的文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>filename</strong> — 字符串，表示要打开的文件名称。</li>
<li><strong>mode</strong> — 字符串，表示文件的访问模式，该指针指向以下面字符开头的字符串：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">“r”</td>
<td style="text-align:left">打开一个用于读取的文件。该文件必须存在。</td>
</tr>
<tr>
<td style="text-align:left">“w”</td>
<td style="text-align:left">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。<strong>有则清空，无则创建</strong>。</td>
</tr>
<tr>
<td style="text-align:left">“a”</td>
<td style="text-align:left">追加到一个文件。写操作向<strong>文件末尾</strong>追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td style="text-align:left">“r+”</td>
<td style="text-align:left">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td style="text-align:left">“w+”</td>
<td style="text-align:left">创建一个用于读写的空文件。</td>
</tr>
<tr>
<td style="text-align:left">“a+”</td>
<td style="text-align:left">打开一个用于读取和追加的文件。</td>
</tr>
</tbody>
</table>
</div>
<p>只有模式<code>r</code>和<code>r+</code>要求文件必须存在，其他模式都是有则清空，无则创建；</p>
<p><strong>mode</strong>也可以包含字母<code>b</code>，放在最后或者中间，表示二进制流。例如<code>“rb”</code>，<code>“r+b”</code>；</p>
<ul>
<li>该函数返回一个 FILE 指针。否则返回 NULL，且设置<strong>全局变量</strong> <code>errno</code> 来标识错误。该全局变量在头文件<code>errno.h</code>中声明：（只展示部分）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPERM 1 <span class="comment">/* Operation not permitted */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENOENT 2 <span class="comment">/* No such file or directory */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESRCH 3 <span class="comment">/* No such process */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EINTR 4 <span class="comment">/* Interrupted system call */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EIO 5 <span class="comment">/* I/O error */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENXIO 6 <span class="comment">/* No such device or address */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E2BIG 7 <span class="comment">/* Argument list too long */</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen() failed! errno = %d.\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译执行后打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen() failed! errno = 2.</span><br></pre></td></tr></table></figure>
<p>可知<code>errno</code>为2，为<code>No such file or directory</code>；</p>
<p>在C标准中定义了两个函数帮助打印输出errno的对应错误原因，一个是<code>strerror</code>，另一个是<code>perror</code>；</p>
<hr>
<p>perror包含在<code>stdio.h</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*功能：根据error打印对应的错误信息</span></span><br><span class="line"><span class="comment">*参数：s: 用户自定义信息字符串，一般是出错的函数名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改后的程序为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// fprintf(stderr, &quot;fopen() failed! errno = %d.\n&quot;, errno);</span></span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fopen(): No such file or directory</span><br></pre></td></tr></table></figure>
<hr>
<p><code>strerror</code>包含在<code>&lt;string.h&gt;</code>头文件中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数原型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*功能：将某个错误代码转换成对应的错误信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnuum)</span></span>;</span><br></pre></td></tr></table></figure>
<p>修改后的程序为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fopen:%s\n&quot;</span>, strerror(errno));</span><br></pre></td></tr></table></figure>
<hr>
<p>fopen函数解析：</p>
<p>由函数原型可知，fopen函数返回的是一个FILE类型的指针，FILE是一个结构体，由<code>typedef</code>进行了重命名，而指针实际上是指向结构体的指针。</p>
<p>问题：指针指向的内存空间是哪一块（或者说FILE结构体放在内存的哪一块）？是堆，是栈，还是静态区？</p>
<ul>
<li>栈</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp.xxx = xxx;</span><br><span class="line">    tmp.yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：<code>tmp</code>变量的存储类别是自动类型（块作用域，自动存储期），当程序退出这个块时，<strong>释放刚才为变量tmp匹配的内存</strong>，因此，指针指向的地址实际上没有tmp，是一个没有被分配的内存；</p>
<ul>
<li>静态区</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FILE tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp.xxx = xxx;</span><br><span class="line">    tmp.yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上<code>static</code>，将tmp保存在静态区（静态无链接），但是只能存在一个FILE实例（因为只有这一个内存区供指针指向）；例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp1 = fopen(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">fp2 = fopen(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="comment">// 此时fp1实际指向了b，第二次的结果会把第一次的结果覆盖掉</span></span><br></pre></td></tr></table></figure>
<ul>
<li>堆（正解）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的fopen源码分析</span></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    FILE *tmp = <span class="literal">NULL</span>;</span><br><span class="line">    tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(FILE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp-&gt;xxx = xxx;</span><br><span class="line">    tmp-&gt;yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时变量<code>tmp</code>具有动态存储期，从调用<code>malloc</code>分配内存到调用<code>free</code>释放内存为止，而<code>free</code>就在<code>fclose</code>函数中被调用。</p>
<h3 id="2-3-fclose"><a href="#2-3-fclose" class="headerlink" title="2.3 fclose"></a>2.3 fclose</h3><p>C 库函数 <code>fclose</code> 关闭流 stream。刷新所有的缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了要被关闭的流。</li>
<li>如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;tmp&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;OK!&quot;</span>);</span><br><span class="line">    fclose(fp); <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-fgetc和fputc"><a href="#2-4-fgetc和fputc" class="headerlink" title="2.4 fgetc和fputc"></a>2.4 fgetc和fputc</h3><ul>
<li><code>getchar</code>和<code>putchar</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 从标准输入 stdin 获取一个字符（一个无符号字符）。这等同于 getc 带有 stdin 作为参数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到标准输出 stdout 中。这等同于 putc 带有 stdout 作为参数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>getc</code>和<code>putc</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>; <span class="comment">// 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。 </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>fgetc</code>和<code>fputc</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>; <span class="comment">// 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。</span></span><br><span class="line"><span class="comment">// 该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span>; <span class="comment">// 把参数 char 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。</span></span><br><span class="line"><span class="comment">// 如果没有发生错误，则返回被写入的字符。如果发生错误，则返回 EOF，并设置错误标识符。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getc</code>，<code>putc</code>和<code>fgetc</code>，<code>fputc</code>的区别</p>
</blockquote>
<p>两者的使用完全相同，只是实现不同。这里的<code>f</code>指的是<code>function</code>，而不是<code>file</code>。</p>
<p><code>getc</code>，<code>putc</code>是通过<strong>宏定义</strong>实现，而<code>fgetc</code>，<code>fputc</code>是通过<strong>函数</strong>来实现。</p>
<p>宏只占用编译时间，不占用调用时间，而函数相反，因此内核的实现通常使用宏来定义函数，减少调用时间。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：拷贝文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy src dest</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行传参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">int</span> ch; <span class="comment">// 存储读入的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        ch = fgetc(fps);</span><br><span class="line">        <span class="keyword">if</span>(ch == EOF) &#123; <span class="comment">// 读到文件末尾结束循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fputc(ch, fpd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 释放内存，后开的先关</span></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mycpy /usr/<span class="built_in">local</span>/<span class="built_in">test</span> /temp/out</span><br></pre></td></tr></table></figure>
<h3 id="2-5-fgets和fputs"><a href="#2-5-fgets和fputs" class="headerlink" title="2.5 fgets和fputs"></a>2.5 fgets和fputs</h3><ul>
<li><code>gets</code>和<code>puts</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *str)</span></span>; <span class="comment">// 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span></span><br><span class="line"><span class="comment">// 如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>; <span class="comment">// 把一个字符串写入到标准输出 stdout，直到空字符，但不包括空字符。换行符会被追加到输出中。</span></span><br><span class="line"><span class="comment">// 如果成功，该函数返回一个非负值为字符串长度（包括末尾的 \0），如果发生错误则返回 EOF。</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>fgets</code>和<code>fputs</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n, FILE *stream)</span></span>; </span><br><span class="line"><span class="comment">// 如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。</span></span><br><span class="line"><span class="comment">// 如果发生错误，返回一个空指针。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  把字符串写入到指定的流 stream 中，但不包括空字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">// 该函数返回一个非负值，如果发生错误则返回 EOF。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>区别</p>
</blockquote>
<p> <code>fgets</code>比<code>gets</code>安全，使用<code>gets</code>编译时会警告。所以不要使用<code>gets</code>！</p>
<p>原因：函数 gets 可以<strong>无限读取</strong>，不会判断上限，所以程序员应该确保 buffer 的空间足够大，以便在执行读操作时不发生溢出。也就是说，gets 函数并不检查缓冲区 buffer 的空间大小，事实上它也无法检查缓冲区的空间。</p>
<p>如果函数的调用者提供了一个指向堆栈的指针，并且 gets 函数读入的字符数量超过了缓冲区的空间（即发生溢出），gets 函数会将多出来的字符继续写入堆栈中，这样就覆盖了堆栈中原来的内容，破坏一个或多个不相关变量的值。</p>
<hr>
<p><code>fgets</code>读取结束的条件，满足其一即可：</p>
<ul>
<li>读到<code>size-1</code>个字符时停止</li>
<li>读到换行符<code>&#39;\n&#39;</code>时停止</li>
<li>读到文件末尾<code>EOF</code></li>
</ul>
<blockquote>
<p>简单的实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="keyword">char</span> buf[SIZE];</span><br><span class="line">fgets(buf, SIZE, stream);</span><br><span class="line"></span><br><span class="line">如果stream = <span class="string">&quot;abcde&quot;</span></span><br><span class="line">则buf = <span class="string">&quot;abcd\0&quot;</span>(读到size<span class="number">-1</span>)，文件指针指向e</span><br><span class="line"></span><br><span class="line">如果stream = <span class="string">&quot;ab&quot;</span></span><br><span class="line">则buf = <span class="string">&quot;ab\n\0&quot;</span>(读到换行符)，文件指针指向EOF</span><br><span class="line"></span><br><span class="line">极端的情况：</span><br><span class="line">如果stream = <span class="string">&quot;abcd&quot;</span></span><br><span class="line">则需要fgets读取两次才能读完</span><br><span class="line">第一次读取的为<span class="string">&quot;abcd\0&quot;</span>(读到SIZE<span class="number">-1</span>)，指针指向<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">第二次读取的为<span class="string">&quot;\n\0&quot;</span>(读到换行符)，指针指向EOF</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用<code>fgets</code>和<code>fputs</code>代替<code>fgtec</code>和<code>fputc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">char</span> buf[SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, SIZE, fps) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">fputs</span>(buf, fpd);</span><br><span class="line"></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-fread和fwrite"><a href="#2-6-fread和fwrite" class="headerlink" title="2.6 fread和fwrite"></a>2.6 fread和fwrite</h3><p><code>fread</code>从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向带有最小尺寸 <code>size*nmemb</code> 字节的内存块的指针。</li>
<li><strong>size</strong> — 这是要读取的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li>
</ul>
<ul>
<li>成功读取的<strong>元素总数</strong>会以 size_t 对象返回，size_t 对象是一个整型数据类型。如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾。</li>
</ul>
<p><code>fwrite</code>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> — 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
<li>如果成功，该函数返回一个 size_t 对象，表示元素的总数，该对象是一个整型数据类型。如果该数字与 nmemb 参数不同，则会显示一个错误。</li>
</ul>
<blockquote>
<p>简单的实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fread(buf, size, nmemb, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：数据量足够</span></span><br><span class="line"><span class="comment">// 情况2：文件只有5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读10个对象，每个对象1个字节</span></span><br><span class="line">fread(buf, <span class="number">1</span>, <span class="number">10</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：</span></span><br><span class="line"><span class="comment">// 第一次读：返回10（读到10个对象），读到10个字节</span></span><br><span class="line"><span class="comment">// 情况2：</span></span><br><span class="line"><span class="comment">// 第一次读：返回5（读到5个对象），读到5个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读1个对象，每个对象10个字节</span></span><br><span class="line">fread(buf, <span class="number">10</span>, <span class="number">1</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况1：</span></span><br><span class="line"><span class="comment">// 第一次读：返回1（读到1个对象），也读到10个字节</span></span><br><span class="line"><span class="comment">// 情况2：</span></span><br><span class="line"><span class="comment">// 第一次读：返回0（读不到1个对象，因为1个对象要10字节，而文件只有5个字节）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用<code>fread</code>和<code>fwrite</code>代替<code>fgtec</code>和<code>fputc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fps, *fpd;</span><br><span class="line">    <span class="keyword">char</span> buf[SIZE];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage:%s &lt;src_file&gt; &lt;dest_file&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fps = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fps == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fpd = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fpd == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(fps);</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果成功读到n(n&gt;0)个对象，则返回n</span></span><br><span class="line">    <span class="comment">// 将这n个对象写入流中</span></span><br><span class="line">    <span class="keyword">while</span>((n = fread(buf, <span class="number">1</span>, SIZE, fps)) &gt; <span class="number">0</span>) </span><br><span class="line">            fwrite(buf, <span class="number">1</span>, n, fpd);</span><br><span class="line"></span><br><span class="line">    fclose(fpd);</span><br><span class="line">    fclose(fps);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-printf和scanf"><a href="#2-7-printf和scanf" class="headerlink" title="2.7 printf和scanf"></a>2.7 printf和scanf</h3><blockquote>
<p><code>printf</code>一族函数</p>
</blockquote>
<ul>
<li><code>printf</code>：发送格式化输出到标准输出 stdout。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fprintf</code>：发送格式化输出到流 stream 中。可以实现格式化输出的<strong>重定向</strong>，例如重定向至文件中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sprintf</code>：发送格式化输出到 <strong>str</strong> 所指向的字符串。它能够将多种数据类型（整型、字符型）的数据综合为字符串类型。有溢出风险，可以使用<code>snprintf</code>来防止。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>atoi</code>：把参数 <strong>str</strong> 所指向的字符串转换为一个整数（类型为 int 型）。包含在<code>stdlib.h</code>中。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atoi</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(str)); <span class="comment">// 123456</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;123a456&quot;</span>;</span><br><span class="line">	<span class="comment">// 遇到字符就停止</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, atoi(str)); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> year = <span class="number">2022</span>, month = <span class="number">11</span>, day = <span class="number">28</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将格式化输出重定向为字符串</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">&quot;%d-%d-%d&quot;</span>, year, month, day);</span><br><span class="line">    <span class="built_in">puts</span>(buf);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>scanf</code>一族函数</p>
</blockquote>
<ul>
<li><code>scanf</code></li>
<li><code>fscanf</code></li>
<li><code>sscanf</code></li>
</ul>
<h3 id="2-8-fseek和ftell"><a href="#2-8-fseek和ftell" class="headerlink" title="2.8 fseek和ftell"></a>2.8 fseek和ftell</h3><p><code>fseek</code>：设置流 <strong>stream</strong> 的文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> <span class="keyword">int</span> offset, <span class="keyword">int</span> whence)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>offset</strong> — 这是相对 whence 的偏移量，以<strong>字节</strong>为单位。</li>
<li><strong>whence</strong> — 这是表示开始添加偏移 offset 的位置。它一般指定为下列常量之一：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>SEEK_SET</code></td>
<td style="text-align:left">文件的开头</td>
</tr>
<tr>
<td style="text-align:left"><code>SEEK_CUR</code></td>
<td style="text-align:left">文件指针的当前位置</td>
</tr>
<tr>
<td style="text-align:left"><code>SEEK_END</code></td>
<td style="text-align:left">文件的末尾</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>如果成功，则该函数返回零，否则返回非零值。</li>
</ul>
<hr>
<p><code>ftell</code>：返回给定流 stream 的当前文件位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li>该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。</li>
</ul>
<blockquote>
<p>程序实例——求程序的有效字节</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 将指针定位在文件末尾</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ftell(fp));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221130104327899.png" alt="image-20221130104327899"></p>
<hr>
<p><code>rewind</code>：设置文件位置为给定流 <strong>stream</strong> 的文件的开头。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<p>相当于<code>(void) fseek(stream, 0, SEEK_SET);</code></p>
<blockquote>
<p>注意</p>
</blockquote>
<p><code>fseek</code>和<code>ftell</code>中偏移<code>offset</code>的修饰类型是<code>long</code>，因此只能对2G左右大小的文件进行操作，否则会超出<code>long</code>的范围；</p>
<p><code>fseeko</code>和<code>ftello</code>则将偏移的修饰类型使用<code>typedef</code>定义为<code>offset_t</code>，具体类型交由系统决定，因此不存在文件大小的限制。但是这两个函数不是C标准库函数，而是隶属于POSIX标准（POSIX是标准C库的超集，或者说，C库是普通话，而POSIX是方言）。</p>
<h3 id="2-9-fflush"><a href="#2-9-fflush" class="headerlink" title="2.9 fflush"></a>2.9 fflush</h3><p><code>fflush</code>：刷新流 stream 的<strong>输出缓冲区</strong>。刷新，指的是将缓冲区（内存上的一片区域）的内容写入到磁盘（外存）中，或者输出到终端上显示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果参数为<code>NULL</code>，则刷新所有的已打开的流</li>
<li>如果成功，该函数返回零值。如果发生错误，则返回 EOF，且设置错误标识符（即 feof）。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before while(1)&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After while(1)&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 什么都不打印</span></span><br></pre></td></tr></table></figure>
<p>原因：</p>
<ul>
<li>对于标准输出，输出缓冲区刷新的时机：<ul>
<li>输出缓冲区满</li>
<li>或者遇到换行符<code>\n</code></li>
<li>强制刷新，或者进程结束</li>
</ul>
</li>
</ul>
<p>因此，可以修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遇到\n刷新</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before while(1)\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After while(1)\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者修改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before while(1)&quot;</span>);</span><br><span class="line">    <span class="comment">// 强制刷新</span></span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="comment">// 或者 fflush(NULL);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After while(1)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>缓冲区的作用：大多数情况下是好事，合并系统调用，增加程序的吞吐量。</p>
<p>缓冲的分类：</p>
<ul>
<li>行缓冲<code>line buffered</code>：针对标准输出（终端设备），有换行刷新，缓冲满刷新，强制刷新三种，后两个和全缓冲一致；</li>
<li>全缓冲<code>fully buffered</code>：默认缓冲机制（除标准输出【终端设备】，例如重定向到文件），有缓冲满刷新，强制刷新两种，强制刷新例如调用<code>fflush</code>函数，或者进程结束时也会强制刷新；此时换行符仅仅只是个换行符，没有刷新功能；</li>
<li>无缓冲<code>unbuffered</code>：例如<code>stderr</code>，需要立即输出，数据会立即读入内存或者输出到外存文件和设备上；</li>
</ul>
<p><code>setvbuf</code>：定义流 stream 应如何缓冲。理解即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了一个打开的流。</li>
<li><strong>buffer</strong> — 这是分配给用户的缓冲。如果设置为 NULL，该函数会自动分配一个指定大小的缓冲。</li>
<li><strong>mode</strong> — 这指定了文件缓冲的模式：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">_IOFBF</td>
<td style="text-align:left"><strong>全缓冲</strong>：对于输出，数据在缓冲填满时被一次性写入。对于输入，缓冲会在请求输入且缓冲为空时被填充。</td>
</tr>
<tr>
<td style="text-align:left">_IOLBF</td>
<td style="text-align:left"><strong>行缓冲</strong>：对于输出，数据在遇到换行符或者在缓冲填满时被写入，具体视情况而定。对于输入，缓冲会在请求输入且缓冲为空时被填充，直到遇到下一个换行符。</td>
</tr>
<tr>
<td style="text-align:left">_IONBF</td>
<td style="text-align:left"><strong>无缓冲</strong>：不使用缓冲。每个 I/O 操作都被即时写入。buffer 和 size 参数被忽略。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-10-getline"><a href="#2-10-getline" class="headerlink" title="2.10 getline"></a>2.10 getline</h3><p>之前介绍的函数，都不能获得完整的一整行（有缓冲区大小的限制），而下面介绍的<code>getline</code>函数则可以动态分配内存，当装不下完整一行时，又会申请额外的内存来存储。</p>
<p><code>getline</code>是C++标准库函数，但不是C标准库函数，而是POSIX所定义的标准库函数（在POSIX IEEE Std 1003.1-2008标准出来之前，则只是GNU扩展库里的函数）。在gcc编译器中，对标准库<code>stdio</code>进行了扩展，加入了一个getline函数。</p>
<p><code>getline</code>会生成一个包含一串从输入流读入的字符的字符串，直到以下情况发生会导致生成的此字符串结束：</p>
<ul>
<li>到文件结束</li>
<li>遇到函数的定界符</li>
<li>输入达到最大限度</li>
</ul>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE <span class="comment">// 通常将这种宏写在makefile中，现在的编译器没有了该宏，直接使用即可</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">getline</span><span class="params">(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>lineptr</code>：指向存放该行字符的指针，如果是NULL，则有系统帮助malloc，请在使用完成后free释放。该参数是一个二级指针，因此传参需要一级指针的地址。即函数会把读取到的字符串的首地址存放在一级指针中。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传参：</span></span><br><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="comment">// 函数内的实际操作：</span></span><br><span class="line"><span class="comment">// 假设读取到的字符串Hello的首地址为0x000</span></span><br><span class="line">&amp;ptr = <span class="number">0x000</span>; <span class="comment">// 此时ptr就指向了Hello</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>n</code>：如果是由系统malloc的指针填0；</p>
</li>
<li><p><code>stream</code>：函数需要读取的FILE流</p>
</li>
<li><p>返回值：成功返回读取的字节数，失败或读完返回-1。</p>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="comment">// 一定要初始化，否则指针会指向内存中的随机位置</span></span><br><span class="line">    <span class="keyword">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linesize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 当返回-1时则读完</span></span><br><span class="line">    	<span class="keyword">if</span>(getline(&amp;linebuf, &amp;linesize, fp) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">       	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">strlen</span>(linebuf));</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-11-临时文件"><a href="#2-11-临时文件" class="headerlink" title="2.11 临时文件"></a>2.11 临时文件</h3><p>临时文件产生的问题：</p>
<ul>
<li>如何命名不冲突</li>
<li>如何保证及时销毁</li>
</ul>
<hr>
<p><code>tmpnam</code>：生成并返回一个有效的临时文件名，该文件名之前是不存在的。如果 <strong>str</strong> 为空，则只会返回临时文件名。</p>
<p>存在并发问题，可能会产生两个或多个名字相同的临时文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>str</strong> — 这是一个指向字符数组的指针，其中，临时文件名将被存储为 C 字符串。</li>
<li>返回一个指向 C 字符串的指针，该字符串存储了临时文件名。如果 str 是一个空指针，则该指针指向一个内部缓冲区，缓冲区在下一次调用函数时被覆盖。</li>
<li>如果 str 不是一个空指针，则返回 str。如果函数未能成功创建可用的文件名，则返回一个空指针。</li>
</ul>
<hr>
<p><code>tmpfile</code>：以二进制更新模式(<code>wb+</code>)创建临时文件。被创建的临时文件会在流关闭的时候或者在程序终止的时候自动删除。</p>
<p>该文件没有名字（匿名文件）只返回指向FILE的指针，因此不存在命名冲突的问题，同时会自动删除，因此可以及时销毁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果成功，该函数返回一个指向被创建的临时文件的流指针。如果文件未被创建，则返回 NULL。</li>
</ul>
<h2 id="3-系统调用IO"><a href="#3-系统调用IO" class="headerlink" title="3 系统调用IO"></a>3 系统调用IO</h2><p>该节对应<code>APUE</code>的第三章——文件IO</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221201160144166.png" alt="image-20221201160144166"></p>
<h3 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1 简介"></a>3.1 简介</h3><p>UNIX系统的大多数文件IO只需用到5个函数：</p>
<ul>
<li><code>open</code></li>
<li><code>close</code></li>
<li><code>read</code></li>
<li><code>write</code></li>
<li><code>lseek</code></li>
</ul>
<h3 id="3-2-文件描述符"><a href="#3-2-文件描述符" class="headerlink" title="3.2 文件描述符"></a>3.2 文件描述符</h3><h4 id="3-2-1-FILE结构体"><a href="#3-2-1-FILE结构体" class="headerlink" title="3.2.1 FILE结构体"></a>3.2.1 FILE结构体</h4><p>查看<code>stdio.h</code>头文件中，有<code>FILE</code>结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stdio.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">iobuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>*  _ptr;        <span class="comment">//文件输入的下一个位置</span></span><br><span class="line">    <span class="keyword">int</span>    _cnt;        <span class="comment">//当前缓冲区的相对位置</span></span><br><span class="line">    <span class="keyword">char</span>*  _base;       <span class="comment">//文件初始位置</span></span><br><span class="line">    <span class="keyword">int</span>    _flag;       <span class="comment">//文件标志</span></span><br><span class="line">    <span class="keyword">int</span>    _file;       <span class="comment">//文件有效性</span></span><br><span class="line">    <span class="keyword">int</span>    _charbuf;    <span class="comment">//缓冲区是否可读取</span></span><br><span class="line">    <span class="keyword">int</span>    _bufsiz;     <span class="comment">//缓冲区字节数</span></span><br><span class="line">    <span class="keyword">char</span>*  _tmpfname;   <span class="comment">//临时文件名</span></span><br><span class="line">&#125; FILE;</span><br></pre></td></tr></table></figure>
<p>其中<code>_file</code>就是文件描述符。</p>
<h4 id="3-2-2-文件描述符"><a href="#3-2-2-文件描述符" class="headerlink" title="3.2.2 文件描述符"></a>3.2.2 文件描述符</h4><p>文件描述符（<code>fd</code>，<code>file descriptor</code>）是文件IO（系统IO）中贯穿始终的类型。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221201164844626.png" alt="image-20221201164844626"></p>
<ul>
<li>当某一个进程执行系统调用<code>open</code>函数，会创建一个结构体，该结构体类似于FILE结构体，其中最基本的成员有一个指针<code>pos</code>，用于指向<code>inode</code>文件的某一个位置；</li>
<li><p>同时，该进程会维护一个数组（文件描述符表），该数组存储上述结构体的地址，而<strong>数组下标就是文件描述符</strong><code>fd</code>，即<strong>文件描述符的本质就是一个整型数</strong>；</p>
<ul>
<li>该数组默认大小为1024，即可以打开的最大文件数量为1024，但可以设置<code>ulimit</code>来更改数组大小；注意该数组和对应产生的结构体只存在于这个进程空间内，而不是进程间共享；</li>
<li>当调用<code>open</code>函数时，系统会自动打开三个流<code>stdin</code>，<code>stdout</code>和<code>stderr</code>，这三个流分别占据该数组的<code>0,1,2</code>号位置；</li>
<li>结构体FILE中的成员<code>_file</code>就是整型数组下标<code>fd</code>，即文件描述符</li>
<li>每打开一个新文件，则占用一个数组空间，而且是空闲的最小的数组下标。即文件描述符优先使用当前可用范围内<strong>最小</strong>的。同一个文件可以被多次打开，但是每打开一次都需要一个新的文件描述符和新的结构体，例如图中的结构体1和结构体2，指向了同一个inode；</li>
</ul>
</li>
<li><p>执行系统调用<code>close</code>时，就将对应fd下标的数组空间清除掉，并清除该地址指向的结构体；</p>
</li>
<li>结构体中有一个成员用于记录<strong>引用计数</strong>，例如图中，将5号位置的<code>0x006</code>地址复制一份存储在6号位置，此时有两个指针指向了同一个结构体3，此时结构体3的引用计数为2，当5号指针<code>free</code>时，结构体3的引用计数减1为1，不为0，则不会释放掉，否则6号位置的指针将成为<strong>野指针</strong>；</li>
</ul>
<h3 id="3-3-open和close"><a href="#3-3-open和close" class="headerlink" title="3.3 open和close"></a>3.3 open和close</h3><h4 id="3-3-1-文件权限"><a href="#3-3-1-文件权限" class="headerlink" title="3.3.1 文件权限"></a>3.3.1 文件权限</h4><h5 id="①-rwx"><a href="#①-rwx" class="headerlink" title="① rwx"></a>① rwx</h5><p>Linux下一切皆文件，不同的用户对文件拥有不同的权限。</p>
<p>文件具有三种权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwx    可读可写可执行,转换为数字就是421</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>针对文件</th>
<th>针对目录</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>是否可以查看文件内容</td>
<td>是否能够列出<code>ls</code>目录内容</td>
</tr>
<tr>
<td>w</td>
<td>是否可以编辑文件内容</td>
<td>是否能够创建、删除、复制、移动文档</td>
</tr>
<tr>
<td>x</td>
<td>是否能够执行该文件</td>
<td>是否可以进入目录和获得目录下文件的列表，要对目录下存在的文件进行读取和修改，必须要能进入目录，所以必须要目录有执行权限</td>
</tr>
</tbody>
</table>
</div>
<h5 id="②-文件属性"><a href="#②-文件属性" class="headerlink" title="② 文件属性"></a>② 文件属性</h5><p>查看当前目录下的所有文件的属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202132740517.png" alt="image-20221202132740517"></p>
<p>或者可以查看单个文件权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll atoi</span><br></pre></td></tr></table></figure>
<p>基本的文件属性格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 权限 链接数 属主 属组 大小 修改日期 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>类型和权限：<ul>
<li>第1列表示文件的类型：<code>dcb-lsp</code><ul>
<li><code>d</code>：目录</li>
<li><code>-</code>：普通文件</li>
<li><code>l</code>：软链接（类似Windows的快捷方式）</li>
<li><code>b</code>：块设备文件（例如硬盘、光驱等）</li>
<li><code>p</code>：管道文件</li>
<li><code>c</code>：字符设备文件（例如屏幕等串口设备）</li>
<li><code>s</code>：套接口文件</li>
</ul>
</li>
<li>第2至10列为文件或目录的权限，分为3组：<ul>
<li>拥有者权限<code>owner</code>：文件和文件目录的所有者</li>
<li>所属组<code>group</code>：文件和文件目录的所有者所在的组的其他用户</li>
<li>其它用户<code>other</code>：不属于上面的两个的用户</li>
</ul>
</li>
</ul>
</li>
<li>链接数：有多少文件名链接到此节点（i-node）；每个文件都会将它的权限与属性记录到文件系统的i-node中，不过我们使用的目录树却是使用文件名来记录，因此每个文件名就会连接到一个i-node，这个属性记录的就是有多少不同的文件名链接到相同的一个i-node号码。</li>
</ul>
<p>例如第一行的文件属性为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 root root 8496 Nov 28 14:54 atoi</span><br></pre></td></tr></table></figure>
<p>则为普通文件，拥有者有读写和执行权限，而所属组用户和其他用户只有读取和执行权限，没有写权限；属主和属组均为<code>root</code>；</p>
<h5 id="③-umask"><a href="#③-umask" class="headerlink" title="③ umask"></a>③ umask</h5><p>Linux具有默认权限：</p>
<ul>
<li><p>一个目录被创建，默认权限是<code>drwxrwxrwx</code>，即777</p>
</li>
<li><p>一个普通文件被创建，默认权限是<code>-rw-rw-rw-</code>，即666</p>
</li>
</ul>
<p>但实际上所创建的文件和目录，看到的权限往往不是上面这个值。原因就是创建文件或目录的时候还要受到 <code>umask</code> 的影响。umask值表明了需要从默认权限中去掉哪些权限来成为最终的默认权限值。</p>
<p>查看umask的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng io]<span class="comment"># umask</span></span><br><span class="line">0002</span><br></pre></td></tr></table></figure>
<p>可以看到umask值为0002</p>
<ul>
<li>第一个0与特殊权限（特殊权限的内容参见<code>6.6.2节</code>）有关，后三位<code>002</code>则与普通权限<code>rwx</code>有关</li>
<li><code>002</code>中第一个0与拥有者权限有关，表示从拥有者权限减0，也就是权限不变，所以文件的创建者的权限就是是默认权限<code>rw</code>（<code>6 - 0 = 0</code>）</li>
<li><code>002</code>中第二个0与组权限有关，表示从组的权限减0，所以组的权限也保持默认权限（rw）</li>
<li><code>002</code>最后一位2则与系统中其他用户的权限有关，由于w=2，所以需要从其他用户默认权限<code>rw</code>减去2，也就是去掉写（w）权限，则其他人的权限为rw - w = r（<code>6 - 2 = 4</code>，对应r权限）</li>
<li>最终，创建文件的最终默认权限为 <code>-rw-rw-r--</code> </li>
</ul>
<p>同理目录权限的计算也是如此。</p>
<p>也可以临时更改umask的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng io]<span class="comment"># umask 027</span></span><br><span class="line">[root@HongyiZeng io]<span class="comment"># umask</span></span><br><span class="line">027</span><br></pre></td></tr></table></figure>
<p>即去掉所属组用户的写权限，去掉其他用户的所有权限。</p>
<p>如果需要永久更改umask的话，需要修改文件<code>/etc/bashrc</code>中的umask值：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202134734807.png" alt="image-20221202134734807"></p>
<h4 id="3-3-2-open"><a href="#3-3-2-open" class="headerlink" title="3.3.2 open"></a>3.3.2 open</h4><p>安装<code>man</code>手册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y man-pages</span><br></pre></td></tr></table></figure>
<hr>
<p><code>open</code>用于打开或创建一个文件或者设备。</p>
<p>所在头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>函数原型1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>将准备打开的文件或是设备的名字作为参数path传给函数，flags用来指定文件访问模式。</li>
<li>open系统调用成功返回一个新的文件描述符，失败返回<code>-1</code>。</li>
</ul>
<p>其中，flags是由必需文件访问模式和可选模式一起构成的(通过按位或<code>|</code>)：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>必需部分</th>
<th>可选部分（只列出常用的）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>O_RDONLY</code>：以只读方式打开</td>
<td><code>O_CREAT</code>：按照参数<code>mode</code>给出的访问模式创建文件</td>
</tr>
<tr>
<td><code>O_WRONLY</code>：以只写方式打开</td>
<td><code>O_EXCL</code>：与<code>O_CREAT</code>一起使用，确保创建出文件，避免两个程序同时创建同一个文件，如文件存在则open调用失败</td>
</tr>
<tr>
<td><code>O_RDWR</code>：以读写方式打开</td>
<td><code>O_APPEND</code>：把写入数据追加在文件的末尾</td>
</tr>
<tr>
<td></td>
<td><code>O_TRUNC</code>：把文件长度设置为0，丢弃原有内容</td>
</tr>
<tr>
<td></td>
<td><code>O_NONBLOCK</code>：以非阻塞模式打开文件</td>
</tr>
</tbody>
</table>
</div>
<p>其中，对于可选部分，又分为文件创建选项和文件状态选项：</p>
<ul>
<li>文件创建选项：<code>O_CREAT</code>，<code>O_EXCL</code>，<code>O_NOCTTY</code>，<code>O_TRUNC</code></li>
<li>文件状态选项：除文件创建选项之外的选项</li>
</ul>
<blockquote>
<p>fopen和open的文件访问模式的联系</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r -&gt; O_RDONLY <span class="comment">// 只读存在的文件</span></span><br><span class="line">r+ -&gt; O_RDWR <span class="comment">// 读写存在的文件</span></span><br><span class="line">w -&gt; O_WRONLY|O_CREAT|O_TRUNC <span class="comment">// 只写，并且有则清空，无则创建</span></span><br><span class="line">w+ -&gt; O_RDWR|O_CREAT|O_TRUNC <span class="comment">// 读写，并且有则清空，无则创建</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<hr>
<p>函数原型2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> *path, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在第一种调用方式上，加上了第三个参数<code>mode</code>，主要是搭配<code>O_CREAT</code>使用，这个参数规定了属主、同组和其他人对文件的文件操作权限。只列出部分：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>S_IRUSR</code></td>
<td>读权限</td>
</tr>
<tr>
<td><code>S_IWUSR</code></td>
<td>写权限 ——文件属主</td>
</tr>
<tr>
<td><code>S_IXUSR</code></td>
<td>执行权限</td>
</tr>
</tbody>
</table>
</div>
<p>可以用数字设定法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数字</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>无权限</td>
</tr>
<tr>
<td>1</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>w</td>
</tr>
<tr>
<td>4</td>
<td>r</td>
</tr>
</tbody>
</table>
</div>
<p>注意mode还要和umask计算才能得出最终的权限；</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd = open(<span class="string">&quot;./file.txt&quot;</span>,O_WRONLY | O_CREAT, <span class="number">0600</span>);</span><br></pre></td></tr></table></figure>
<p>创建一个普通文件，权限为<code>0600</code>，拥有者有读写权限，组用户和其他用户无权限。</p>
<blockquote>
<p>补充：变参函数</p>
</blockquote>
<p>变参数函数的原型声明为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="title">VAFunction</span><span class="params">(type arg1, type arg2, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>变参函数可以接受不同类型的参数，也可以接受不同个数的参数。</p>
<p>参数可以分为两部分：个数确定的固定参数和个数可变的可选参数。函数至少需要一个固定参数，固定参数的声明和普通函数一样；可选参数由于个数不确定，声明时用 <code>...</code> 表示。固定参数和可选参数共同构成一个函数的参数列表。</p>
<p>以<code>printf</code>为例，它就是一个变参函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> i;    </span><br><span class="line">    <span class="keyword">int</span> len;    </span><br><span class="line">    va_list args; <span class="comment">/* va_list 即 char * */</span></span><br><span class="line">    </span><br><span class="line">    va_start(args, fmt);    </span><br><span class="line">    <span class="comment">/* 内部使用了 va_arg() */</span></span><br><span class="line">    len = <span class="built_in">vsprintf</span>(g_PCOutBuf,fmt,args);</span><br><span class="line">    </span><br><span class="line">    va_end(args);    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(g_PCOutBuf); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putc(g_PCOutBuf[i]);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-3-close"><a href="#3-3-3-close" class="headerlink" title="3.3.3 close"></a>3.3.3 close</h4><p><code>close</code>：关闭一个文件描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回 0 表示成功，或者 -1 表示有错误发生，并设值<code>errno</code>；</p>
<h3 id="3-4-read，write和lseek"><a href="#3-4-read，write和lseek" class="headerlink" title="3.4 read，write和lseek"></a>3.4 read，write和lseek</h3><p><code>read</code>所在头文件和函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>从与文件描述符fd相关联的文件中读取前count字节的内容，并且写入到数据区buf中</li>
<li>read系统调用返回的是实际读入的字节数，发生错误返回<code>-1</code></li>
</ul>
<p><code>write</code>所在头文件和函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>把缓存区buf中的前count字节写入到与文件描述符fd有关的文件中</li>
<li>write系统调用返回的是实际写入到文件中的字节数，发生错误返回<code>-1</code>，注意返回0不是发生错误，而是写入的字节数为0</li>
</ul>
<p><code>lseek</code>所在头文件和函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>lseek</code>设置文件位置为给定的偏移 <strong>offset</strong>，参数 offset 意味着从给定的 <strong>whence</strong> 位置查找的字节数。</p>
<p><code>whence</code>取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SEEK_SET</code></td>
<td>文件开头</td>
</tr>
<tr>
<td><code>SEEK_END</code></td>
<td>文件末尾</td>
</tr>
<tr>
<td><code>SEEK_CUR</code></td>
<td>文件当前位置</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>用系统调用io实现<code>mycpy</code>的功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 源文件和目标文件的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="comment">// 读写缓冲</span></span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="comment">// len：读文件的返回字节数</span></span><br><span class="line">    <span class="comment">// ret：写文件的返回字节数</span></span><br><span class="line">    <span class="comment">// pos：写文件的当前位置</span></span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以只读方式打开文件，打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以只读方式打开文件，有则清空，无则创建</span></span><br><span class="line">    <span class="comment">// 打开文件失败</span></span><br><span class="line">    <span class="keyword">if</span>((dfd = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(sfd);</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 读完文件</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 防止读到的字节没有完全写入文件</span></span><br><span class="line">        <span class="comment">// 保证读多少，就写多少</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;write()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 关闭文件描述符</span></span><br><span class="line">    close(dfd);</span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-IO效率"><a href="#3-5-IO效率" class="headerlink" title="3.5 IO效率"></a>3.5 IO效率</h3><ul>
<li><strong>文件I/O：</strong>文件I/O又称为无缓冲IO，低级磁盘I/O，遵循POSIX相关标准。任何兼容POSIX标准的操作系统上都支持文件I/O。</li>
<li><strong>标准I/O：</strong>标准I/O是ANSI C建立的一个标准I/O模型，又称为高级磁盘I/O，是一个标准函数包和stdio.h头文件中的定义，具有一定的可移植性。标准I/O库处理很多细节。例如缓存分配，以优化长度执行I/O等。标准的I/O提供了三种类型的缓存（行缓存、全缓存和无缓存）。</li>
</ul>
<p>Linux 中使用的是<code>GLIBC</code>，它是标准C库的超集。不仅包含ANSI C中定义的函数，还包括POSIX标准中定义的函数。因此，Linux 下既可以使用标准I/O，也可以使用文件I/O。</p>
<p>缓存是内存上的某一块区域。缓存的一个作用是<strong>合并系统调用</strong>，即将多次的标准IO操作合并为一个系统调用操作。</p>
<p>文件IO不使用缓存，每次调用读写函数时，从用户态切换到内核态，对磁盘上的实际文件进行读写操作，因此<strong>响应速度快</strong>，坏处是频繁的系统调用会<strong>增加系统开销（用户态和内核态来回切换）</strong>，例如调用<code>write</code>写入一个字符时，磁盘上的文件中就多了一个字符。</p>
<p>标准IO使用缓存，未刷新缓冲前的多次读写时，实际上操作的是内存上的缓冲区，与磁盘上的实际文件无关，直到刷新缓冲时，才调用一次文件IO，从用户态切换到内核态，对磁盘上的实际文件进行操作。因此标准IO<strong>吞吐量大</strong>，相应的响应时间比文件IO长。但是差别不大，<strong>建议使用标准IO来操作文件</strong>。</p>
<hr>
<p>两种IO可以相互转化：</p>
<p><code>fileno</code>：返回结构体FILE的成员<code>_file</code>，即文件描述符。<code>标准IO-&gt;文件IO</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>fdopen</code>：通过文件描述符fd，返回FILE结构体。<code>文件IO-&gt;标准IO</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>注意：即使对同一个文件，也不要混用两种IO，否则容易发生错误。</p>
<p>原因：FILE结构体的<code>pos</code>和进程中的结构体的<code>pos</code>基本上不一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="comment">// 连续写入两个字符</span></span><br><span class="line">fputc(fp) -&gt; pos++</span><br><span class="line">fputc(fp) -&gt; pos++    </span><br></pre></td></tr></table></figure>
<p>但是，进程维护的结构体中的<code>pos</code>并未加2；只有刷新缓冲区时，该<code>pos</code>才会加2；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bbbaaa</span><br></pre></td></tr></table></figure>
<p>解析：遇到文件IO则立即输出，遇到标准IO，则需要等待缓冲区刷新的时机，这里是进程结束后，进行了强制刷新，将3个a字符输出到终端上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababab</span><br></pre></td></tr></table></figure>
<hr>
<p><code>strace</code>命令能够显示所有由用户空间程序发出的系统调用。</p>
<p>以上面第一个程序为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace ./ab</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202160702527.png" alt="image-20221202160702527"></p>
<blockquote>
<p>BUFSIZE对IO效率的影响</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203120510389.png" alt="image-20221203120510389"></p>
<p>图中用户CPU时间是程序在用户态下的执行时间；系统CPU时间是程序在内核态下的执行时间；时钟时间是两个时间的总和；</p>
<p>BUFSIZE受栈大小的影响；此测试所用的文件系统是Linux ext4文件系统，其磁盘块长度为<code>4096</code>字节。这也证明了图中系统 CPU 时间的几个最小值差不多出现在BUFFSIZE 为4096 及以后的位置，继续增加缓冲区长度对此时间几乎没有影响。</p>
<h3 id="3-6-C程序的内存空间布局"><a href="#3-6-C程序的内存空间布局" class="headerlink" title="3.6 C程序的内存空间布局"></a>3.6 C程序的内存空间布局</h3><blockquote>
<p>补充：内存地址和内存空间</p>
</blockquote>
<p>内存地址是一个编号，通常由16进制表示，它代表一个内存空间。在计算机中存储器的容量是以字节为基本单位的，也就是说<strong>一个内存地址代表一个字节（8bit）的存储空间</strong>，即<strong>按字节寻址</strong>。</p>
<p>假设一个int类型的变量x占用4个字节，则会占用4个连续的内存空间，x的内存地址则为第一个内存空间的地址。</p>
<p>对于32位操作系统，内存地址长度为32位，则可以表示2的32次方个内存空间（可寻址空间），即4GB；</p>
<p>计算：<code>2^32 * 1B = 2^32B = 2^22 KB = 2^12 MB = 2^2 GB = 4GB</code></p>
<p>对于64位操作系统，内存地址长度为64位，则可以表示2的64次方个内存空间（<code>16777216TB</code>）；但实际上，主板和CPU的限制导致一般的电脑所支持的内存最大只有16GB而已。</p>
<hr>
<p>C程序（例如<code>a.out</code>）运行时会被加载入内存中，而这个内存一般分为五个分区：栈区、堆区、数据区、常量区、代码区。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212432432.png" alt="image-20221202212432432"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202214105130.png" alt="image-20221202214105130"></p>
<h4 id="3-6-1-动态区"><a href="#3-6-1-动态区" class="headerlink" title="3.6.1 动态区"></a>3.6.1 动态区</h4><p>动态区的内容会根据执行情况而动态变化。</p>
<h5 id="①-栈区"><a href="#①-栈区" class="headerlink" title="① 栈区"></a>① 栈区</h5><p>栈（stack）是用户存放程序临时创建的<strong>局部变量</strong>，在函数被调用时，其<strong>参数</strong>也会被压入发起调用的进程栈中，并且等调用结束后，<strong>函数的返回值</strong>也会被存放在回栈中。</p>
<ul>
<li><strong>栈的大小</strong>：最大大小由编译时确定，不会太大。</li>
<li><strong>释放和分配</strong>：由编译器自动分配释放，由操作系统自动管理，无须手动管理。</li>
<li><strong>栈区地址</strong>：由高地址向低地址生长。</li>
<li>若越界访问则会出现<strong>段错误</strong>（Segmentation Fault）</li>
<li>若多次递归调用增加栈帧导致越界则会出现<strong>栈溢出</strong>（Stack Overflow）</li>
</ul>
<p>栈的大小可以通过<code>ulimit</code>命令查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s <span class="comment"># 只查看stack的大小</span></span><br><span class="line"><span class="built_in">ulimit</span> -a <span class="comment"># 查看当前所有的资源限制，stack 字段，单位Kbytes</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221202212135917.png" alt="image-20221202212135917"></p>
<p>可以看到栈的大小默认为8192KB，即8M；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x =<span class="number">10</span>;  <span class="comment">// 栈存储</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>; <span class="comment">// 栈存储</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-堆区"><a href="#②-堆区" class="headerlink" title="② 堆区"></a>② 堆区</h5><ul>
<li><strong>堆区存放</strong>：程序运行中<strong>动态存储分配</strong>的空间</li>
<li><strong>堆区大小</strong>：视内存大小而定，由程序员进行分配。</li>
<li><strong>堆区地址</strong>：由低地址向高地址生长</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x =<span class="number">10</span>;  <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">20</span>; <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">256</span>); <span class="comment">//堆分配</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-2-静态区"><a href="#3-6-2-静态区" class="headerlink" title="3.6.2 静态区"></a>3.6.2 静态区</h4><p>静态区的内容在整个程序的生命周期内都存在，由编译器在编译的时候分配。</p>
<h5 id="①-数据区"><a href="#①-数据区" class="headerlink" title="① 数据区"></a>① 数据区</h5><p>根据数据是否被初始化又分为：<code>bss</code>段与<code>data</code>段。</p>
<ul>
<li>未初始化数据段（<code>bss</code>）</li>
</ul>
<p>通常将此段称为<code>bss</code>段，这一名称来源于早期汇编程序的一个操作符，意思是<code>block started by symbol（由符号开始的块）</code>。</p>
<p><strong>存放未初始化的全局变量</strong>，属于静态内存分配。在程序开始执行之前，<strong>内核</strong>将此段初始化为0。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> sum[<span class="number">1000</span>]; <span class="comment">// 此变量存放在非初始化数据段中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>已初始化数据段（<code>data</code>）</li>
</ul>
<p><strong>存放已初始化的全局变量和静态变量</strong>，属于静态内存分配，其内容由<strong>程序</strong>初始化。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> PI= <span class="number">3.14f</span>; <span class="comment">// 此变量以初值存放在初始化数据段中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-常量区"><a href="#②-常量区" class="headerlink" title="② 常量区"></a>② 常量区</h5><p>常量区存放字符串常量、const修饰的全局变量。程序运行期间，常量区的内容不可以被修改。</p>
<h5 id="③-代码区"><a href="#③-代码区" class="headerlink" title="③ 代码区"></a>③ 代码区</h5><p>代码区（<code>text</code>），又叫：正文段、代码段。</p>
<p>通常是用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读，某些架构也允许代码段为可写，即允许修改程序。</p>
<h4 id="3-6-3-栈的地址测试"><a href="#3-6-3-栈的地址测试" class="headerlink" title="3.6.3 栈的地址测试"></a>3.6.3 栈的地址测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>; <span class="comment">// 栈分配</span></span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>; <span class="comment">// 栈分配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x; <span class="comment">// 栈分配</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;y = %p\n&quot;</span>, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;x = 0x7ffd1ce3e33c</span><br><span class="line">&amp;y = 0x7ffd1ce3e338</span><br><span class="line">&amp;p = 0x7ffd1ce3e330</span><br></pre></td></tr></table></figure>
<p>可以看到x，y，p的地址从高向低依次排列。</p>
<h4 id="3-6-4-堆的地址测试"><a href="#3-6-4-堆的地址测试" class="headerlink" title="3.6.4 堆的地址测试"></a>3.6.4 堆的地址测试</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *p = &amp;x;</span><br><span class="line">    <span class="keyword">char</span> *q = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">256</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>)); <span class="comment">// 堆上分配</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;x = %p\n&quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;y = %p\n&quot;</span>, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;p = %p\n&quot;</span>, &amp;p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;q = %p\n&quot;</span>, &amp;q);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;x = 0x7ffd4ab330fc</span><br><span class="line">&amp;y = 0x7ffd4ab330f8</span><br><span class="line">&amp;p = 0x7ffd4ab330f0</span><br><span class="line">&amp;q = 0x7ffd4ab330e8</span><br></pre></td></tr></table></figure>
<p>可以看到分配在堆区的q的地址在其他三个的低处，且距离较远。</p>
<h4 id="3-6-5-静态区演示"><a href="#3-6-5-静态区演示" class="headerlink" title="3.6.5 静态区演示"></a>3.6.5 静态区演示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 数据区：data段</span></span><br><span class="line"><span class="keyword">char</span> m = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> n = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据区：bss段</span></span><br><span class="line"><span class="keyword">char</span> arr1[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据区：data段</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">static</span> MAX = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">// 数据区：bss段</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">static</span> MIN;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈区</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 常量区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> z = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数据区：data段</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="comment">// 数据区：bss段</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;Hello World&quot;在常量区</span></span><br><span class="line">    <span class="comment">// p在栈区</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &quot;123456&quot;和arr均在栈区，且地址相同</span></span><br><span class="line">    <span class="keyword">char</span> arr2[] = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-文件共享"><a href="#3-7-文件共享" class="headerlink" title="3.7 文件共享"></a>3.7 文件共享</h3><p>如果两个独立进程各自打开了同一文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203121019961.png" alt="image-20221203121019961"></p>
<ul>
<li>在完成每个write后，在<strong>文件表项（即类似于FILE的结构体）</strong>中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量（也就是该文件加长了）。</li>
<li>如果用<code>O_APPEND</code>标志打开一个文件，则相应标志也被设置到文件表项的<strong>文件状态标志</strong>中。每次对这种具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。</li>
<li>若一个文件用<code>lseek</code>定位到文件当前的尾端，则文件表项中的当前文件偏移量被设置为i节点表项中的当前文件长度。<code>lseek</code>函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
</ul>
<p>可能有多个文件描述符指向同一个文件表项（例如使用dup），对于多个进程读取同一文件都能正确工作。每个进程都有它自己的文件表项，其中也有它自己的当前文件偏移量。但是，当多个进程<strong>写同一文件</strong>时，则可能产生预想不到的结果。为了说明如何避免这种情况，需要理解<strong>原子操作</strong>的概念。</p>
<p>原子操作：不可分割的操作；</p>
<p>原子操作的作用：解决竞争和冲突；</p>
<h3 id="3-8-dup和dup2"><a href="#3-8-dup和dup2" class="headerlink" title="3.8 dup和dup2"></a>3.8 dup和dup2</h3><p><code>dup</code>函数用于复制文件描述符，重定向输入输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>成功：<ul>
<li>dup函数返回当前系统可用的<strong>最小整数值</strong>，并且该描述符对应的文件与参数描述符<code>oldfd</code>所对应的文件一致，即指向同一个结构体；</li>
<li>dup2函数返回第一个<code>不小于newfd</code>的整数值，分两种情况：<ul>
<li>如果newfd已经打开，则先将其关闭，再指向文件描述符oldfd的结构体；</li>
<li>如果newfd等于oldfd，则什么也不做；</li>
</ul>
</li>
</ul>
</li>
<li>失败：dup和dup2函数均返回<code>-1</code>，并设置errno。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：将<code>puts</code>重定向到一个文件中</p>
<ul>
<li>方法1：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    close(<span class="number">1</span>); <span class="comment">// 关闭stdout，使描述符1空闲</span></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ./dup</span></span><br><span class="line">[root@HongyiZeng sysio]<span class="comment"># cat /tmp/out</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2：使用<code>dup</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭stdout</span></span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 复制fd，让其占据1的描述符</span></span><br><span class="line">    dup(fd);</span><br><span class="line">    <span class="comment">// 关闭fd</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203125442239.png" alt="image-20221203125442239"></p>
<p>注意结构体中有引用计数，当<code>fd=3</code>被关闭时，还有<code>fd=1</code>指向这个结构体，因此结构体不会被销毁掉。存在并发问题。</p>
<ul>
<li>方法3：使用<code>dup2</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(FNAME, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果fd = 1，则什么也不做，返回fd</span></span><br><span class="line">    <span class="comment">// 如果fd != 1，则关闭1指向的结构体，再打开1，指向fd的结构体，返回1</span></span><br><span class="line">    dup2(fd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd != <span class="number">1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dup2</code>是一个原子操作，相当于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 相当于:</span></span><br><span class="line">close(<span class="number">1</span>);</span><br><span class="line">dup(fd);</span><br></pre></td></tr></table></figure>
<h3 id="3-9-fcntl和ioctl"><a href="#3-9-fcntl和ioctl" class="headerlink" title="3.9 fcntl和ioctl"></a>3.9 fcntl和ioctl</h3><p><code>fcntl</code>针对文件描述符提供控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值：若成功，则依赖于<code>cmd</code>，若失败，则返回<code>-1</code></p>
<p>函数功能：</p>
<ul>
<li>复制一个已有的描述符（<code>cmd=F_DUPFD或F_DUPFD_CLOEXEC</code>）</li>
<li>获取/设置文件描述符标志（<code>cmd=F_GETFD或F_SETFD</code>）</li>
<li>获取/设置文件状态标志（<code>cmd=F_GETFL或F_SETFL</code>）</li>
<li>获取/设置异步I/O所有权（<code>cmd=F_GETOWN或F_SETOWN</code>）</li>
<li>获取/设置记录锁（<code>cmd=F_GETLK、F_SETLK或F_SETLKW</code>）</li>
</ul>
<hr>
<p><code>ioctl</code>：用于控制设备</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>ioctl</code>函数一直是IO操作的杂物箱。不能用本章中其他函数表示的I/O操作通常都能用ioctl表示。<strong>终端I/O是使用ioctl最多的地方</strong>。</p>
<h3 id="3-10-dev-fd目录"><a href="#3-10-dev-fd目录" class="headerlink" title="3.10 /dev/fd目录"></a>3.10 /dev/fd目录</h3><p><strong>对于每个进程</strong>，内核都提供有一个<strong>特殊的虚拟目录</strong><code>/dev/fd</code>。</p>
<p>该目录中包含<code>/dev/fd/n</code>形式的文件名，其中n是与进程中打开文件描述符相对应的编号。也就是说，<code>/dev/fd/0</code>就对应于进程的标志输入。</p>
<p>打开/dev/fd目录中的一个文件等同于复制对应的文件描述符，所以下面两行代码是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dev/fd/1&quot;</span>, O_WRONLY);</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">fd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-11-补充：几个文件的区别"><a href="#3-11-补充：几个文件的区别" class="headerlink" title="3.11 补充：几个文件的区别"></a>3.11 补充：几个文件的区别</h3><h4 id="3-11-1-用户变量"><a href="#3-11-1-用户变量" class="headerlink" title="3.11.1 用户变量"></a>3.11.1 用户变量</h4><p> <code>~/.bashrc</code>和<code>~/.bash_file</code>这两个看到<code>~</code>，应该明白，这是用户目录下的，即里面的环境变量也叫shell变量，是局部的，只对特定的shell有效，用vim在用户目录下的<code>.bash_profile</code>文件中增加变量，<strong>变量仅会对当前用户有效</strong>，并且是“永久的”。</p>
<p>要让刚才的修改马上生效，需要执行以下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure>
<p>两个的区别：<code>.bash_profile</code>只在会话开始时被读取一次，而<code>.bashrc</code>则每次打开新的终端时，都会被读取。</p>
<ul>
<li>当shell是交互式登录shell时，读取<code>.bash_profile</code>文件，如在系统启动、远程登录或使用su -切换用户时；</li>
<li>当shell是交互式登录和非登录shell时都会读取<code>.bashrc</code>文件，如：在图形界面中打开新终端或使用su切换用户时，均属于非登录shell的情况。</li>
</ul>
<h4 id="3-11-2-全局变量"><a href="#3-11-2-全局变量" class="headerlink" title="3.11.2 全局变量"></a>3.11.2 全局变量</h4><p><code>/etc/profile</code> 和<code>/etc/profile.d</code>，前面的是文件，后面一看也就明白<code>.d</code>表示目录， <code>/etc/profile</code>里面的变量是全局的，对所有用户的shell有效。</p>
<p> 用vim在文件<code>/etc/profile</code>文件中增加变量，该变量将会对Linux下<strong>所有用户有效</strong>，并且是“永久的”。</p>
<p>要让刚才的修改马上生效，需要执行以下代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<h2 id="4-文件系统"><a href="#4-文件系统" class="headerlink" title="4 文件系统"></a>4 文件系统</h2><p>该节对应<code>APUE</code>的第四章——文件和目录，第六章——系统数据文件和信息</p>
<h3 id="4-1-Linux文件目录构成"><a href="#4-1-Linux文件目录构成" class="headerlink" title="4.1 Linux文件目录构成"></a>4.1 Linux文件目录构成</h3><h4 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172157027.png" alt="image-20221203172157027"></p>
<p>树状目录结构：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203172208754.png" alt="image-20221203172208754"></p>
<p>目录解释：</p>
<ul>
<li><strong>/bin</strong>：bin 是 Binaries (二进制文件) 的缩写，这个目录存放着最经常使用的命令。</li>
<li><strong>/boot：</strong>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</li>
<li><strong>/dev ：</strong>dev 是 Device(设备) 的缩写，该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的（一切皆文件）。</li>
<li><strong>/etc：</strong>etc 是 Etcetera(等等) 的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li>
<li><strong>/home</strong>：用户的主目录（家目录），在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</li>
<li><strong>/lib</strong>：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li>
<li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li>
<li><strong>/media</strong>：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</li>
<li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</li>
<li><strong>/opt</strong>：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li>
<li><strong>/proc</strong>：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li>
<li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li>
<li><strong>/sbin</strong>：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</li>
<li><strong>/tmp</strong>：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</li>
<li><strong>/usr</strong>：usr 是 <code>unix shared resources</code>(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 <code>C:/Windows/</code> 目录。<ul>
<li><code>/usr/lib</code>理解为<code>C:/Windows/System32</code></li>
<li><code>/usr/local</code>：用户级的程序目录，可以理解为<code>C:/Progrem Files/</code>。用户自己编译的软件默认会安装到这个目录下。</li>
<li><code>/opt</code>：用户级的程序目录，可以理解为<code>D:/Software</code>，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接<code>rm -rf</code>掉即可。</li>
</ul>
</li>
<li><strong>/var</strong>：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li>
<li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li>
</ul>
<blockquote>
<p>切换用户</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su 用户名</span><br></pre></td></tr></table></figure>
<hr>
<p><code>~</code>代表当前登录用户的用户目录（家目录）。</p>
<p>如果当前的用户是root，则<code>~</code>代表<code>/root</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng ~]$ su root</span><br><span class="line">Password: </span><br><span class="line">[root@HongyiZeng lighthouse]<span class="comment"># cd ~</span></span><br><span class="line">[root@HongyiZeng ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>如果当前的用户是其他用户，则<code>~</code>代表<code>/home/用户名</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng ~]$ <span class="built_in">pwd</span></span><br><span class="line">/home/lighthouse</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="4-1-2-etc-passwd"><a href="#4-1-2-etc-passwd" class="headerlink" title="4.1.2 /etc/passwd"></a>4.1.2 /etc/passwd</h4><p><code>/etc/passwd</code>为用户信息文件存放路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root:x:<span class="number">0</span>:<span class="number">0</span>:root:/root:/bin/bash</span><br><span class="line">bin:x:<span class="number">1</span>:<span class="number">1</span>:bin:/bin:/sbin/nologin</span><br><span class="line">daemon:x:<span class="number">2</span>:<span class="number">2</span>:daemon:/sbin:/sbin/nologin</span><br><span class="line">adm:x:<span class="number">3</span>:<span class="number">4</span>:adm:/var/adm:/sbin/nologin</span><br><span class="line">lp:x:<span class="number">4</span>:<span class="number">7</span>:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">sync:x:<span class="number">5</span>:<span class="number">0</span>:sync:/sbin:/bin/sync</span><br><span class="line">shutdown:x:<span class="number">6</span>:<span class="number">0</span>:shutdown:/sbin:/sbin/shutdown</span><br><span class="line">halt:x:<span class="number">7</span>:<span class="number">0</span>:halt:/sbin:/sbin/halt</span><br><span class="line">mail:x:<span class="number">8</span>:<span class="number">12</span>:mail:/var/spool/mail:/sbin/nologin</span><br><span class="line"><span class="keyword">operator</span>:x:<span class="number">11</span>:<span class="number">0</span>:<span class="keyword">operator</span>:/root:/sbin/nologin</span><br><span class="line">games:x:<span class="number">12</span>:<span class="number">100</span>:games:/usr/games:/sbin/nologin</span><br><span class="line">ftp:x:<span class="number">14</span>:<span class="number">50</span>:FTP User:/var/ftp:/sbin/nologin</span><br><span class="line">nobody:x:<span class="number">99</span>:<span class="number">99</span>:Nobody:/:/sbin/nologin</span><br><span class="line">systemd-network:x:<span class="number">192</span>:<span class="number">192</span>:systemd Network Management:/:/sbin/nologin</span><br><span class="line">dbus:x:<span class="number">81</span>:<span class="number">81</span>:System message bus:/:/sbin/nologin</span><br><span class="line">polkitd:x:<span class="number">999</span>:<span class="number">998</span>:User <span class="keyword">for</span> polkitd:/:/sbin/nologin</span><br><span class="line">libstoragemgmt:x:<span class="number">998</span>:<span class="number">997</span>:daemon account <span class="keyword">for</span> libstoragemgmt:/var/run/lsm:/sbin/nologin</span><br><span class="line">rpc:x:<span class="number">32</span>:<span class="number">32</span>:Rpcbind Daemon:/var/lib/rpcbind:/sbin/nologin</span><br><span class="line">ntp:x:<span class="number">38</span>:<span class="number">38</span>::/etc/ntp:/sbin/nologin</span><br><span class="line">abrt:x:<span class="number">173</span>:<span class="number">173</span>::/etc/abrt:/sbin/nologin</span><br><span class="line">sshd:x:<span class="number">74</span>:<span class="number">74</span>:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin</span><br><span class="line">postfix:x:<span class="number">89</span>:<span class="number">89</span>::/var/spool/postfix:/sbin/nologin</span><br><span class="line">chrony:x:<span class="number">997</span>:<span class="number">995</span>::/var/lib/chrony:/sbin/nologin</span><br><span class="line">tcpdump:x:<span class="number">72</span>:<span class="number">72</span>::/:/sbin/nologin</span><br><span class="line">syslog:x:<span class="number">996</span>:<span class="number">994</span>::/home/syslog:/bin/<span class="literal">false</span></span><br><span class="line">lighthouse:x:<span class="number">1000</span>:<span class="number">1000</span>::/home/lighthouse:/bin/bash</span><br></pre></td></tr></table></figure>
<p>每一行分为7个字段，以冒号<code>:</code>进行分割，含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户名</td>
<td>用户登录系统时使用的用户名</td>
</tr>
<tr>
<td>密码</td>
<td>密码位，通常将<code>passwd</code>文件中的口令字段使用一个<code>x</code>来代替，将<code>/etc /shadow</code>作为真正的口令文件</td>
</tr>
<tr>
<td>UID</td>
<td>用户标识号</td>
</tr>
<tr>
<td>GID</td>
<td>缺省组标识号</td>
</tr>
<tr>
<td>注释性描述</td>
<td>例如存放用户全名等信息</td>
</tr>
<tr>
<td>宿主目录</td>
<td>用户登录系统后的缺省目录</td>
</tr>
<tr>
<td>命令解释器</td>
<td>用户使用的shell，默认为bash</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-3-etc-group"><a href="#4-1-3-etc-group" class="headerlink" title="4.1.3 /etc/group"></a>4.1.3 /etc/group</h4><p><code>/ect/group</code> 文件是用户组配置文件，即用户组的所有信息都存放在此文件中。只列出部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:<span class="number">0</span>:</span><br><span class="line">lighthouse:x:<span class="number">1000</span>:lighthouse</span><br></pre></td></tr></table></figure>
<p>每一行分为4个字段，以冒号<code>:</code>进行分割，含义如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>组名</td>
<td>用户组名称</td>
</tr>
<tr>
<td>组密码</td>
<td>和 /etc/passwd 文件一样，这里的 “x” 仅仅是密码标识</td>
</tr>
<tr>
<td>GID</td>
<td>组标识号</td>
</tr>
<tr>
<td>组中的用户</td>
<td>此字段列出每个群组包含的所有用户</td>
</tr>
</tbody>
</table>
</div>
<h4 id="4-1-4-usr-include"><a href="#4-1-4-usr-include" class="headerlink" title="4.1.4 /usr/include"></a>4.1.4 /usr/include</h4><p>linux系统编程往往需要引用c头文件，linux下，头文件一般存储到<code>/usr/include</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221203190639497.png" alt="image-20221203190639497"></p>
<h4 id="补充-inode"><a href="#补充-inode" class="headerlink" title="补充 inode"></a>补充 inode</h4><h5 id="①-简介"><a href="#①-简介" class="headerlink" title="① 简介"></a>① 简介</h5><p>文件数据是储存在硬盘上的，硬盘的最小存储单位叫做<strong>扇区</strong>。每个扇区存储512字节，而连续的8个扇区组成了一个<strong>块</strong>（block），大小为<code>4kB</code>。<strong>文件数据都存储在块中</strong>，为了能够方便找到存储数据的位置我们还必须找到一个地方存储文件的属性，这种存储文具属性信息的区域叫做<code>inode</code>（索引节点）。</p>
<h5 id="②-inode的信息"><a href="#②-inode的信息" class="headerlink" title="② inode的信息"></a>② inode的信息</h5><p>inode（<strong>本质上是一个结构体</strong>）包含文件的属性信息有以下内容：<strong>注意，没有文件名和inode编号</strong></p>
<ul>
<li>文件的字节数</li>
<li>文件拥有者的id</li>
<li>文件所属组id</li>
<li>文件的读写执行权限</li>
<li>文件的时间戳，共有三个：<ul>
<li>ctime指inode上一次变动的时间</li>
<li>mtime指文件内容上一次变动时间</li>
<li>atime指文件上一次打开时间。</li>
</ul>
</li>
<li>硬链接数，即有多少个文件指向这个inode</li>
<li><p>文件数据块（block）的位置，即指向数据块的<strong>指针</strong>，包括一级指针，二级指针和三级指针，一般为15个指针</p>
<p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘划分为两个区域。一个是<strong>数据区</strong>，存放文件数据，另一个是<strong>inode区（inode table）</strong>，存放inode所包含的信息，inode区本质上是一个<strong>结构体数组</strong>，数组下标就是inode编号<code>inode_num</code>。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205182107212.png" alt="image-20221205182107212"></p>
<p> 每个inode节点（结构体）的大小，一般是128字节或者256字节。inode节点的总数。在格式化时就给定，一般是每1kb或者每2kb就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小就会达到128MB。</p>
<p>inode编号是很重要的，当系统在找一个文件时，步骤如下：</p>
<ol>
<li>通过文件名先找到文件的inode编号（数组下标）</li>
<li>通过inode编号找到文件inode信息（结构体）</li>
<li>通过inode信息中的block<strong>指针</strong>找到文件内容。</li>
</ol>
<h5 id="③-相关命令"><a href="#③-相关命令" class="headerlink" title="③ 相关命令"></a>③ 相关命令</h5><p><code>stat</code>显示文件的状态信息。stat命令的输出信息比ls命令的输出信息要更详细。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ls</span></span><br><span class="line">ab  ab.c  dup  dup.c  mycpy  mycpy.c  <span class="built_in">test</span></span><br><span class="line">[root@HongyiZeng sysio]<span class="comment"># stat ab.c</span></span><br><span class="line">  文件: ‘ab.c’</span><br><span class="line">  大小: 193             块: 8          IO 块: 4096   普通文件</span><br><span class="line">设备: fd01h/64769d    Inode: 797269      硬链接: 1</span><br><span class="line">权限: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">最近访问: 2022-12-02 16:05:47.044135336 +0800</span><br><span class="line">最近修改: 2022-12-02 16:05:45.239158807 +0800</span><br><span class="line">最近改动: 2022-12-02 16:05:45.245158729 +0800</span><br><span class="line"> 创建时间: -</span><br></pre></td></tr></table></figure>
<p><code>ls -i</code>用于查看某个文件的inode编号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng sysio]<span class="comment"># ls -i ab.c</span></span><br><span class="line">797269 ab.c</span><br></pre></td></tr></table></figure>
<h5 id="④-硬链接"><a href="#④-硬链接" class="headerlink" title="④ 硬链接"></a>④ 硬链接</h5><p> 一般情况下，文件名和inode号码是一一对应关系，每个inode号码对应一个文件名，但是Linux系统<strong>允许多个文件名指向同一个inode号码</strong>，这就意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是删除一个文件名，不影响另一个文件名访问，相当于源文件的副本，这种情况叫做硬链接。</p>
<p>inode信息中有一项叫做链接数，记录指向该inode的文件总数，这时会加1，反过来，删除一个文件名，会减一，当链接数变为0时，表明没有文件指向这个inode号码，系统就会回收这个inode号码与文件数据块区。</p>
<h5 id="⑤-符号链接"><a href="#⑤-符号链接" class="headerlink" title="⑤ 符号链接"></a>⑤ 符号链接</h5><p>文件A与文件B的号码虽然不一样，但是文件A的内容是文件B的路径，A就是B的软链接文件。读取文件A时，系统会自动访问导向文件B的文件名，然后再根据B的inode去访问存储在块中的数据。</p>
<p>而这意味着，文件A依赖于文件B而存在，若删除了文件B，打开文件A就会报错。这就是软连接与硬链接最大的不同：<strong>文件A指向文件B的文件名，而不是inode号码，文件B的inode链接数不会发生变化</strong>。</p>
<h3 id="4-2-文件和目录"><a href="#4-2-文件和目录" class="headerlink" title="4.2 文件和目录"></a>4.2 文件和目录</h3><h4 id="4-2-1-stat"><a href="#4-2-1-stat" class="headerlink" title="4.2.1 stat"></a>4.2.1 stat</h4><p>系统调用<code>stat</code>用于获取文件的属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>stat</code>：第一个形参：文件路径； 第二个形参：一个指向结构体<code>stat</code>的指针，因此需要传入结构体的地址；</li>
<li><code>fstat</code>：第一个形参是文件描述符；</li>
<li><code>lstat</code>：lstat函数的形参跟stat函数的形参一样。其功能也跟stat函数功能一样，仅有一点不同：stat函数是穿透（追踪）函数，即对软链接文件进行操作时，操作的是链接到的那一个文件，不是软链接文件本身；而lstat函数是不穿透（不追踪）函数，对软链接文件进行操作时，操作的是<strong>软链接文件本身</strong>。注：软链接严格来说应该叫<strong>符号链接</strong>。</li>
<li>返回值：成功返回0，失败返回-1，并且将详细错误信息赋值给errno全局变量。</li>
</ul>
<p><code>struct stat</code>类型的说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_dev;     <span class="comment">/* 文件的设备编号 */</span></span><br><span class="line">    <span class="keyword">ino_t</span> st_ino;     <span class="comment">/* 索引结点编号 */</span></span><br><span class="line">    <span class="keyword">mode_t</span> st_mode;    <span class="comment">/* 文件类型和权限*/</span></span><br><span class="line">    <span class="keyword">nlink_t</span> st_nlink;   <span class="comment">/*硬链接数 */</span></span><br><span class="line">    <span class="keyword">uid_t</span> st_uid;     <span class="comment">/*用户ID*/</span></span><br><span class="line">    <span class="keyword">gid_t</span> st_gid;     <span class="comment">/* 组ID*/</span></span><br><span class="line">    <span class="keyword">dev_t</span> st_rdev;    <span class="comment">/* 设备类型（若此文件为设备文件，则为设备编号*/</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;    <span class="comment">/* 文件大小，以字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/*文件系统的I/O块大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks;  <span class="comment">/* 块数 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_atime;   <span class="comment">/* 访问时间 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_mtime;   <span class="comment">/* 修改时间 */</span></span><br><span class="line">    <span class="keyword">time_t</span> st_ctime;   <span class="comment">/* 更改时间 */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>打印出文件的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意返回值是off_t类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">off_t</span> <span class="title">flen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span> <span class="comment">// 声明一个stat类型的结构体statres</span></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 返回st_size成员</span></span><br><span class="line">    <span class="keyword">return</span> statres.st_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total size: %lld\n&quot;</span>, flen(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>off_t</code>类型用于指示文件的偏移量，通常就是<code>long</code>类型，其默认为一个32位的整数，在gcc编译中会被编译为<code>long int</code>类型，在64位的Linux系统中则会被编译为<code>long long int</code>，这是一个64位的整数，其定义在<code>unistd.h</code>头文件中可以查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> __off_t_defined</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">ifndef</span> __USE_FILE_OFFSET64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off_t</span> <span class="keyword">off_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off64_t</span> <span class="keyword">off_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __off_t_defined</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined __USE_LARGEFILE64 &amp;&amp; !defined __off64_t_defined</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__off64_t</span> <span class="keyword">off64_t</span>;</span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __off64_t_defined</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-空洞文件"><a href="#4-2-2-空洞文件" class="headerlink" title="4.2.2 空洞文件"></a>4.2.2 空洞文件</h4><p>在描述文件属性的结构体<code>stat</code>中，有以下三个描述文件大小的成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">off_t</span> st_size;    <span class="comment">/* 文件大小，以字节为单位*/</span></span><br><span class="line">    <span class="keyword">blksize_t</span> st_blksize; <span class="comment">/*文件系统的I/O块大小*/</span></span><br><span class="line">    <span class="keyword">blkcnt_t</span> st_blocks;  <span class="comment">/* 块数 */</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p>其中，块大小一般为4096字节，即<code>4KB</code>（一个块为连续8个扇区，每个扇区为512B）；块数为该文件的占用的块数；</p>
<p>注意：<code>st_size ≠ st_blksize * st_blocks</code>；或者说，<code>st_size</code>是文件的<strong>逻辑大小</strong>，而<code>st_blksize * st_blocks</code>是文件的<strong>物理大小</strong>；</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>创建一个<code>5GB</code>大小的文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(argv[<span class="number">1</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 先让指针从文件开头向后移动5G个字节</span></span><br><span class="line">    lseek(fd, <span class="number">5LL</span> * <span class="number">1024LL</span> * <span class="number">1024LL</span> * <span class="number">1024LL</span> - <span class="number">1LL</span>, SEEK_SET);</span><br><span class="line">	<span class="comment">// 在最后写入一个空字符</span></span><br><span class="line">    write(fd, <span class="string">&quot;&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># make big</span></span><br><span class="line">cc     big.c   -o big</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ./big /tmp/bigfile</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># stat /tmp/bigfile </span></span><br><span class="line">  File: ‘/tmp/bigfile’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<p>可以看出，大小为5368709120B，但是占用的块数却为8，即实际占用的物理大小为<code>4KB * 8 = 32KB</code>。</p>
<p>如果将该文件进行拷贝，再查看拷贝文件的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]# cp /tmp/bigfile /tmp/bigfile.bak</span><br><span class="line">[root@HongyiZeng fs]# stat /tmp/bigfile.bak </span><br><span class="line">  File: ‘/tmp/bigfile.bak’</span><br><span class="line">  Size: 5368709120      Blocks: 0           IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26200       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Change: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<hr>
<p>使用 lseek 可以修改文件的当前读写位置偏移量，此函数不但可以改变位置偏移量，并且还允许文件偏移量超出文件长度，譬如有一个 <code>test_file</code>，该文件的大小是 4K（也就是 4096 个字节），通过 lseek 系统调用可以将该文件的读写偏移量移动到偏移文件头部 6000 个字节处。</p>
<p>接下来使用 write 函数对文件进行写入操作，也就是说此时将是从偏移文件头部 6000 个字节处开始写入数据，也就意味着 4096~6000 字节之间出现了一个<strong>空洞</strong>，因为这部分空间并没有写入任何数据，所以形成了空洞，这部分区域就被称为文件空洞，那么相应的该文件也被称为<strong>空洞文件</strong>。文件空洞部分实际上并不会占用任何物理空间，直到在某个时刻对空洞部分进行写入数据时才会为它分配对应的空间，但是空洞文件形成时，逻辑上该文件的大小是包含了空洞部分的大小的，这点需要注意。</p>
<blockquote>
<p>空洞文件的作用</p>
</blockquote>
<p>空洞文件的好处是：空洞文件对多线程共同操作文件是很有用的。</p>
<p>因为我们在创建一个很大文件的时候，我们就把一个文件分成很多的段，然后采用多线程的方式，让每个线程负责写入其中的某一段的数据。这样的话比我们用单个线程写入是快很多的。</p>
<p>例如：</p>
<ul>
<li>在使用迅雷下载文件时，还未下载完成，就发现该文件已经占据了全部文件大小的空间，这也是空洞文件；下载时如果没有空洞文件，多线程下载时文件就只能从一个地方写入，这就不能发挥多线程的作用了；如果有了空洞文件，可以从不同的地址同时写入，就达到了多线程的优势；</li>
<li>在创建虚拟机时，你给虚拟机分配了 100G 的磁盘空间，但其实系统安装完成之后，开始也不过只用了 3、4G 的磁盘空间，如果一开始就把 100G 分配出去，资源是很大的浪费。</li>
</ul>
<h4 id="4-2-3-st-mode"><a href="#4-2-3-st-mode" class="headerlink" title="4.2.3 st_mode"></a>4.2.3 st_mode</h4><h5 id="①-简介-1"><a href="#①-简介-1" class="headerlink" title="① 简介"></a>① 简介</h5><p><code>st_mode</code>是一个16位的位图，用于表示文件类型，文件访问权限以及特殊权限位。</p>
<p>它的类型为<code>mode_t</code>，其实就是普通的<code>unsigned int</code>，但是只是用了低16位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165451681.png" alt="image-20221205165451681"></p>
<h5 id="②-实例分析"><a href="#②-实例分析" class="headerlink" title="② 实例分析"></a>② 实例分析</h5><p>假设<code>st_mode</code>表示为八进制的<code>100664</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205165902073.png" alt="image-20221205165902073"></p>
<p>则有：</p>
<ul>
<li>1000: 这是一个常规文件</li>
<li>000: 执行时设置信息为空，黏着位为 0</li>
<li>110-110-100: 用户权限为 <code>RW-</code>，组员权限为<code>RW-</code>，其他人权限为<code>R--</code></li>
</ul>
<h5 id="③-宏"><a href="#③-宏" class="headerlink" title="③ 宏"></a>③ 宏</h5><p>通过手工分析 st_mode 字段，实际上是很不方便的。实际写程序，可使用 <code>st_mode &amp; 掩码</code>来得到 st_mode 中特定的部分。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_mode &amp; 0170000 : 得到文件类型</span><br><span class="line">st_mode &amp; 0007000 : 得到执行文件时设置信息</span><br><span class="line">st_mode &amp; 0000777 : 得到权限位</span><br><span class="line">st_mode &amp; 00100: 判断所有者是否可执行</span><br><span class="line">(以上数字均为八进制)</span><br></pre></td></tr></table></figure>
<p>为了方便使用，用 linux 预定义的一些宏来代替这些生硬的数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bit15 ~ bit12 , 文件类型属性区域</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFMT      0170000     文件类型的位遮罩</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFSOCK    0140000     socket</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFLNK     0120000     符号链接(symbolic link)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFREG     0100000     一般文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFBLK     0060000     区块装置(block device)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFDIR     0040000     目录</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFCHR     0020000     字符装置(character device)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_IFIFO     0010000     先进先出(fifo)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISSOCK(m) (((m) &amp; S_IFMT) == S_IFSOCK)  <span class="comment">//提供了一些宏函数来帮助用户执行&amp;操作，是则返回1</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISLNK(m)  (((m) &amp; S_IFMT) == S_IFLNK)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISREG(m)  (((m) &amp; S_IFMT) == S_IFREG)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISBLK(m)  (((m) &amp; S_IFMT) == S_IFBLK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(m)  (((m) &amp; S_IFMT) == S_IFDIR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISCHR(m)  (((m) &amp; S_IFMT) == S_IFCHR)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISFIFO(m) (((m) &amp; S_IFMT) == S_IFIFO)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bit11 ~ bit9，权限的特殊属性区域</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISUID      0004000     文件的(set user-id on execution)位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISGID      0002000     文件的(set group-id on execution)位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  S_ISVTX      0001000     文件的sticky位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//bit8 ~ bit0，权限属性区域</span></span><br><span class="line"><span class="comment">//文件所有者（owner）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXU 00700	<span class="comment">/* mask for file owner permissions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRUSR 00400	<span class="comment">/* owner has read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWUSR 00200	<span class="comment">/* owner has write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXUSR 00100	<span class="comment">/* owner has execute permission */</span></span></span><br><span class="line"> <span class="comment">//组用户（group）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXG 00070	<span class="comment">/* mask for group permissions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRGRP 00040	<span class="comment">/* group has read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWGRP 00020	<span class="comment">/* group has write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXGRP 00010	<span class="comment">/* group has execute permission */</span></span></span><br><span class="line"> <span class="comment">//其他用户（other）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IRWXO 00007	<span class="comment">/* mask for permissions for others (not in group) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IROTH 00004	<span class="comment">/* others have read permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IWOTH 00002	<span class="comment">/* others have write permission */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_IXOTH 00001	<span class="comment">/* others have execute permission */</span></span></span><br></pre></td></tr></table></figure>
<h5 id="④-代码示例"><a href="#④-代码示例" class="headerlink" title="④ 代码示例"></a>④ 代码示例</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ftype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;stat()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(S_ISREG(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISDIR(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(S_ISSOCK(statres.st_mode))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fper</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fname)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statres</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stat(fname, &amp;statres)) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fper()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> statres.st_mode &amp; S_IRWXU;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File type: %c\n&quot;</span>, ftype(argv[<span class="number">1</span>]));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Permission of owner: %o\n&quot;</span>, fper(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./ftype ftype.c </span></span><br><span class="line">File <span class="built_in">type</span>: -</span><br><span class="line">Permission of owner: 600</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ./ftype ftype</span></span><br><span class="line">File <span class="built_in">type</span>: -</span><br><span class="line">Permission of owner: 700</span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-文件权限"><a href="#4-2-4-文件权限" class="headerlink" title="4.2.4 文件权限"></a>4.2.4 文件权限</h4><h5 id="①-umask"><a href="#①-umask" class="headerlink" title="① umask"></a>① umask</h5><p>umask函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umask</span><span class="params">(<span class="keyword">mode_t</span> mask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在进程创建一个新的文件或目录时，如调用open函数创建一个新文件，新文件的实际存取权限是mode与umask按照 <code>mode &amp; ~umask</code>运算以后的结果。umask函数用来修改进程的umask，作用是防止出现权限过松的文件。</p>
<h5 id="②-chmod"><a href="#②-chmod" class="headerlink" title="② chmod"></a>② chmod</h5><p>补充：chmod命令</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [对谁操作(ugoa)] [操作符 (+-=)] [赋予的权限(rwxs或数字)] 文件名1 文件名2...</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205171940635.png" alt="image-20221205171940635"></p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-r--r-- 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod 664 big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-rw-r-- 1 root root 420 Dec  5 16:19 big.c</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rw-rw-r-- 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod a+x big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rwxrwxr-x 1 root root 420 Dec  5 16:19 big.c</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># chmod o-x big.c</span></span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># ll big.c</span></span><br><span class="line">-rwxrwxr-- 1 root root 420 Dec  5 16:19 big.c</span><br></pre></td></tr></table></figure>
<hr>
<p>chmod函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>
<p>chmod是对指定的文件进行操作，而fchmod则是对已经打开的文件进行操作。所以它们的第一个参数不一样。</p>
<p>返回值：如果改变成功返回0，否则返回-1</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;a&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == fd)</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;open fail&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">// 将fd的权限更改为0777</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == fchmod(fd, <span class="number">0777</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fchmod fail&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> 	</span><br><span class="line">    <span class="comment">// 将b文件的权限更改为0777</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == chmod(<span class="string">&quot;b&quot;</span>, <span class="number">0777</span>))</span><br><span class="line">    &#123;</span><br><span class="line">       perror(<span class="string">&quot;fchmod fail&quot;</span>);</span><br><span class="line">       <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-粘住位"><a href="#③-粘住位" class="headerlink" title="③ 粘住位"></a>③ 粘住位</h5><p>在UNIX尚未使用分页技术的早期版本中，<code>S_ISVTX</code>位被称为粘住位（<code>sticky bit</code>）。</p>
<p>如果一个<strong>可执行程序文件</strong>的这一位被设置了，那么在该程序第一次被执行并结束时，其程序正文部分的一个副本仍被保存在交换区，（程序的正文部分是机器指令部分）。这使得下次执行该程序时能较快地将其装入内存中。其原因是：交换区占用连续磁盘空间，可将它视为连续文件，而且一个程序的正文部分在交换区中也是连续存放的，而在一般的UNIX文件系统中，文件的各数据块很可能是随机存放的。</p>
<p>对于常用的应用程序，例如文本编辑器和C编译器，我们常常设置它们所在文件的粘住位。自然，对于在交换区中可以同时存放的设置了粘住位的文件数是有一定限制的，以免过多占用交换区空间，但无论如何这是一个有用的技术。后来的UNIX版本称它为保存正文位（saved-text bit），因此也就有了常量<code>S_ISVTX</code>。现今较新的UNIX系统大多数都配置有虚拟存储系统以及快速文件系统，所以不再需要使用这种技术。</p>
<p>现今的系统扩展了粘住位的使用范围，<strong>允许针对目录设置粘住位</strong>。如果对一个目录设置了粘住位，则只有对该目录具有写权限的用户在满足下列之一的情况下，才能删除或更名该目录下的文件或目录：</p>
<ul>
<li>拥有此文件</li>
<li>拥有此目录</li>
<li>是超级用户</li>
</ul>
<p>目录<code>/tmp</code>是设置粘住位的典型候选者：任何用户都可在这个目录中创建文件。任一用户（用户、组和其他）对这个目录的权限通常都是读、写和执行（<code>rwx</code>）。但是用户不应能删除或更名属于其他人的文件，为此在这个目录的文件模式中都设置了粘住位。</p>
<p>即：假如<code>/tmp</code>下的文件A被用户U1所有，文件A的权限为777，那么所有用户都可以对该文件进行修改、移动、重命名等操作，<strong>但无法删除该文件</strong>。通常的用途在于用户团队协作的目录，用户可以相互修改文件，却<strong>只有用户所有者才能删除</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205173224552.png" alt="image-20221205173224552"></p>
<p>图中最后一位<code>t</code>就是粘住位。</p>
<h4 id="4-2-5-文件系统"><a href="#4-2-5-文件系统" class="headerlink" title="4.2.5 文件系统"></a>4.2.5 文件系统</h4><h5 id="①-磁盘的结构"><a href="#①-磁盘的结构" class="headerlink" title="① 磁盘的结构"></a>① 磁盘的结构</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180529903.png" alt="image-20221205180529903"></p>
<blockquote>
<p>磁盘</p>
</blockquote>
<p>一个磁盘（如一个 1T 的机械硬盘）由多个盘片（如下图中的 0 号盘片）叠加而成。</p>
<p>盘片的表面涂有磁性物质，这些磁性物质用来记录二进制数据。因为正反两面都可涂上磁性物质，故一个盘片可能会有两个盘面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180620706.png" alt="image-20221205180620706"></p>
<blockquote>
<p>磁道和扇区</p>
</blockquote>
<p>每个盘片被划分为一个个磁道（一个一个半径不同的同心圆环），每个磁道又划分为一个个扇区（磁道上的一个弧段）。扇区是磁盘的最小组成单元，通常是<code>512字节</code>。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180731436.png" alt="image-20221205180731436"></p>
<p>其中，最内侧磁道上的扇区面积最小，因此数据密度最大。</p>
<blockquote>
<p>柱面</p>
</blockquote>
<p>每个盘面对应一个磁头。所有的磁头都是连在同一个磁臂上的，因此所有磁头只能“共进退”。</p>
<p>所有盘面中半径相同的磁道组成柱面。如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180822250.png" alt="image-20221205180822250"></p>
<blockquote>
<p>磁盘容量计算</p>
</blockquote>
<p>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数</p>
<blockquote>
<p>磁盘的物理地址</p>
</blockquote>
<p>由上，可用<code>（柱面号，盘面号，扇区号）</code>来定位任意一个“磁盘块”，这里的“磁盘块”，实质上就是一个扇区。</p>
<p>可根据该地址读取一个“块”，操作如下：</p>
<ol>
<li>根据“柱面号”前后移动磁臂，让磁头指向指定柱面；</li>
<li>旋转磁盘，让磁头抵达待读的起始扇区。</li>
<li>激活指定盘面对应的磁头；</li>
<li>旋转磁盘，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。</li>
</ol>
<blockquote>
<p>块和簇</p>
</blockquote>
<p>磁盘块/簇（虚拟出来的）。 块是操作系统中最小的<strong>逻辑存储单位</strong>。操作系统与磁盘打交道的最小单位是磁盘块。</p>
<p>在Windows下如<code>NTFS</code>等文件系统中叫做簇；</p>
<p>在Linux下如<code>Ext4</code>等文件系统中叫做块（block）。一般来说，一个块（<code>block</code>）包含连续的8个扇区，每个扇区<code>512B</code>，因此一个块大小为<code>4096KB</code>。</p>
<p>每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。</p>
<h5 id="②-文件系统简介"><a href="#②-文件系统简介" class="headerlink" title="② 文件系统简介"></a>② 文件系统简介</h5><p>文件系统：文件或数据的存储和管理。目前，正在使用的UNIX文件系统有多种实现。</p>
<ul>
<li>传统的基于BSD的UNIX文件系统（称为<code>UFS</code>）。UFS是以Berkeley快速文件系统为基础的。本节讨论该文件系统。</li>
<li>读、写DOS格式软盘的文件系统（称为<code>PCFS</code>）</li>
<li>读CD的文件系统（称为<code>HSFS</code>）</li>
</ul>
<p>我们可以把一个磁盘分成一个或多个分区。<strong>每个分区可以包含一个文件系统</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205180335105.png" alt="image-20221205180335105"></p>
<ul>
<li><strong>i节点</strong>即为inode结构体的数组</li>
<li>数据块一般被分成了大小为4KB的块（block）</li>
<li>i节点图（i节点位图）：用来判断inode的空闲与占用情况</li>
<li>块位图：用来判断数据块的占用与空闲情况</li>
</ul>
<hr>
<p>对于普通文件，如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205181426945.png" alt="image-20221205181426945"></p>
<ul>
<li>i节点结构体中通常包含15个指针来指向数据块，最后三个指针为一二三级指针，用于扩充文件的大小；图中的i节点指向了三个数据块。</li>
<li>在图中有两个目录项（两个不同文件名的文件，但是inode编号相同）指向同一个i节点（此时称为<strong>硬链接</strong>，即<strong>目录项就是硬链接的同义词</strong>）。每个i节点中都有一个硬链接计数<code>st_nlink</code>，其值是指向该i节点的目录项数。只有当链接计数减少至0时，才可删除该文件（也就是可以释放该文件占用的数据块）。</li>
<li>i节点包含了文件有关的所有信息∶文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。stat 结构中的大多数信息都取自i节点。<strong>只有两项重要数据存放在目录项中∶文件名和i节点编号</strong>。</li>
</ul>
<p>对于目录，目录也是一种文件，它的属性也需要inode结构体存储，它的物理存储也需要通过inode中的指针来指向的数据块（此时的数据块就是<strong>目录块</strong>）来存储；</p>
<p>目录块存储的内容非常的简单，由<strong>目录项</strong>组成，<code>每条目录项有包含的文件名以及该文件名对应的inode编号</code>。</p>
<p>如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205194706533.png" alt="image-20221205194706533"></p>
<ul>
<li>编号为2549的i节点（<code>testdir</code>），其类型字段<code>st_mode</code>表示它是一个目录（因此它指向一个特殊的数据块——目录块），链接计数为2。任何一个叶目录（不包含任何其他目录的目录）的链接计数总是2，数值2来自于命名该目录（testdir）的目录项以及在该目录中的<code>.</code>项。</li>
<li>编号为1267的i节点，其类型字段<code>st_mode</code>表示它是一个目录，链接计数大于或等于3。它大于或等于3的原因是，至少有3个目录项指向它∶一个是命名它的目录项，第二个是在该目录中的<code>.</code>项，第三个是在其子目录 testdir 中的<code>..</code>项。注意，在父目录中的每一个子目录都使该父目录的链接计数增加1。</li>
</ul>
<h5 id="③-链接"><a href="#③-链接" class="headerlink" title="③ 链接"></a>③ 链接</h5><p>链接分为硬链接和符号链接（注意不是软链接）。</p>
<p>创建链接的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln src dest <span class="comment"># 创建src的硬链接为dest</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s src dest <span class="comment"># 创建src的符号链接为dest</span></span><br></pre></td></tr></table></figure>
<hr>
<p>硬链接对比：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># ln bigfile bigfile_link</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile</span></span><br><span class="line">  File: ‘bigfile’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 2</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:29:33.176048702 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 2</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:29:33.176048702 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<p>字段<code>Link</code>即为文件的硬链接数，硬链接数为2，说明有两个目录项指向了这个inode，并且注意两个文件的inode编号相同，说明同时指向了这个inode；</p>
<p>将源文件<code>bigfile</code>删除后，<code>bigfile_link</code>仍然存在：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># rm -rf bigfile</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:33:03.459331364 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure>
<p>此时硬链接数<code>Link</code>变为1；</p>
<hr>
<p>符号链接对比：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng tmp]<span class="comment"># ln -s bigfile_link bigfile_s</span></span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_link </span></span><br><span class="line">  File: ‘bigfile_link’</span><br><span class="line">  Size: 5368709120      Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769d    Inode: 26199       Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 16:26:39.166784814 +0800</span><br><span class="line">Modify: 2022-12-05 16:19:40.734216438 +0800</span><br><span class="line">Change: 2022-12-05 20:33:03.459331364 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># stat bigfile_s</span></span><br><span class="line">  File: ‘bigfile_s’ -&gt; ‘bigfile_link’</span><br><span class="line">  Size: 12              Blocks: 0          IO Block: 4096   symbolic link</span><br><span class="line">Device: fd01h/64769d    Inode: 26201       Links: 1</span><br><span class="line">Access: (0777/lrwxrwxrwx)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line">Modify: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line">Change: 2022-12-05 20:34:11.189456100 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@HongyiZeng tmp]<span class="comment"># ll bigfile_s</span></span><br><span class="line">lrwxrwxrwx 1 root root 12 Dec  5 20:34 bigfile_s -&gt; bigfile_link</span><br></pre></td></tr></table></figure>
<p>可以看到硬链接数并未改变；此外符号链接文件的大小为12字节，物理占用的块甚至为0；文件类型标识也变为了<code>symbolic link</code>和<code>l</code>；</p>
<p>删除原始文件后，发现符号链接文件的链接已成非法链接（红色部分）：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221205203655039.png" alt="image-20221205203655039"></p>
<hr>
<p>相关的系统调用：</p>
<p><code>link</code> 函数专门用来创建硬链接的，功能和 ln 命令一样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>unlink</code>函数删除一个文件的目录项并减少它的链接数，若成功则返回0，否则返回-1，错误原因存于error。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br></pre></td></tr></table></figure>
<hr>
<p>对比：硬链接不能给分区建立，不能给目录建立，而符号链接可以。</p>
<h4 id="4-2-6-杂项"><a href="#4-2-6-杂项" class="headerlink" title="4.2.6 杂项"></a>4.2.6 杂项</h4><blockquote>
<p>文件的删除、重命名和移动</p>
</blockquote>
<ul>
<li><code>remove</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rename</code>：是<code>mv</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改文件的时间</p>
</blockquote>
<ul>
<li><code>utime</code>：可更改文件的最后读的时间和最后修改的时间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utime.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct utimbuf *times)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更改当前工作路径</p>
</blockquote>
<ul>
<li><code>chdir</code>：是<code>cd</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getcwd</code>：是<code>pwd</code>命令的系统调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getwd</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_current_dir_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-7-glob"><a href="#4-2-7-glob" class="headerlink" title="4.2.7 glob"></a>4.2.7 glob</h4><p>该节内容为分析目录和读取目录内容。</p>
<p>glob函数原型（模型匹配函数）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">glob</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pattern, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">int</span> (*errfunc) (<span class="keyword">const</span> <span class="keyword">char</span> *epath, <span class="keyword">int</span> eerrno),</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">glob_t</span> *pglob)</span></span>;</span><br><span class="line"><span class="comment">// 释放glob函数调用的空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">globfree</span><span class="params">(<span class="keyword">glob_t</span> *pglob)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pattern</code>： 通配符，要分析的<code>pattern</code>，如<code>/*</code>表示匹配根文件下的所有文件（不包括隐藏文件）   </li>
<li><code>flags</code>：flags参数可以设置特殊要求，如无特殊要求置为0</li>
<li><code>errfunc</code>：函数指针，glob函数执行出错会执行的函数，出错的路径会回填到epath中，出错的原因回填到eerrno中。如不关注错误可设置为<code>NULL</code></li>
<li><code>pglob</code>：解析出来的结果放在这个参数里，是一个结构体指针</li>
<li>返回值：成功返回0，错误返回非0</li>
</ul>
<p>其中，<code>glob_t</code>是一个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">// pathc与pathv类似于main函数参数argc与argv</span></span><br><span class="line">    <span class="keyword">size_t</span>    gl_pathc;    <span class="comment">//匹配到的数量</span></span><br><span class="line">    <span class="keyword">char</span>    **gl_pathv;    <span class="comment">//匹配到的元素放在这里</span></span><br><span class="line">    <span class="keyword">size_t</span>    gl_offs; </span><br><span class="line">&#125; <span class="keyword">glob_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例</p>
</blockquote>
<p>打印出<code>/etc/*.conf</code>的文件名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通配符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAT <span class="meta-string">&quot;//etc//*.conf&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">errfunc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *epath, <span class="keyword">int</span> eerrno)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(epath);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;ERROR: %d&quot;</span>, eerrno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = glob(PAT, <span class="number">0</span>, errfunc, &amp;globres);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR CODE = %d\n&quot;</span>, err);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; globres.gl_pathc; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(globres.gl_pathv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放空间</span></span><br><span class="line">	globfree(&amp;globres);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./glob </span></span><br><span class="line">/etc/GeoIP.conf</span><br><span class="line">/etc/asound.conf</span><br><span class="line">/etc/chrony.conf</span><br><span class="line">/etc/dat.conf</span><br><span class="line">其余略</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一组对目录操作的函数</p>
</blockquote>
<p>和对文件操作的函数基于<code>FILE</code>结构体类似，对目录的操作基于名为<code>DIR</code>的结构体。</p>
<p>下面是常用的对目录进行操作的函数，他们的功能可以被<code>glob</code>替代。</p>
<p>暂略</p>
<h2 id="5-进程环境"><a href="#5-进程环境" class="headerlink" title="5 进程环境"></a>5 进程环境</h2><p>本节对应第七章——进程环境；</p>
<h3 id="5-1-main函数"><a href="#5-1-main函数" class="headerlink" title="5.1 main函数"></a>5.1 main函数</h3><p>C程序总是从main函数开始执行，从main函数结束执行。即main是程序的入口和出口。</p>
<p>当内核执行C程序时（使用一个exec函数），在调用main前先调用一个特殊的<strong>启动例程</strong>。可执行程序文件将此启动例程指定为程序的起始地址———这是由连接编辑器设置的，而连接编辑器则由C编译器调用。</p>
<p>启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用main函数做好安排。</p>
<h3 id="5-2-进程终止"><a href="#5-2-进程终止" class="headerlink" title="5.2 进程终止"></a>5.2 进程终止</h3><h4 id="5-2-1-终止方式"><a href="#5-2-1-终止方式" class="headerlink" title="5.2.1 终止方式"></a>5.2.1 终止方式</h4><p>共有8种方式让进程终止。其中5种为正常退出：</p>
<ol>
<li>从main返回</li>
<li>调用<code>exit</code>（C库函数）</li>
<li>调用<code>_exit</code>或<code>_Exit</code>（系统调用）</li>
<li>最后一个线程从其启动例程返回</li>
<li>从最后一个线程调用<code>pthread_exit</code></li>
</ol>
<p>异常终止有3种方式：</p>
<ol>
<li>调用<code>abort</code></li>
<li>接到一个信号</li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h4 id="5-2-2-main函数的返回值"><a href="#5-2-2-main函数的返回值" class="headerlink" title="5.2.2 main函数的返回值"></a>5.2.2 <code>main</code>函数的返回值</h4><p>main函数的返回值给main函数的<strong>父进程</strong>。</p>
<p>假设一个程序名为<code>main_test</code>，则在终端上执行该程序时，父进程为<code>shell</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main_test</span><br></pre></td></tr></table></figure>
<p>可通过<code>$?</code>（表示显示最后命令的退出状态）查看该返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./main1 </span></span><br><span class="line">Hello World!</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $?</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>如果将程序更改为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则执行结果为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># ./main1 </span></span><br><span class="line">Hello World!</span><br><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $?</span></span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>此时会将<code>printf</code>的返回值（打印字符的个数）作为main函数的返回值给父进程<code>shell</code>。</p>
<h4 id="5-2-3-钩子函数atexit"><a href="#5-2-3-钩子函数atexit" class="headerlink" title="5.2.3 钩子函数atexit"></a>5.2.3 钩子函数<code>atexit</code></h4><p>按照ISO C的规定，一个进程可以登记多至32个函数，这些函数将由<code>exit</code>自动调用。我们称这些函数为<strong>终止处理程序</strong>（<code>exit handler</code>），并调用 <code>atexit</code> 函数来登记这些函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>atexit</code>当程序<strong>正常终止时</strong>，调用指定的函数（终止处理程序） <strong>func</strong>。可以在任何地方注册终止函数，但它会在程序终止的时候被调用。先注册的后调用。</p>
<ul>
<li><strong>func</strong> — 在程序终止时被调用的函数，该函数无参且无返回值，它是一个函数指针，因此传入的参数应该是一个函数的地址，即函数名（函数名就是函数的首地址）。</li>
<li>如果函数成功注册，则该函数返回零，否则返回一个非零值。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f1() is working!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f2() is working!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止处理程序</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;f3() is working!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">    <span class="comment">// 先注册的后被调用</span></span><br><span class="line">    <span class="comment">// 钩子函数的书写顺序并不是实际执行顺序，atexit会在程序终止时被调用</span></span><br><span class="line">    <span class="comment">// atexit参数用指针来接收，因此需要传入地址，而函数名就是函数的地址</span></span><br><span class="line">    atexit(f1);</span><br><span class="line">    atexit(f2);</span><br><span class="line">    atexit(f3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Begin</span><br><span class="line">End</span><br><span class="line">f3() is working!</span><br><span class="line">f2() is working!</span><br><span class="line">f1() is working!</span><br></pre></td></tr></table></figure>
<h4 id="5-2-4-exit和-exit"><a href="#5-2-4-exit和-exit" class="headerlink" title="5.2.4 exit和_exit"></a>5.2.4 exit和_exit</h4><p><code>exit</code>是库函数，而<code>_exit</code>是系统调用，前者使用了后者。</p>
<p>除此之外，<code>_exit()</code>执行后会立即返回给内核，而<code>exit()</code>要先执行一些清除和终止操作，然后将控制权交给内核。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210113101221.png" alt="image-20221210113101221"></p>
<h3 id="5-3-命令行参数"><a href="#5-3-命令行参数" class="headerlink" title="5.3 命令行参数"></a>5.3 命令行参数</h3><p>暂略</p>
<h3 id="5-4-环境变量"><a href="#5-4-环境变量" class="headerlink" title="5.4 环境变量"></a>5.4 环境变量</h3><h4 id="5-4-1-简介"><a href="#5-4-1-简介" class="headerlink" title="5.4.1 简介"></a>5.4.1 简介</h4><p>环境变量的含义：程序（操作系统命令和应用程序）的执行都需要运行环境，这个环境是由多个环境变量组成的。</p>
<p>按变量的周期划为永久变量和临时性变量2种：</p>
<ol>
<li>永久变量：通过修改配置文件，配置之后变量永久生效。</li>
<li>临时性变量：使用命令如export等命令设置，设置之后马上生效。当关闭shell的时候失效（这种主要用于测试比较多）。</li>
</ol>
<p>按照影响范围分为用户变量和系统变量2种：</p>
<ol>
<li>用户变量（局部变量）：修改的设置只对某个用户的路径或执行起作用；</li>
<li>系统变量（全局变量）：影响范围是整个系统；</li>
</ol>
<p>环境变量本质上是一个<code>kv键值对</code>。</p>
<h4 id="5-4-2-查看环境变量"><a href="#5-4-2-查看环境变量" class="headerlink" title="5.4.2 查看环境变量"></a>5.4.2 查看环境变量</h4><p>在Shell下，用<code>env</code>命令查看<strong>当前用户</strong>全部的环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># env</span></span><br><span class="line">XDG_SESSION_ID=139874</span><br><span class="line">HOSTNAME=HongyiZeng</span><br><span class="line">TERM=xterm-256color</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">HISTSIZE=3000</span><br><span class="line">SSH_TTY=/dev/pts/0</span><br><span class="line">USER=root</span><br><span class="line">MAIL=/var/spool/mail/root</span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/bin:/root/bin:/root/bin</span><br><span class="line">PWD=/usr/<span class="built_in">local</span>/linux_c/fs</span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.8.0_161</span><br><span class="line">LANG=en_US.UTF-8</span><br><span class="line">NEXUS_HOME=/usr/<span class="built_in">local</span>/nexus/nexus-3.20.1-01</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">LOGNAME=root</span><br><span class="line">CLASSPATH=/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/lib/</span><br><span class="line">SSH_CONNECTION=81.69.102.136 35390 10.0.24.5 22</span><br><span class="line">LESSOPEN=||/usr/bin/lesspipe.sh %s</span><br><span class="line">PROMPT_COMMAND=<span class="built_in">history</span> -a; <span class="built_in">history</span> -a; <span class="built_in">printf</span> <span class="string">&quot;\033]0;%s@%s:%s\007&quot;</span> <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;HOSTNAME%%.*&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;PWD/#$HOME/~&#125;</span>&quot;</span></span><br><span class="line">XDG_RUNTIME_DIR=/run/user/0</span><br><span class="line">HISTTIMEFORMAT=%F %T </span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/usr/<span class="built_in">local</span>/linux_c</span><br></pre></td></tr></table></figure>
<p><code>export</code>命令显示<strong>当前系统</strong>定义的所有环境变量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># export</span></span><br><span class="line"><span class="built_in">declare</span> -x CLASSPATH=<span class="string">&quot;/usr/local/java/jdk1.8.0_161/lib/&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTSIZE=<span class="string">&quot;3000&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HISTTIMEFORMAT=<span class="string">&quot;%F %T &quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HOME=<span class="string">&quot;/root&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x HOSTNAME=<span class="string">&quot;HongyiZeng&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x JAVA_HOME=<span class="string">&quot;/usr/local/java/jdk1.8.0_161&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x LANG=<span class="string">&quot;en_US.UTF-8&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x LESSOPEN=<span class="string">&quot;||/usr/bin/lesspipe.sh %s&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x LOGNAME=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x MAIL=<span class="string">&quot;/var/spool/mail/root&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x NEXUS_HOME=<span class="string">&quot;/usr/local/nexus/nexus-3.20.1-01&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x OLDPWD=<span class="string">&quot;/usr/local/linux_c&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x PATH=<span class="string">&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/java/jdk1.8.0_161/bin:/root/bin:/root/bin&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x PROMPT_COMMAND=<span class="string">&quot;history -a; history -a; printf \&quot;\\033]0;%s@%s:%s\\007\&quot; \&quot;\$&#123;USER&#125;\&quot; \&quot;\$&#123;HOSTNAME%%.*&#125;\&quot; \&quot;\$&#123;PWD/#\$HOME/~&#125;\&quot;&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x PWD=<span class="string">&quot;/usr/local/linux_c/fs&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x SHELL=<span class="string">&quot;/bin/bash&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x SHLVL=<span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_CLIENT=<span class="string">&quot;81.69.102.136 35390 22&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_CONNECTION=<span class="string">&quot;81.69.102.136 35390 10.0.24.5 22&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x SSH_TTY=<span class="string">&quot;/dev/pts/0&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x TERM=<span class="string">&quot;xterm-256color&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x USER=<span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x XDG_RUNTIME_DIR=<span class="string">&quot;/run/user/0&quot;</span></span><br><span class="line"><span class="built_in">declare</span> -x XDG_SESSION_ID=<span class="string">&quot;139874&quot;</span></span><br></pre></td></tr></table></figure>
<p>查看某个环境变量的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$KEY</span></span><br></pre></td></tr></table></figure>
<p>例如，查看<code>PATH</code>的值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng fs]<span class="comment"># echo $PATH</span></span><br><span class="line">/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/usr/<span class="built_in">local</span>/java/jdk1.8.0_161/bin:/root/bin:/root/bin</span><br></pre></td></tr></table></figure>
<h4 id="5-4-3-设置环境变量"><a href="#5-4-3-设置环境变量" class="headerlink" title="5.4.3 设置环境变量"></a>5.4.3 设置环境变量</h4><p>在用户的家目录<code>/home/用户名</code>下，有几个特别的文件：</p>
<ul>
<li><code>.bash_profile</code>（推荐首选）：当用户登录时执行，每个用户都可以使用该文件来配置<strong>专属于自己的环境变量</strong>。</li>
<li><code>.bashrc</code>：当用户登录时以及每次打开新的Shell时该文件都将被读取，不推荐在里面配置用户专用的环境变量，因为每开一个Shell，该文件都会被读取一次，效率肯定受影响。</li>
<li><code>.bash_logout</code>：当每次退出系统（退出bash shell）时执行该文件。</li>
<li><code>.bash_history</code>：保存了当前用户使用过的历史命令</li>
</ul>
<h4 id="5-4-4-环境表"><a href="#5-4-4-环境表" class="headerlink" title="5.4.4 环境表"></a>5.4.4 环境表</h4><p>每个程序都接收到一张环境表。与参数表一样，环境表也是一个字符指针数组，其中每个指针包含一个以<code>null</code>结束的C字符串的地址。</p>
<p>全局变量<code>environ</code>则包含了该指针数组的地址∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure>
<p>例如，如果该环境包含5个字符串，那么它看起来如图中所示。其中，每个字符串的结尾处都显式地有一个null字节。我们称 <code>environ</code> 为环境指针，指针数组为环境表，其中各指针指向的字符串为环境字符串。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221210163517747.png" alt="image-20221210163517747"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用声明外部的变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; environ[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关库函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据环境变量的键name来获取环境变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 键name，值value，overwrite是否覆盖</span></span><br><span class="line"><span class="comment">// 当name存在时，且overwrite为1，表示改变环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据key删除环境变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(getenv(<span class="string">&quot;PATH&quot;</span>));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-共享库"><a href="#5-5-共享库" class="headerlink" title="5.5 共享库"></a>5.5 共享库</h3><p>共享库使得可执行文件中不再需要包含公用的库函数，而只需在所有进程都可引用的存储区中保存这种库例程的一个副本。</p>
<p>程序第一次执行或者第一次调用某个库函数时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。</p>
<p>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新连接编辑（假定参数的数目和类型都没有发生改变）。</p>
<blockquote>
<p>动态库的相关库函数</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dladdr,  dlclose,  dlerror,  dlopen,  dlsym, dlvsym - programming interface to dynamic linking loader</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="comment">// 该函数将打开一个新库，并把它装入内存。该函数主要用来加载库中的符号，这些符号在编译的时候是不知道的。这种机制使得在系统中添加或者删除一个模块时，都不需要重新进行编译</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个描述最后一次调用dlopen、dlsym，或dlclose的错误信息的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">dlerror</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在打开的动态库中查找符号的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭动态库</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-6-函数间跳转"><a href="#5-6-函数间跳转" class="headerlink" title="5.6 函数间跳转"></a>5.6 函数间跳转</h3><blockquote>
<p>补充：goto语句</p>
</blockquote>
<p>C 语言中的 goto 语句允许把控制无条件转移到<strong>同一函数内</strong>的被标记的语句。</p>
<p>语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br><span class="line">..</span><br><span class="line">.</span><br><span class="line">label: statement;</span><br></pre></td></tr></table></figure>
<p>在这里，label 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221211193000103.png" alt="image-20221211193000103"></p>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* do 循环执行 */</span></span><br><span class="line">   LOOP:</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>( a == <span class="number">15</span>) &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">goto</span> LOOP;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;a 的值： %d\n&quot;</span>, a);</span><br><span class="line">      a++;</span><br><span class="line">   &#125; <span class="keyword">while</span>(a &lt; <span class="number">20</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a 的值： 10</span><br><span class="line">a 的值： 11</span><br><span class="line">a 的值： 12</span><br><span class="line">a 的值： 13</span><br><span class="line">a 的值： 14</span><br><span class="line">a 的值： 16</span><br><span class="line">a 的值： 17</span><br><span class="line">a 的值： 18</span><br><span class="line">a 的值： 19</span><br></pre></td></tr></table></figure>
<hr>
<p><code>setjmp</code>和<code>longjmp</code>可以实现非局部控制转移即从一个函数到另外一个函数的跳转。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>setjmp</code>函数用于记录当前位置，保存调用函数的栈环境在结构体<code>jmp_buf buf</code>（相当于保护现场）。函数输入参数为<code>jmp_buf</code>类型（这个结构体类似于goto的跳转标识），返回整型。当第一次调用时（设置跳转点），它的值为0；当第二次调用时（从别处跳转回来，即调用<code>longjmp</code>时）返回非零值；总之<strong>执行一次，返回两次</strong>，因此，<code>setjmp</code>函数后常常跟上分支语句。</p>
</li>
<li><p><code>longjmp</code>的作用是使用<code>setjmp</code>保存在<code>buf</code>中的栈环境信息返回到<code>setjmp</code>的位置，也就是当执行<code>longjmp</code>时程序又回到<code>setjmp</code>处（相当于恢复现场）。形参<code>val</code>是调用<code>longjmp</code>时<code>setjmp</code>函数返回的值，为非零值，如果故意设置为0，也会被修改为1；</p>
</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call d().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    d();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():d() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call c().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    c();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():c() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call b().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    b();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():b() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call a().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():a() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">main():Begin.</span><br><span class="line">main():Call a().</span><br><span class="line">a():Begin.</span><br><span class="line">a():Call b().</span><br><span class="line">b():Begin.</span><br><span class="line">b():Call c().</span><br><span class="line">c():Begin.</span><br><span class="line">c():Call d().</span><br><span class="line">d():Begin.</span><br><span class="line">d():End.</span><br><span class="line">c():d() returned.</span><br><span class="line">c():End.</span><br><span class="line">b():c() returned.</span><br><span class="line">b():End.</span><br><span class="line">a():b() returned.</span><br><span class="line">a():End.</span><br><span class="line">main():a() returned.</span><br><span class="line">main():End.</span><br></pre></td></tr></table></figure>
<p>注：ANSI C 定义了许多宏。在编程中可以使用这些宏，但是不能直接修改这些预定义的宏。</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__DATE__ 当前日期，一个以 “MMM DD YYYY” 格式表示的字符串常量。</span><br><span class="line">__TIME__ 当前时间，一个以 “HH:MM:SS” 格式表示的字符串常量。</span><br><span class="line">__FILE__ 这会包含当前文件名，一个字符串常量。</span><br><span class="line">__LINE__ 这会包含当前行号，一个十进制常量。</span><br><span class="line">__FUNCTION__ 程序预编译时预编译器将用所在的函数名，返回值是字符串;</span><br></pre></td></tr></table></figure>
<p>现在改写程序，在函数a进行<code>setjmp</code>，函数d进行<code>longjmp</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转点的现场环境</span></span><br><span class="line"><span class="keyword">static</span> jmp_buf save;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Jump now!.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="comment">// 向save跳转，并携带返回值为6</span></span><br><span class="line">    longjmp(save, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call d().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    d();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():d() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call c().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    c();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():c() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回值</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="comment">// 设置跳转点</span></span><br><span class="line">    <span class="comment">// setjmp一次调用，两次返回</span></span><br><span class="line">    ret = setjmp(save);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():Call b().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">        b();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():b() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s():Jumped back here with code %d.\n&quot;</span>, __FUNCTION__, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Begin.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():Call a().\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    a();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():a() returned.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s():End.\n&quot;</span>, __FUNCTION__);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">main():Begin.</span><br><span class="line">main():Call a().</span><br><span class="line">a():Begin.</span><br><span class="line">a():Call b().</span><br><span class="line">b():Begin.</span><br><span class="line">b():Call c().</span><br><span class="line">c():Begin.</span><br><span class="line">c():Call d().</span><br><span class="line">d():Begin.</span><br><span class="line">d():Jump now!.</span><br><span class="line">a():Jumped back here with code 6.</span><br><span class="line">a():End.</span><br><span class="line">main():a() returned.</span><br><span class="line">main():End.</span><br></pre></td></tr></table></figure>
<h3 id="5-7-资源的获取和控制"><a href="#5-7-资源的获取和控制" class="headerlink" title="5.7 资源的获取和控制"></a>5.7 资源的获取和控制</h3><p>获取或设置资源使用限制：linux下每种资源都有相关的软硬限制，软限制是内核强加给相应资源的限制值，硬限制是软限制的最大值。</p>
<p>非授权调用的进程只能将其软限制指定为<code>0~硬限制范围中的某个值</code>，同时能不可逆转地降低其硬限制。</p>
<p>授权进程（root用户）可以任意改变其软硬限制。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>rlimit</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_cur; <span class="comment">// 软限制</span></span><br><span class="line">　　<span class="keyword">rlim_t</span> rlim_max; <span class="comment">// 硬限制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>resource</code>的选择有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RLIMIT_AS <span class="comment">//进程的最大虚内存空间，字节为单位。</span></span><br><span class="line">RLIMIT_CORE <span class="comment">//内核转存文件的最大长度。</span></span><br><span class="line">RLIMIT_CPU <span class="comment">//最大允许的CPU使用时间，秒为单位。当进程达到软限制，内核将给其发送SIGXCPU信号，这一信号的默认行为是终止进程的执行。然而，可以捕捉信号，处理句柄可将控制返回给主程序。如果进程继续耗费CPU时间，核心会以每秒一次的频率给其发送SIGXCPU信号，直到达到硬限制，那时将给进程发送 SIGKILL信号终止其执行。</span></span><br><span class="line">RLIMIT_DATA <span class="comment">//进程数据段的最大值。</span></span><br><span class="line">RLIMIT_FSIZE <span class="comment">//进程可建立的文件的最大长度。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。</span></span><br><span class="line">RLIMIT_LOCKS <span class="comment">//进程可建立的锁和租赁的最大值。</span></span><br><span class="line">RLIMIT_MEMLOCK <span class="comment">//进程可锁定在内存中的最大数据量，字节为单位。</span></span><br><span class="line">RLIMIT_MSGQUEUE <span class="comment">//进程可为POSIX消息队列分配的最大字节数。</span></span><br><span class="line">RLIMIT_NICE <span class="comment">//进程可通过setpriority() 或 nice()调用设置的最大完美值。</span></span><br><span class="line">RLIMIT_NOFILE <span class="comment">//指定比进程可打开的最大文件描述词大一的值，超出此值，将会产生EMFILE错误。</span></span><br><span class="line">RLIMIT_NPROC <span class="comment">//用户可拥有的最大进程数。</span></span><br><span class="line">RLIMIT_RTPRIO <span class="comment">//进程可通过sched_setscheduler 和 sched_setparam设置的最大实时优先级。</span></span><br><span class="line">RLIMIT_SIGPENDING <span class="comment">//用户可拥有的最大挂起信号数。</span></span><br><span class="line">RLIMIT_STACK <span class="comment">//最大的进程堆栈，以字节为单位。</span></span><br></pre></td></tr></table></figure>
<p>返回值：</p>
<ul>
<li>成功执行时，返回0。失败返回-1，errno被设为以下的某个值</li>
<li><code>EFAULT</code>：rlim指针指向的空间不可访问</li>
<li><code>EINVAL</code>：参数无效</li>
<li><code>EPERM</code>：增加资源限制值时，权能不允许</li>
</ul>
<h2 id="6-进程控制"><a href="#6-进程控制" class="headerlink" title="6 进程控制"></a>6 进程控制</h2><p>该节对应第八章——进程控制。</p>
<h3 id="6-1-进程标识"><a href="#6-1-进程标识" class="headerlink" title="6.1 进程标识"></a>6.1 进程标识</h3><p>每个进程都有一个<strong>非负整型</strong>表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。例如，应用程序有时就把进程 ID 作为名字的一部分来创建一个唯一的文件名。</p>
<p>进程标识符的类型为<code>pid_t</code>，其本质上是一个<strong>无符号整型（unsigned int）</strong>的类型别名。</p>
<p>进程ID是可复用的。当一个进程终止后，其进程ID就成为复用的候选者。大多数 UNIX 系统实现<strong>延迟复用算法</strong>，使得赋予新建进程的 ID不同于最近终止进程所使用的ID。这防止了将新进程误认为是使用同一ID的某个已终止的先前进程。</p>
<hr>
<p>系统中有一些专用进程，但具体细节随实现而不同。</p>
<ul>
<li>ID为0的进程通常是<strong>调度进程</strong>，常常被称为交换进程（swapper）。该进程是内核的一部分，它并不执行任何硬盘上的程序，因此也被称为系统进程。</li>
<li>进程ID1通常是 <code>init</code> 进程，在自举过程结束时由内核调用。该进程的程序文件在UNIX的早期版本中是/etc/init，在较新版本中是/sbin/init。此进程负责在自举内核后启动一个UNIX系统。<code>init</code> 进程决不会终止。它是一个普通的用户进程（与交换进程不同，它不是内核中的系统进程），但是它以超级用户特权运行。</li>
</ul>
<blockquote>
<p>常用系统调用</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回调用该函数进程的进程标识符</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回父进程的进程标识符</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：<code>ps</code>命令</p>
</blockquote>
<p>Linux 中的 ps 命令是 <code>Process Status</code> 的缩写。ps 命令用来列出系统中当前正在运行的那些进程，就是执行 ps 命令的那个时刻的那些进程的快照。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps axf</span><br><span class="line">ps axm</span><br><span class="line">ps ax -L</span><br></pre></td></tr></table></figure>
<h3 id="6-2-进程产生"><a href="#6-2-进程产生" class="headerlink" title="6.2 进程产生"></a>6.2 进程产生</h3><h4 id="6-2-1-fork"><a href="#6-2-1-fork" class="headerlink" title="6.2.1 fork"></a>6.2.1 fork</h4><p><code>init</code>进程：pid为1，是所有进程的祖先进程，注意不是父进程。</p>
<p>一个现有的进程可以调用<code>fork</code>函数创建一个新进程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由fork创建的新进程被称为<strong>子进程</strong>（child process）。</p>
<p>返回值：<strong>fork函数被调用一次，但返回两次</strong>。子进程的返回值是0，父进程的返回值则是新建子进程的进程PID。如果失败则返回<code>-1</code>，并设置<code>errno</code>。和<code>setjmp</code>类似，fork语句后常常跟上分支语句进行判断。</p>
<p><strong>子进程和父进程继续执行fork调用之后的指令</strong>。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆、栈和<strong>缓冲区</strong>的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分，除了读时共享的部分。</p>
<ul>
<li><p>fork后父子进程的区别</p>
<ul>
<li><p>fork返回值不同</p>
</li>
<li><p>两个进程的<code>pid</code>不同</p>
</li>
<li><p>两个进程的<code>ppid</code>也不同，父进程的ppid是它的父进程pid，而子进程的ppid是创建它的进程的pid</p>
</li>
<li><p>父进程的未决信号和文件锁不继承</p>
</li>
<li><p>子进程的资源利用量归零</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>程序实例1——<code>fork</code>的使用</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>, getpid());</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// ---------------------------</span></span><br><span class="line">    <span class="comment">// 父进程调用fork后，父子进程都从这里开始执行</span></span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 如果返回值pid为0，则为子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Child is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果返回值pid大于0，则为父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Parent is working!\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]:End!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：（可能形式）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./fork1 </span><br><span class="line">[16023]:Begin!</span><br><span class="line">[16023]:Parent is working!</span><br><span class="line">[16023]:End!</span><br><span class="line">[root@HongyiZeng proc]# [16024]:Child is working!</span><br><span class="line">[16024]:End!</span><br></pre></td></tr></table></figure>
<p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的<strong>调度算法</strong>。</p>
<p>如果在main程序返回前添加一行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getchar();</span><br></pre></td></tr></table></figure>
<p>使得父子进程都暂停，再使用命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf</span><br></pre></td></tr></table></figure>
<p>可以看到两个进程与bash的关系如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212095917346.png" alt="image-20221212095917346"></p>
<blockquote>
<p>程序实例2——<code>fflush</code>的重要性</p>
</blockquote>
<p>对于上述程序的结果，注意到<code>Begin</code>只打印了一次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./fork1 </span></span><br><span class="line">[16023]:Begin!</span><br><span class="line">[16023]:Parent is working!</span><br><span class="line">[16023]:End!</span><br><span class="line">[16024]:Child is working!</span><br><span class="line">[16024]:End!</span><br></pre></td></tr></table></figure>
<p>如果将该打印信息重定向至某个文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./fork1 &gt; /tmp/out</span><br></pre></td></tr></table></figure>
<p>再查看该文件的内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">[18060]:Begin!</span><br><span class="line">[18060]:Parent is working!</span><br><span class="line">[18060]:End!</span><br><span class="line">[18060]:Begin!</span><br><span class="line">[18061]:Child is working!</span><br><span class="line">[18061]:End!</span><br></pre></td></tr></table></figure>
<p>注意到<code>Begin</code>打印了两次。</p>
<p>原因：对于重定向至文件，采用的是全缓冲（除标准输出和标准错误输出），只有进程结束或者缓冲满的时候才刷新缓冲区（遇到换行符不刷新），将缓冲区的内容写入到文件。因此，父进程<code>fork</code>时，尚未刷新缓冲区，因此缓冲区的内容<code>[18060]:Begin!</code>（注意进程号已经固定了！）被复制到子进程的缓冲区中，当父子进程执行结束时，强制刷新，输出两次<code>Begin</code>。</p>
<p>为防止缓冲区内容被复制，父进程在<code>fork</code>之前需要强制刷新所有已经打开的流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]:Begin!\n&quot;</span>, getpid());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 强制刷新所有打开的流!!!</span></span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 再调用fork</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="comment">// ---------------------------</span></span><br><span class="line">    <span class="comment">// 父进程调用fork后，父子进程都从这里开始执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，只打印了一句<code>Begin</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./fork1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">[19853]:Begin!</span><br><span class="line">[19853]:Parent is working!</span><br><span class="line">[19853]:End!</span><br><span class="line">[19854]:Child is working!</span><br><span class="line">[19854]:End!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例3——找质数</p>
</blockquote>
<p>需求：找出<code>30000000~30000200</code>的所有质数。</p>
<ul>
<li>单进程版：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># time ./primer0 </span></span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000037 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000149 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line"></span><br><span class="line">real    0m0.967s</span><br><span class="line">user    0m0.950s</span><br><span class="line">sys     0m0.001s</span><br></pre></td></tr></table></figure>
<ul>
<li>多进程协同：</li>
</ul>
<p>一个错误的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：子进程执行完<code>pid==0</code>的分支后，又会执行<code>for</code>循环的部分，此时会再次<code>fork</code>，导致进程数量指数式的增长，超出可用内存。</p>
<p>更正：在执行完<code>pid==0</code>的分支后面（完成了对某个数<code>i</code>的判断的任务），需要正常退出<code>exit(0)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// child</span></span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">            <span class="comment">// 子进程退出</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># time ./primer1</span></span><br><span class="line">30000037 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000149 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line"></span><br><span class="line">real    0m0.048s</span><br><span class="line">user    0m0.001s</span><br><span class="line">sys     0m0.008s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例4——孤儿进程和僵尸进程</p>
</blockquote>
<p>修改1：在子进程在退出前，先睡眠1000s，这样父进程会先执行完毕而退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">            <span class="comment">// 子进程睡眠1000s</span></span><br><span class="line">            sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再使用命令<code>ps axf</code>查看：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212105453780.png" alt="image-20221212105453780"></p>
<p>此时201个子进程的状态为<code>S</code>（可中断的睡眠状态），且父进程为<code>init</code>进程（每个进程以顶格形式出现）。这里的子进程在<code>init</code>进程接管之前就是孤儿进程。</p>
<p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被 <code>init</code> 进程(进程号为1)所收养，并由 init 进程对它们完成状态收集工作，孤儿进程并不会有什么危害。</p>
<hr>
<p>修改2：在父进程退出之前，先休眠1000s，再查看进程状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 父进程睡眠1000s再退出</span></span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212110215722.png" alt="image-20221212110215722"></p>
<p>可以看到子进程状态为<code>Z</code>，即为僵尸状态。</p>
<p><strong>僵尸进程</strong>：一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息（收尸），那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p> 僵尸进程虽然<strong>不占有任何内存空间</strong>，但如果父进程不调用 wait() / waitpid() 的话，那么保留的信息就不会释放，<strong>其进程号就会一直被占用</strong>，而系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，此即为僵尸进程的危害。</p>
<h4 id="6-2-2-vfork"><a href="#6-2-2-vfork" class="headerlink" title="6.2.2 vfork"></a>6.2.2 vfork</h4><p>考虑这样一个场景，父进程使用了一个占用内存很大的数据，此时它fork了一个子进程，而子进程仅仅打印一个字符串就退出了，此时这块很大的数据复制到子进程的内存空间中，造成了很大的内存浪费。</p>
<p>为了解决这个问题，在<code>fork</code>实现中，增加了<strong>读时共享，写时复制（Copy-On-Write，COW）</strong>的机制。写时复制可以避免拷贝大量根本就不会使用的数据（地址空间包含的数据多达数十兆）。因此可以看出写时复制极大提升了Linux系统下fork函数运行的性能。</p>
<p>写时复制指的是子进程的页表项指向与父进程相同的物理页，这也只需要拷贝父进程的页表项就可以了，不会复制整个内存地址空间，同时把这些页表项标记为<strong>只读</strong>。</p>
<ul>
<li><p>读时共享：如果父子进行都不对页面进行操作或只读，那么便一直共享同一份物理页面。</p>
</li>
<li><p>写时复制：只要父子进程有一个尝试进行修改某一个页面（写时），那么就会发生缺页异常。那么内核便会为该页面创建一个新的物理页面，并将内容复制到新的物理页面中，让父子进程真正地各自拥有自己的物理内存页面，并将页表中相应地页表项标记为<strong>可写</strong>。</p>
</li>
</ul>
<p>写时复制父子进程修改某一个页面前后变化如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221212114349322.png" alt="image-20221212114349322"></p>
<p>在fork还没实现<code>copy on write</code>之前。Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了<code>vfork</code>系统调用。而现在<code>vfork</code>已经不常用了。</p>
<ul>
<li>vfork和fork的区别/联系：vfork函数和 fork函数一样都是在已有的进程中创建一个新的进程，但它们创建的子进程是有区别的。</li>
<li>父子进程的执行顺序<ul>
<li>fork： 父子进程的执行次序不确定。</li>
<li>vfork：保证子进程先运行，在它调用 <code>exec/exit</code>之后，父进程才执行</li>
</ul>
</li>
<li>是否拷贝父进程的地址空间<ul>
<li>fork： 子进程写时拷贝父进程的地址空间，子进程是父进程的一个复制</li>
<li>vfork：子进程共享父进程的地址空间</li>
</ul>
</li>
<li>调用vfork函数，是为了执行exec函数；如果子进程没有调用 exec/exit，程序会出错</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	pid = vfork();	<span class="comment">// 创建进程</span></span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;vfork&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;  </span><br><span class="line">		sleep(<span class="number">3</span>); <span class="comment">// 延时 3 秒</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am son\n&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		_exit(<span class="number">0</span>); <span class="comment">// 退出子进程，必须</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; <span class="comment">// 父进程</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;i am father\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：已经让子进程延时 3 s，结果还是子进程运行结束后，父进程才执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">	pid = vfork();</span><br><span class="line">	<span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;vfork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">0</span> == pid)&#123;</span><br><span class="line">		a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;son: a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">		_exit(<span class="number">0</span>);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>)&#123; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;father: a = %d, b = %d\n&quot;</span>, a, b);	</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：子进程先执行，修改完a，b的值后，由于父子进程共享内存空间，因此会影响父进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">son: a = 100, b = 200</span><br><span class="line">father: a = 100, b = 200</span><br></pre></td></tr></table></figure>
<p>如果采用<code>fork</code>的话，会有写时复制，此时父子进程的变量无关：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        a = <span class="number">100</span>;</span><br><span class="line">        b = <span class="number">200</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;son: a = %d, b = %d.\n&quot;</span>, a, b);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father: a = %d, b = %d.\n&quot;</span>, a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./vfork </span></span><br><span class="line">father: a = 10, b = 20.</span><br><span class="line">son: a = 100, b = 200.</span><br></pre></td></tr></table></figure>
<h3 id="6-3-wait和waitpid"><a href="#6-3-wait和waitpid" class="headerlink" title="6.3 wait和waitpid"></a>6.3 wait和waitpid</h3><p><code>wait</code>系统调用：等待进程改变状态。</p>
<p>进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。</p>
<p><code>wait</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *status)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>status</code>用来保存子进程退出时的一些状态。如果不在意子进程的退出状态，可以设定<code>status</code>为<code>NULL</code>。如果参数<code>status</code>的值不是<code>NULL</code>，<code>wait</code>就会把子进程退出时的状态取出，并存入其中。可以使用下列的宏函数来处理<code>status</code>：<ul>
<li><code>WIFEXITED(status)</code>：用来指出子进程是否为正常退出，如果是，则会返回一个非零值。</li>
<li><code>WEXITSTATUS(status)</code>：当<code>WIFEXITED</code>返回非零值时，可以用这个宏来提取子进程的返回值。</li>
</ul>
</li>
<li>如果执行成功，<code>wait</code>会返回子进程的<code>PID</code>；如果没有子进程，则<code>wait</code>返回<code>-1</code>。</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pc, pr;</span><br><span class="line">    pc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;error ocurred!\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pc == <span class="number">0</span>) &#123; <span class="comment">/* 如果是子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process with pid of %d\n&quot;</span>, getpid());</span><br><span class="line">        sleep (<span class="number">10</span>); <span class="comment">/* 睡眠10秒钟 */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123; <span class="comment">/* 如果是父进程 */</span></span><br><span class="line">        pr = wait (<span class="literal">NULL</span>); <span class="comment">/* 在这里阻塞，收尸 */</span></span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;I catched a child process with pid of %d\n&quot;</span>, pr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is child process with pid of <span class="number">298</span></span><br><span class="line">等待<span class="number">10</span>秒</span><br><span class="line">I catched a child process with pid of <span class="number">298</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例2</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">pid_t</span> pc, pr;</span><br><span class="line">    pc = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;error ocurred!\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pc == <span class="number">0</span>) &#123; <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;This is child process with pid of %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">exit</span> ( <span class="number">3</span> ); <span class="comment">/* 子进程返回3 */</span></span><br><span class="line">    <span class="keyword">if</span>(pc &gt; <span class="number">0</span>) &#123; <span class="comment">/* 父进程 */</span></span><br><span class="line">        pr = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status)) &#123; <span class="comment">/* 如果WIFEXITED返回非零值 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the child process %d exit normally\n&quot;</span>, pr);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the return code is %d\n&quot;</span>, WEXITSTATUS(status ));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 如果WIFEXITED返回零 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the child process %d exit abnormally\n&quot;</span>, pr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This is child process with pid of <span class="number">308</span></span><br><span class="line">the child process <span class="number">308</span> <span class="built_in">exit</span> normally</span><br><span class="line">the <span class="keyword">return</span> code is <span class="number">3</span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>waitpid</code>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面两者等价：</span></span><br><span class="line">wait(&amp;status);</span><br><span class="line">waitpid(<span class="number">-1</span>, &amp;status, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>从本质上讲，<code>waitpid</code>和<code>wait</code>的作用是完全相同的，但<code>waitpid</code>多出了两个可以由用户控制的参数<code>pid</code>和<code>options</code>：</p>
<ul>
<li><code>pid</code>：当<code>pid</code>取不同的值时，在这里有不同的意义：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>取值</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&gt; 0</code></td>
<td>只等待进程<code>ID</code>等于<code>pid</code>的子进程</td>
</tr>
<tr>
<td><code>=-1</code></td>
<td>等待任何一个子进程退出，此时<code>waitpid</code>和<code>wait</code>的作用一模一样</td>
</tr>
<tr>
<td><code>= 0</code></td>
<td>等待同一个进程组<code>process group id</code>中的任何子进程</td>
</tr>
<tr>
<td><code>&lt;-1</code></td>
<td>等待一个指定进程组中的任何子进程，这个进程组的<code>ID</code>等于<code>pid</code>的绝对值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>options</code>：是一个位图，可以通过<strong>按位或</strong>来设置，如果不设置则置为0即可。最常用的选项是<code>WNOHANG</code>，作用是即使没有子进程退出，它也会立即返回，此时<code>waitpid</code>不同于<code>wait</code>，它变成了非阻塞的函数。</li>
<li><code>waitpid</code>的返回值有如下几种情况：<ul>
<li>当正常返回时，<code>waitpid</code>返回子进程的<code>PID</code>。</li>
<li>如果设置了<code>WNOHANG</code>，而<code>waitpid</code>没有发现已经退出的子进程，则返回<code>0</code>。</li>
<li>如果<code>waitpid</code>出错，则返回<code>-1</code>。例如参数<code>pid</code>指示的子进程不存在，或此进程存在，但不是调用进程的子进程。</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT 30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">pid_t</span> pid_child;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                    mark = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(mark)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d]:%d is a primer.\n&quot;</span>, getpid(), i);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环201次，给201个子进程收尸</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pid_child = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process with pid: %d.\n&quot;</span>, pid_child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：省略了没有打印质数的输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[32444]:30000023 is a primer.</span><br><span class="line">Child process with pid: 32444.</span><br><span class="line">[32462]:30000041 is a primer.</span><br><span class="line">Child process with pid: 32462.</span><br><span class="line">[32458]:30000037 is a primer.</span><br><span class="line">Child process with pid: 32458.</span><br><span class="line">[32422]:30000001 is a primer.</span><br><span class="line">Child process with pid: 32422.</span><br><span class="line">[32470]:30000049 is a primer.</span><br><span class="line">Child process with pid: 32470.</span><br><span class="line">[32480]:30000059 is a primer.</span><br><span class="line">Child process with pid: 32480.</span><br><span class="line">[32530]:30000109 is a primer.</span><br><span class="line">Child process with pid: 32530.</span><br><span class="line">[32504]:30000083 is a primer.</span><br><span class="line">Child process with pid: 32504.</span><br><span class="line">[32614]:30000193 is a primer.</span><br><span class="line">Child process with pid: 32614.</span><br><span class="line">[32590]:30000169 is a primer.</span><br><span class="line">Child process with pid: 32590.</span><br><span class="line">[32492]:30000071 is a primer.</span><br><span class="line">Child process with pid: 32492.</span><br><span class="line">[32620]:30000199 is a primer.</span><br><span class="line">Child process with pid: 32620.</span><br><span class="line">[32500]:30000079 is a primer.</span><br><span class="line">Child process with pid: 32500.</span><br><span class="line">[32588]:30000167 is a primer.</span><br><span class="line">Child process with pid: 32588.</span><br><span class="line">[32554]:30000133 is a primer.</span><br><span class="line">Child process with pid: 32554.</span><br><span class="line">[32558]:30000137 is a primer.</span><br><span class="line">Child process with pid: 32558.</span><br><span class="line">[32584]:30000163 is a primer.</span><br><span class="line">Child process with pid: 32584.</span><br><span class="line">[32570]:30000149 is a primer.</span><br><span class="line">Child process with pid: 32570.</span><br></pre></td></tr></table></figure>
<h3 id="6-4-exec函数族"><a href="#6-4-exec函数族" class="headerlink" title="6.4 exec函数族"></a>6.4 exec函数族</h3><h4 id="6-4-1-简介"><a href="#6-4-1-简介" class="headerlink" title="6.4.1 简介"></a>6.4.1 简介</h4><p>fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，<strong>并用它来取代原调用进程的数据段、代码段和堆栈段</strong>，在执行完之后，原调用进程的内容<strong>除了进程号外，其他全部被新程序的内容替换了</strong>。这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。</p>
<p>当进程调用一种exec函数时，该进程执行的程序<strong>完全替换为新程序</strong>，而新程序则从其main函数开始执行。因为调用exec并不创建新进程，所以前后的进程ID并未改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。</p>
<blockquote>
<p>为什么需要<code>exec</code>函数</p>
</blockquote>
<ul>
<li>fork子进程是为了执行新程序（fork创建了子进程后，子进程和父进程同时被OS调度执行，因此子进程可以单独的执行一个程序，这个程序宏观上将会和父进程程序同时进行）；</li>
<li>可以直接在子进程的<code>if</code>中写入新程序的代码（参见<code>6.2.1节</code>的做法）。这样可以，但是不够灵活，因为我们只能把子进程程序的源代码贴过来执行（必须知道源代码，而且源代码太长了也不好控制），譬如说我们希望子进程来执行<code>ls -la</code>命令就不行了（没有源代码，只有编译好的可执行程序<code>/usr/bin/ls</code>）；</li>
<li>使用exec族运行新的可执行程序（exec族函数可以直接把一个编译好的可执行程序直接加载运行）；</li>
<li>我们有了exec族函数后，典型的父子进程程序是这样的：子进程需要运行的程序被单独编写、单独编译连接成一个可执行程序（叫<code>hello</code>），（项目是一个多进程项目）主程序为父进程，fork创建了子进程后在子进程中<code>exec</code>来执行hello，达到父子进程分别做不同程序同时（宏观上）运行的效果；</li>
</ul>
<h4 id="6-4-2-使用"><a href="#6-4-2-使用" class="headerlink" title="6.4.2 使用"></a>6.4.2 使用</h4><p>有多种不同的exec函数可供使用，它们常常被统称为exec函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="comment">// 从PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直达</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="comment">// 从PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="comment">// 从PATH里找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上函数成功执行时不返回，失败时返回<code>-1</code>并设值<code>errno</code></li>
<li><p>后缀含义</p>
<ul>
<li><code>l</code>：以<code>list</code>形式传入参数</li>
<li><code>v</code>：以<code>vector</code>形式传入参数</li>
<li><code>p</code>：在<code>$PATH</code>中查找可执行程序</li>
<li><code>e</code>：在<code>envp[]</code>中查找可执行程序</li>
</ul>
</li>
<li><p><code>execl</code>和<code>execv</code>：这两个函数是最基本的exec，都可以用来执行一个程序，区别是传参的格式不同：</p>
<ul>
<li>execl是把参数列表（本质上是多个字符串，必须以<code>NULL</code>结尾）依次排列而成</li>
<li>execv是把参数列表事先放入一个字符串数组中（必须以<code>NULL</code>结尾），再把这个字符串数组传给execv函数，类似于<code>char **argv</code></li>
<li><code>path</code>：完整的文件目录路径</li>
</ul>
</li>
<li><p><code>execlp</code>和<code>execvp</code>：这两个函数在上面2个基础上加了<code>p</code></p>
<ul>
<li><code>file</code>：文件名，系统就会自动从环境变量<code>$PATH</code>所指出的路径中进行查找该文件。如果包含<code>/</code>，则视为路径名<code>path</code>。</li>
</ul>
</li>
<li><p><code>execle</code>和<code>execvpe</code>：这两个函数较基本exec来说加了<code>e</code></p>
<ul>
<li><code>envp</code>：自己指定的环境变量。在<code>envp[]</code>中指定当前进程所使用的环境变量替换掉该进程继承的环境变量<code>$PATH</code>。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215120515986.png" alt="image-20221215120515986"></p>
<blockquote>
<p>代码示例——环境变量</p>
</blockquote>
<ul>
<li><code>myexec.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="comment">// 参数</span></span><br><span class="line">        <span class="keyword">char</span> * <span class="keyword">const</span> param[] = &#123;<span class="string">&quot;myHello&quot;</span>, <span class="string">&quot;-a&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="comment">// 自己设置的环境变量</span></span><br><span class="line">        <span class="keyword">char</span> * <span class="keyword">const</span> envp[] = &#123;<span class="string">&quot;AA=aaa&quot;</span>, <span class="string">&quot;BB=bbb&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="comment">// 执行同目录下的hello</span></span><br><span class="line">        execvpe(<span class="string">&quot;./hello&quot;</span>, param, envp);</span><br><span class="line">        perror(<span class="string">&quot;execvpe()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>hello.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **env)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; argv[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; env[i] != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;env[%d]: %s\n&quot;</span>, i, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译链接为<code>hello</code></p>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./myexec </span></span><br><span class="line">argc = 3</span><br><span class="line">argv[0]: myHello</span><br><span class="line">argv[1]: -a</span><br><span class="line">argv[2]: -l</span><br><span class="line">env[0]: AA=aaa</span><br><span class="line">env[1]: BB=bbb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——程序名称</p>
</blockquote>
<p>补充：<code>argv</code>第一个参数为程序名称，后面的参数为命令行参数。程序名称可以任意设置，一般来说，如果一个源码文件的名称为<code>XXX.c</code>，则编译生成的可执行程序为<code>XXX</code>，此时运行，程序名称（<code>argv[0]</code>）就是<code>XXX</code></p>
<p>使用gcc默认编译链接得到的可执行文件名称为<code>a.out</code>，此时程序名称（<code>argv[0]</code>）就是<code>a.out</code>。</p>
<hr>
<p>使用<code>exec</code>族函数实现<code>date +%s</code>命令打印时间戳的功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># date +%s</span></span><br><span class="line">1670902531</span><br></pre></td></tr></table></figure>
<p>这里的参数依次是<code>程序名</code>，<code>+%s</code>，<code>NULL</code>，注意第一个参数代表的是程序的名称，可以任意设置，类似于<code>argv[0]</code>，之后的参数才是重要的<strong>命令行参数</strong>。</p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">	<span class="comment">// 注意这里的程序名称给了一个myDate</span></span><br><span class="line">    execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;myDate&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用<code>execv</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">char</span> * <span class="keyword">const</span> param[] = &#123;<span class="string">&quot;myDate&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    execp(<span class="string">&quot;/bin/date&quot;</span>, param);</span><br><span class="line">    perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./ex </span><br><span class="line">Begin!</span><br><span class="line">1670902607</span><br></pre></td></tr></table></figure>
<p>为什么不打印<code>End!</code>：执行<code>exec</code>后，原进程映像被替换成新的进程映像（即<code>/bin/date</code>程序），从main函数开始执行<code>/bin/date</code>的代码了。</p>
<p><strong>我不再是我，我已成新的我</strong>。</p>
<hr>
<p>让子进程睡眠1000s：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]Begin!\n&quot;</span>, getpid());</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的程序名称给了一个httpd</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sleep&quot;</span>, <span class="string">&quot;httpd&quot;</span>, <span class="string">&quot;1000&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]End!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后查看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps axf</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221215122921045.png" alt="image-20221215122921045"></p>
<p>这里子进程运行时执行的是<code>sleep</code>程序，但是程序名称却被设置成了<code>httpd</code>，这实际上是一种低级的木马程序隐藏的办法。</p>
<blockquote>
<p>代码示例——刷新缓冲区的重要性</p>
</blockquote>
<p>在讲<code>fork</code>的时候提到过，在<code>fork</code>之前，最好将强制刷新所有已经打开的流，这里的<code>exec</code>也不例外，例如使用上面的程序，将结果重定向到<code>/tmp/out</code>中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./ex &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># cat /tmp/out</span></span><br><span class="line">1670902720</span><br></pre></td></tr></table></figure>
<p>发现<code>Begin!</code>不见了，原因就在于重定向是全缓冲，当执行完<code>puts(&quot;Begin!&quot;)</code>后，该进程的缓冲区内容为<code>Begin!\n</code>，并不刷新到文件中，此时执行<code>exec</code>后，进程映像被替换成新的进程映像（即<code>/bin/date</code>程序），除了原进程的进程号外，其他全部（包括缓冲区）被新程序的内容替换了，之后新程序的缓冲区内容为时间戳，程序结束后，强制刷新到文件。</p>
<p>因此需要在执行<code>exec</code>之前强制刷新所有打开的流：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]# ./ex &gt; /tmp/out</span><br><span class="line">[root@HongyiZeng proc]# cat /tmp/out</span><br><span class="line">Begin!</span><br><span class="line">1670903209</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——fork，exec和wait结合使用</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]Begin!\n&quot;</span>, getpid());</span><br><span class="line">    fflush(<span class="literal">NULL</span>);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/date&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;+%s&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待子进程结束，收尸</span></span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]End!\n&quot;</span>, getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">17301</span>]Begin! <span class="comment">// 父进程打印</span></span><br><span class="line"><span class="number">1670903917</span> <span class="comment">// 子进程打印，子进程和父进程完全是不同的程序了</span></span><br><span class="line">[<span class="number">17301</span>]End! <span class="comment">// 父进程打印</span></span><br></pre></td></tr></table></figure>
<p>至此，UNIX系统进程控制原语更加完善。用fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止。这些是我们需要的基本的进程控制原语。</p>
<h3 id="6-5-shell外部命令实现"><a href="#6-5-shell外部命令实现" class="headerlink" title="6.5 shell外部命令实现"></a>6.5 shell外部命令实现</h3><p>shell外部命令：在磁盘上能够看得到的命令。此外都是内部命令。</p>
<p>之前在终端上执行<code>primer1.c</code>时，出现下列情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./primer1</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># 30000037 is a primer.</span></span><br><span class="line">30000001 is a primer.</span><br><span class="line">30000041 is a primer.</span><br><span class="line">30000023 is a primer.</span><br><span class="line">30000079 is a primer.</span><br><span class="line">30000133 is a primer.</span><br><span class="line">30000137 is a primer.</span><br><span class="line">30000049 is a primer.</span><br><span class="line">30000109 is a primer.</span><br><span class="line">30000083 is a primer.</span><br><span class="line">30000071 is a primer.</span><br><span class="line">30000059 is a primer.</span><br><span class="line">30000193 is a primer.</span><br><span class="line">30000169 is a primer.</span><br><span class="line">30000167 is a primer.</span><br><span class="line">30000199 is a primer.</span><br><span class="line">30000163 is a primer.</span><br><span class="line">30000149 is a primer.</span><br></pre></td></tr></table></figure>
<p>发现终端先于子程序打印。</p>
<p>原因：在终端上执行<code>primer1</code>时，父进程（终端，即shell）fork了一个子进程，然后exec了<code>primer1</code>程序，并且<code>wait</code>到<code>primer1</code>退出，所以当<code>primer1</code>退出时，就立刻出现了终端，此时<code>primer1</code>fork的子进程还在运行打印结果，所以出现了终端先于子进程的结果出现。</p>
<p>一般的，当shell执行某个程序时，首先<code>fork</code>一个子进程，然后该子进程<code>exec</code>那个执行程序，shell此时<code>wait</code>该程序退出<code>exit</code>。</p>
<blockquote>
<p>shell伪代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 死循环，shell不断接收用户命令</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 终端提示符</span></span><br><span class="line">        prompt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取命令</span></span><br><span class="line">        getline();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析命令</span></span><br><span class="line">        parse();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(内部命令) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 外部命令</span></span><br><span class="line">            fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 异常处理...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123; <span class="comment">// 子进程</span></span><br><span class="line">                exec(); <span class="comment">// 将子进程替换为待执行程序</span></span><br><span class="line">                <span class="comment">// 异常处理...</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; <span class="comment">// shell父进程</span></span><br><span class="line">                wait(<span class="literal">NULL</span>); <span class="comment">// 等待子进程结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glob.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分隔符：空 制表符 换行符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DELIMS <span class="meta-string">&quot; \t\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">glob_t</span> globres;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prompt</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mysh-0.1$ &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(<span class="keyword">char</span> *line, struct cmd_st *res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tok;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        tok = strsep(&amp;line, DELIMS);</span><br><span class="line">        <span class="comment">// 分割完毕</span></span><br><span class="line">        <span class="keyword">if</span>(tok == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(tok[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">       	<span class="comment">// 选项解释</span></span><br><span class="line">        <span class="comment">// NOCHECK：不对pattern进行解析，直接返回pattern（这里是tok），相当于存储了命令行参数tok在glob_t中</span></span><br><span class="line">        <span class="comment">// APPEND：以追加形式将tok存放在glob_t中，第一次时不追加，因为globres尚未初始化，需要系统来自己分配内存，因此乘上i（乘法优先于按位或）</span></span><br><span class="line">        glob(tok, GLOB_NOCHECK|GLOB_APPEND*i, <span class="literal">NULL</span>, &amp;res-&gt;globres);</span><br><span class="line">        <span class="comment">// 置为1，使得追加永远成立</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// getline的参数要初始化</span></span><br><span class="line">    <span class="keyword">char</span> *linebuf = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> linebuf_size = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmd_st</span> <span class="title">cmd</span>;</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        prompt();</span><br><span class="line">        <span class="comment">// getline函数参见2.10节</span></span><br><span class="line">        <span class="keyword">if</span>(getline(&amp;linebuf, &amp;linebuf_size, <span class="built_in">stdin</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析命令</span></span><br><span class="line">        parse(linebuf, &amp;cmd);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>) &#123; <span class="comment">// 内部命令，暂不做实现</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 外部命令</span></span><br><span class="line">            pid = fork();</span><br><span class="line">            <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">                execvp(cmd.globres.gl_pathv[<span class="number">0</span>], cmd.globres.gl_pathv);</span><br><span class="line">                perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wait(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分析：</p>
<p><code>strsep</code>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strsep</span><span class="params">(<span class="keyword">char</span> **stringp, <span class="keyword">const</span> <span class="keyword">char</span> *delim)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>strsep</code>实现字符串的分割，把<code>stringp</code>里面出现的<code>delim</code>替换成<code>&#39;\0&#39;</code>，后将 <code>stringp</code> 更新指向到<code>&#39;\0&#39;</code>符号的下一个字符地址，函数的返回值指向原来的 <code>stringp</code> 位置。直到分割完毕返回<code>NULL</code>。</p>
<hr>
<p>代码执行流程分析：</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./mysh </span></span><br><span class="line">mysh-0.1$ ls -l</span><br><span class="line">total 144</span><br><span class="line">-rwxr-xr-x 1 root root 8600 Dec 13 11:46 ex</span><br><span class="line">-rw-r--r-- 1 root root  213 Dec 13 11:46 ex.c</span><br><span class="line">-rwxr-xr-x 1 root root 8552 Dec 13 12:52 exv</span><br><span class="line">-rw-r--r-- 1 root root  232 Dec 13 12:52 exv.c</span><br><span class="line">-rwxr-xr-x 1 root root 8752 Dec 13 11:58 few</span><br><span class="line">-rw-r--r-- 1 root root  361 Dec 13 11:58 few.c</span><br><span class="line">-rwxr-xr-x 1 root root 8656 Dec 12 10:19 fork1</span><br><span class="line">-rw-r--r-- 1 root root  402 Dec 12 10:19 fork1.c</span><br><span class="line">-rwxr-xr-x 1 root root 8912 Dec 14 12:06 mysh</span><br><span class="line">-rw-r--r-- 1 root root  953 Dec 14 12:06 mysh.c</span><br><span class="line">-rwxr-xr-x 1 root root 8448 Dec 12 10:28 primer0</span><br><span class="line">-rw-r--r-- 1 root root  313 Dec 12 10:28 primer0.c</span><br><span class="line">-rwxr-xr-x 1 root root 8552 Dec 14 11:05 primer1</span><br><span class="line">-rw-r--r-- 1 root root  437 Dec 14 11:04 primer1.c</span><br><span class="line">-rwxr-xr-x 1 root root 8656 Dec 13 10:02 primer2</span><br><span class="line">-rw-r--r-- 1 root root  652 Dec 13 10:02 primer2.c</span><br><span class="line">-rwxr-xr-x 1 root root 8672 Dec 12 11:56 vfork</span><br><span class="line">-rw-r--r-- 1 root root  372 Dec 12 11:56 vfork.c</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>getline</code>得到字符串<code>ls -l</code></p>
</li>
<li><p><code>parse</code>解析该字符串，将分割结果存在<code>globres</code>中，其中：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">globres.gl_pathv[<span class="number">0</span>] = <span class="string">&quot;ls&quot;</span>;</span><br><span class="line">globres.gl_pathv[<span class="number">1</span>] = <span class="string">&quot;-l&quot;</span>;</span><br><span class="line">globres.gl_pathv[<span class="number">2</span>] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>子进程<code>execvp(cmd.globres.gl_pathv[0], cmd.globres.gl_pathv);</code></p>
<ul>
<li>第一个参数为要执行的可执行程序的名字，为<code>ls</code>，从环境变量<code>PATH</code>中找到<code>/usr/bin/</code>路径下的<code>ls</code>程序</li>
<li>第二个参数为指针数组，为<code>ls</code>和<code>-l</code>，第一个为程序名，任意，第二个和后面的为命令的参数，重要，这里的参数为<code>-l</code></li>
</ul>
</li>
</ul>
<h3 id="6-6-用户权限和组权限"><a href="#6-6-用户权限和组权限" class="headerlink" title="6.6 用户权限和组权限"></a>6.6 用户权限和组权限</h3><p>在UNIX系统中，特权（如能改变当前日期的表示法）以及访问控制（如能否读、写一个特定文件），是基于用户ID和组ID的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。与此类似，当程序需要降低其特权或阻止对某些资源的访问时，也需要更换用户ID或组ID，新ID不具有相应特权或访问这些资源的能力。</p>
<h4 id="6-6-1-UID和GID"><a href="#6-6-1-UID和GID" class="headerlink" title="6.6.1 UID和GID"></a>6.6.1 UID和GID</h4><p>Linux采用一个32位的整数记录和区分不同的用户。这个区分不同用户的数字被称为User ID，简称<code>UID</code>。Linux系统中用户分为3类，即普通用户、根用户root、系统用户。</p>
<ul>
<li>普通用户是指所有使用Linux系统的真实用户，通常<code>UID&gt;500</code>；</li>
<li>根用户即root用户，ID为0。</li>
<li>系统用户是指系统运行必须有的用户，但并不是真实使用者。UID为<code>1~499</code>。对于系统用户，可能还不能理解是什么。比如，在Redhat或CentOS下运行网站服务时，需要使用系统用户Apache来运行httpd，而运行MySQL数据库服务时，需要使用系统用户mysql来运行mysqld进程。这就是系统用户。</li>
</ul>
<p>可以使用<code>id [用户名]</code>命令查看uid，gid和组名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># id</span></span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># id lighthouse</span></span><br><span class="line">uid=1000(lighthouse) gid=1000(lighthouse) groups=1000(lighthouse),991(docker)</span><br></pre></td></tr></table></figure>
<p>要确认自己所属的用户组，可以使用<code>groups</code>命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># groups</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure>
<p>系统用来记录用户名、密码的最重要两个文件是<code>/etc/passwd</code>和<code>/etc/shadow</code>，详见<code>4.1.2节</code>。</p>
<h4 id="6-6-2-SUID和SGID"><a href="#6-6-2-SUID和SGID" class="headerlink" title="6.6.2 SUID和SGID"></a>6.6.2 SUID和SGID</h4><p>内核为每个进程维护的三个UID值（和三个GID值，是对应关系，略），这三个UID分别是：</p>
<ul>
<li><code>RUID</code>：(Real UID，实际用户ID)，我们当前以哪个用户登录，我们运行程序产生进程的RUID就是这个用户的UID。</li>
<li><code>EUID</code>：(Effective UID，有效用户ID)，指当前进程实际以哪个UID来运行。一般情况下EUID等于RUID；但如果进程对应的可执行文件具有SUID权限（也就是rws的<code>s</code>），那么<strong>进程的EUID是可执行文件的所有者的UID</strong>，鉴权看的就是这个ID。</li>
<li><code>SUID</code>：(Saved Set-user-ID，保存的设置用户ID)，EUID的一个副本，与SUID权限有关。</li>
</ul>
<blockquote>
<p>特殊权限</p>
</blockquote>
<p>文件和目录权限除了普通权限<code>rwx</code>外，还有三个特殊权限：</p>
<ul>
<li><code>SUID</code>：在属主的<code>x</code>位以<code>s</code>标识，全称<code>SetUID</code></li>
<li><code>SGID</code>：在属组的<code>x</code>位以<code>s</code>标识，全称<code>SetGID</code></li>
<li><code>STIKCY</code>：黏着位，详见<code>4.2.4.③节</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ll /usr/bin/passwd </span></span><br><span class="line">-rwsr-xr-x 1 root root 27856 Apr  1  2020 /usr/bin/passwd</span><br></pre></td></tr></table></figure>
<p>上面第4位的<code>s</code>就是特殊权限<code>SUID</code>。</p>
<p>下面将由五个问题来说明什么是<code>SUID</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.普通用户可不可以修改密码？</span></span><br><span class="line">可以，修改自己的密码</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2./etc/shadow文件的作用？</span></span><br><span class="line">存储用户密码的文件</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3./etc/shadow文件的权限？</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /etc/shadow</span></span><br><span class="line">----------1 root root 16404 Apr  8 11:41 /etc/shadow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.普通用户，是否可以修改/etc/shadow文件？</span></span><br><span class="line">不可以，/etc/shadow文件，对于普通用户没有任何权限，所以不能读取，也不能写入内容。</span><br><span class="line"></span><br><span class="line">普通用户的信息保存在 /etc/passwd文件中，与用户的密码在 /etc/shadow 文件中，也就是说，普通用户在更改自己密码时，修改了 /etc/shadow 文件中的加密密码，但是文件权限显示，普通用户对这两个文件都没有写权限。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.那么普通用户，为什么可以修改密码？</span></span><br><span class="line">1）因为使用了passwd这个命令</span><br><span class="line">2）passwd命令在属主权限位上，原本是x权限，变成了s权限</span><br><span class="line">3）s权限在属主权限位，又叫做SetUID权限，SUID</span><br><span class="line">4）作用：普通用户在使用有SUID权限的文件或命令时，会以该文件的属主身份去执行该命令，换句话说，普通用户在执行passwd命令时，切换成了passwd属主即root的身份去执行passwd命令。</span><br></pre></td></tr></table></figure>
<p>从进程控制的角度来说，当非root用户执行passwd这个可执行文件的时候，<strong>产生的进程的EUID</strong>，就是<strong>root用户的UID</strong>。换言之，这种情况下，产生的进程，实际以root用户的ID来运行二进制文件。</p>
<blockquote>
<p>相关命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s 文件名/目录名 <span class="comment"># 对文件给予用户s权限，则此用户暂时获得这个文件的属主权限</span></span><br><span class="line">chmod g+s 文件名/目录名 <span class="comment"># 对文件给予用户组s权限，则此用户暂时获得这个文件的属组权限</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>从进程控制的角度看命令的执行</p>
</blockquote>
<ul>
<li>UNIX系统产生的第一个进程是<code>init</code>进程，其三个uid为root的uid，即<code>res</code>为<code>0 0 0</code>，以<code>init(0 0 0)</code>表示；</li>
<li><code>init</code>进程fork和exec产生<code>getty(0 0 0)</code>进程，此进程等待用户输入用户名；</li>
<li>用户回车输入了用户名后，<code>getty</code>进程存储用户名，exec产生<code>login(0 0 0)</code>进程，等待用户输入密码并验证口令（查找用户名和密码<code>/etc/passwd</code>）；<ul>
<li>如果验证成功，<code>login</code>进程则fork并exec产生<code>shell(r e s)</code>进程，即终端，此时的<code>res</code>就是登录用户的UID，即固定了用户产生的进程的身份；</li>
<li>如果验证失败，则返回继续验证；</li>
</ul>
</li>
<li>当用户执行某个命令时，<code>shell</code>进程fork并exec该命令对应的程序，例如<code>ls(r e s)</code>，并wait该程序，<code>ls</code>进程退出时，又返回到<code>shell(r e s)</code>终端（因为shell是一个死循环，参见<code>6.5节</code>）；</li>
<li>可以看出，整个UNIX的世界就是由fork，exec，wait和exit的进程控制原语搭建起来的</li>
</ul>
<p>整个过程的图示如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121452262.png" alt="image-20221216121452262"></p>
<p>又如执行<code>passwd</code>命令时图如下，变化的只有<code>EUID</code>和<code>SUID</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216121641906.png" alt="image-20221216121641906"></p>
<h4 id="6-6-3-相关系统调用"><a href="#6-6-3-相关系统调用" class="headerlink" title="6.6.3 相关系统调用"></a>6.6.3 相关系统调用</h4><p>下面的系统调用是特殊权限实现所需的函数。</p>
<ul>
<li>获取：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的ruid</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回当前进程的euid</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前进程的euid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前进程的egid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>交换：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换当前进程的ruid和euid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>实现任意用户用<code>0号用户</code>（即root）的身份查看<code>/etc/shadow</code>文件的功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mysu 0 cat /etc/shadow</span><br></pre></td></tr></table></figure>
<p>exec参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat -&gt; main的argv[<span class="number">2</span>]：所需要执行的程序;</span><br><span class="line">cat /etc/shadow -&gt; main的argv[<span class="number">2</span>]之后：程序名cat 命令行参数/etc/shadow</span><br></pre></td></tr></table></figure>
<p>代码实现：（以普通用户<code>lighthouse</code>编译链接）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        setuid(atoi(argv[<span class="number">1</span>])); <span class="comment">// 将字符串转成int</span></span><br><span class="line">        execvp(argv[<span class="number">2</span>], argv + <span class="number">2</span>);</span><br><span class="line">        perror(<span class="string">&quot;execvp()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看该文件的属性：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ll mysu</span><br><span class="line">-rwxr-xr-x 1 lighthouse lighthouse 8800 Dec 16 12:32 mysu</span><br></pre></td></tr></table></figure>
<p>直接运行，权限不够：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ./mysu 0 cat /etc/shadow</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br></pre></td></tr></table></figure>
<p>切换到<code>root</code>用户，将<code>mysu</code>属主更改为<code>root</code>，并给予该文件<code>s</code>权限：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># chown root mysu</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># chmod u+s mysu</span></span><br><span class="line">[root@HongyiZeng proc]<span class="comment"># ll mysu</span></span><br><span class="line">-rwsr-xr-x 1 root lighthouse 8800 Dec 16 12:32 mysu</span><br></pre></td></tr></table></figure>
<p>然后切换到<code>lighthouse</code>，再执行即可：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221216141111786.png" alt="image-20221216141111786"></p>
<h3 id="6-7-解释器文件"><a href="#6-7-解释器文件" class="headerlink" title="6.7 解释器文件"></a>6.7 解释器文件</h3><p>解释器文件也叫脚本文件。脚本文件包括：shell脚本，python脚本等；</p>
<p>脚本文件的后缀可自定义，一般来说shell脚本的后缀名为<code>.sh</code>，python脚本的后缀名为<code>.py</code>。</p>
<p>解释器文件的执行过程：当在linux系统的shell命令行上执行一个可执行文件时，系统会<code>fork</code>一个子进程，在子进程中内核会首先将该文件当做是二进制机器文件来执行，但是内核发现该文件不是机器文件（看到第一行为<code>#!</code>）后就会返回一个错误信息，收到错误信息后进程会将该文件看做是一个解释器文件，然后扫描该文件的第一行，获取解释器程序（本质上就是可执行文件）的名字，然后执行<code>exec</code>该解释器，并将该解释器文件当做解释器的一个参数，然后开始由解释器程序扫描整个解释器文件，执行每条语句（如果指定解释器为<code>shell</code>，会跳过第一条语句，因为<code>#</code>是注释）。如果其中某条命令执行失败了也不会影响后续命令的执行。</p>
<p>解释器文件的格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!pathname [optional-argument]</span></span><br><span class="line"></span><br><span class="line">内容...</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pathname</code>：一般是绝对路径（它不会使用<code>$PATH</code>做路径搜索），对这个文件识别是由内核做为<code>exec</code>系统调用处理的。</li>
<li><code>optional-argument</code>：相当于提供给<code>exec</code>的参数</li>
</ul>
<p>内核exec执行的并不是解释器文件，而是第一行pathname指定的文件。一定要将解释器文件（本质是一个文本文件，以    <code>#!</code>开头）和解释器（由pathname指定）区分开。</p>
<blockquote>
<p>代码示例1</p>
</blockquote>
<p>以普通用户创建脚本<code>test.sh</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>
<p>这个文件没有执行权限，需要添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[lighthouse@HongyiZeng proc]$ ll test.sh</span><br><span class="line">-rw-r--r-- 1 lighthouse lighthouse 46 Dec 16 15:09 test.sh</span><br><span class="line">[lighthouse@HongyiZeng proc]$ chmod u+x test.sh </span><br><span class="line">[lighthouse@HongyiZeng proc]$ ./test.sh</span><br><span class="line">ex    exv.c  fork1    hello.c   mysh    mysu.c     primer1    primer2.c  test.sh</span><br><span class="line">ex.c  few    fork1.c  myexec    mysh.c  primer0    primer1.c  sleep      vfork</span><br><span class="line">exv   few.c  hello    myexec.c  mysu    primer0.c  primer2    sleep.c    vfork.c</span><br><span class="line">lighthouse</span><br><span class="line">cat: /etc/shadow: Permission denied</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">14857 pts/3    00:00:00 bash</span><br><span class="line">19087 pts/3    00:00:00 test.sh</span><br><span class="line">19091 pts/3    00:00:00 ps</span><br></pre></td></tr></table></figure>
<p>shell执行<code>./test.sh</code>时，fork了一个子进程，该进程看到该文件为解释器文件，于是读取第一行，得到解释器程序的PATH，并<code>exec</code>该解释器程序（<code>/bin/bash</code>），然后重新执行这个解释器文件。</p>
<p>可以看出<code>bash</code>跳过了第一句，因为<code>#</code>在bash程序中被看成了注释，<code>cat</code>命令没有权限，但后面的<code>ps</code>命令仍然继续执行。</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/cat</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>
<p>执行该脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./test.sh </span></span><br><span class="line"><span class="comment">#!/bin/cat</span></span><br><span class="line">ls</span><br><span class="line">whoami</span><br><span class="line">cat /etc/shadow</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>
<p>发现这次是打印了该脚本文件的所有内容。过程同上，只是这次子进程<code>exec</code>的程序为<code>/bin/cat</code>程序。</p>
<blockquote>
<p>代码示例3——自定义解释器程序</p>
</blockquote>
<p>解释器程序（或解释器）本质上就是一个可执行文件。</p>
<ul>
<li><code>echoarg.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s \n&quot;</span>, i, argv[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译为<code>echoarg</code>，并存放在<code>/usr/local/linux_c/proc/</code>下。</p>
<ul>
<li><code>echoarg.sh</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/<span class="built_in">local</span>/linux_c/proc/echoarg foo1 foo2 foo3</span></span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng proc]<span class="comment"># ./echoarg.sh</span></span><br><span class="line">argv[0]: /usr/<span class="built_in">local</span>/linux_c/proc/echoarg</span><br><span class="line">argv[1]: foo1 foo2 foo3</span><br><span class="line">argv[2]: ./echoarg.sh</span><br></pre></td></tr></table></figure>
<h3 id="6-8-system函数"><a href="#6-8-system函数" class="headerlink" title="6.8 system函数"></a>6.8 system函数</h3><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>
<p>作用：该函数实际上调用的是<code>/bin/sh -c command</code>，实质上是对<code>fork+exec+wait</code>的封装。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    system(<span class="string">&quot;date +%s &gt; /tmp/out&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序实质上执行的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh -c date +%s &gt; /tmp/out</span><br></pre></td></tr></table></figure>
<p>在执行该命令的时候，system函数代码类似于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fork()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 实际上在 exec /bin/sh程序</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;date +%s &gt; /tmp/out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        perror(<span class="string">&quot;execl()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-9-守护进程"><a href="#6-9-守护进程" class="headerlink" title="6.9 守护进程"></a>6.9 守护进程</h3><p>暂略</p>
<h3 id="6-10-系统日志"><a href="#6-10-系统日志" class="headerlink" title="6.10 系统日志"></a>6.10 系统日志</h3><p>暂略</p>
<h2 id="7-信号"><a href="#7-信号" class="headerlink" title="7 信号"></a>7 信号</h2><p>该节对应第十章——信号。</p>
<h3 id="7-1-前置概念"><a href="#7-1-前置概念" class="headerlink" title="7.1 前置概念"></a>7.1 前置概念</h3><blockquote>
<p>并发和并行</p>
</blockquote>
<ul>
<li>并发（<code>concurrency</code>）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。</li>
<li>并行（<code>parallelism</code>）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217114203844.png" alt="image-20221217114203844"></p>
<blockquote>
<p>同步和异步</p>
</blockquote>
<ul>
<li>进程同步：按照一定的顺序协同进行（有序进行），而不是同时。即一组进程为了协调其推进速度，在某些地方需要相互等待或者唤醒，这种进程间的相互制约就被称作是进程同步。这种合作现象在操作系统和并发式编程中属于经常性事件。<ul>
<li>例如，在主线程中，开启另一个线程。另一个线程去读取文件，主线程等待该线程读取完毕，那么主线程与该线程就有了同步关系。</li>
</ul>
</li>
<li>进程异步：当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
</ul>
<p>异步事件的处理：查询法（发生频率高）和通知法（发生频率低）</p>
<h3 id="7-1-信号的概念"><a href="#7-1-信号的概念" class="headerlink" title="7.1 信号的概念"></a>7.1 信号的概念</h3><p>信号是软件层面的中断，是进程之间相互传递消息的一种方法，信号全称为软中断信号，也有人称作软中断，从它的命名可以看出，它的实质和使用很像中断。</p>
<p>进程之间可以通过调用<code>kill</code>库函数发送软中断信号。Linux内核也可能给进程发送信号，通知进程发生了某个事件（例如内存越界）。</p>
<p>每个信号都有一个名字。这些名字都以3个字符<code>SIG</code>开头。头文件<code>&lt;signal.h&gt;</code>中，信号名都被定义为正整数常量（信号编号）。</p>
<p>通过命令<code>kill -l</code>可以列出所有可用信号：</p>
<p>信号值 1 ~ 31  为不可靠信号（标准信号），信号会丢失；信号值 34 ~ 64 为可靠信号（实时信号），信号不会丢失。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># kill -l</span></span><br><span class="line"> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP</span><br><span class="line"> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1</span><br><span class="line">11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM</span><br><span class="line">16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP</span><br><span class="line">21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR</span><br><span class="line">31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1  64) SIGRTMAX</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>信号名</th>
<th>信号值</th>
<th>发出信号的原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIGHUP</td>
<td>1</td>
<td>终端挂起或者控制进程终止</td>
</tr>
<tr>
<td><strong>SIGINT</strong></td>
<td><strong>2</strong></td>
<td><strong>键盘中断Ctrl+c</strong></td>
</tr>
<tr>
<td>SIGQUIT</td>
<td>3</td>
<td>键盘的退出键被按下</td>
</tr>
<tr>
<td>SIGILL</td>
<td>4</td>
<td>非法指令</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>6</td>
<td>由abort(3)发出的退出指令</td>
</tr>
<tr>
<td>SIGFPE</td>
<td>8</td>
<td>浮点异常</td>
</tr>
<tr>
<td><strong>SIGKILL</strong></td>
<td><strong>9</strong></td>
<td><strong>采用kill  -9 进程编号 强制杀死程序。</strong></td>
</tr>
<tr>
<td><strong>SIGSEGV</strong></td>
<td><strong>11</strong></td>
<td><strong>无效的内存引用</strong></td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>13</td>
<td>管道破裂:写一个没有读端口的管道</td>
</tr>
<tr>
<td>SIGALRM</td>
<td>14</td>
<td>由alarm(2)发出的信号</td>
</tr>
<tr>
<td><strong>SIGTERM</strong></td>
<td><strong>15</strong></td>
<td><strong>采用“kill  进程编号”或“killall 程序名”通知程序。</strong></td>
</tr>
<tr>
<td>SIGUSR1</td>
<td>30,10,16</td>
<td>用户自定义信号1</td>
</tr>
<tr>
<td>SIGUSR2</td>
<td>31,12,17</td>
<td>用户自定义信号2</td>
</tr>
<tr>
<td><strong>SIGCHLD</strong></td>
<td><strong>20,17,18</strong></td>
<td><strong>子进程结束信号</strong></td>
</tr>
<tr>
<td>SIGCONT</td>
<td>19,18,25</td>
<td>进程继续（曾被停止的进程）</td>
</tr>
<tr>
<td>SIGSTOP</td>
<td>17,19,23</td>
<td>终止进程</td>
</tr>
<tr>
<td>SIGTSTP</td>
<td>18,20,24</td>
<td>控制终端（tty）上按下停止键</td>
</tr>
<tr>
<td>SIGTTIN</td>
<td>21,21,26</td>
<td>后台进程企图从控制终端读</td>
</tr>
<tr>
<td>SIGTTOU</td>
<td>22,22,27</td>
<td>后台进程企图从控制终端写</td>
</tr>
</tbody>
</table>
</div>
<p><strong>信号是异步事件的经典实例</strong>。产生信号的事件对进程而言是<strong>随机</strong>出现的。进程不能简单地测试一个变量（如 errno）来判断是否发生了一个信号，而是必须告诉内核”在此信号发生时，请执行下列操作”。</p>
<p>当某个信号出现时，可以告诉内核按下列三种方式之一进行处理，称之为信号的处理或与信号相关的工作：</p>
<ul>
<li>忽略此信号</li>
<li>捕捉信号</li>
<li>执行系统默认工作</li>
</ul>
<p>下图列出了所有信号的名字，说明了哪些系统支持此信号和信号对应的系统默认工作。可以看出C标准库支持的信号是最少的。大部分的信号的默认操作是终止进程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217131449456.png" alt="image-20221217131449456"></p>
<p><code>core</code>是在进程当前工作目录的core文件中复制了该进程的内存映像，core文件记录了进程终止时的错误报告，大多数UNIX系统调试程序都使用core文件检查进程终止时的状态。</p>
<h3 id="7-3-signal函数"><a href="#7-3-signal函数" class="headerlink" title="7.3 signal函数"></a>7.3 signal函数</h3><blockquote>
<p>补充：<code>typedef</code>的用法总结</p>
</blockquote>
<ul>
<li>定义一种类型的别名：基本用法</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* PCHAR;</span><br><span class="line">PCHAR pa, pb;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;POINT;</span><br><span class="line"></span><br><span class="line">POINT p1, p2;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义与平台无关的类型：当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。标准库就广泛使用了这个技巧，比如<code>size_t</code>，<code>pid_t</code>。另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏更稳健。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> REAL; <span class="comment">// 平台1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> REAL; <span class="comment">// 平台2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>为<strong>复杂声明</strong>定义一个新的简单的别名。</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于给返回值为int，形参为int的这一类函数起了一个别名FUNC</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="title">FUNC</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了返回值为int，形参为int的函数f</span></span><br><span class="line">FUNC f;  <span class="comment">// 相当于：int f(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = f(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给返回值为int*，形参为int的函数（指针函数：返回指针的函数，本质是函数；函数指针：指向函数的指针，本质是指针）起了一个别名FUNCP，本质是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">int</span>* <span class="title">FUNCP</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">FUNCP p; <span class="comment">// 相当于 int* p(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* a = p(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给指向返回值为int*，形参为int的指针函数的指针其一个别名FUNCP，本质是一个指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* (*FUNCP)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">FUNCP p; <span class="comment">// 相当于 int* (*p)(int);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* a = (*p)(<span class="number">1</span>); <span class="comment">// 使用</span></span><br></pre></td></tr></table></figure>
<p>又如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始声明，该声明本质上是一个函数指针</span></span><br><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> signum, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最外层是一个函数指针，形式为：</span></span><br><span class="line"><span class="keyword">void</span> (*)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层是一个返回指针，形参为int，函数指针的函数signal</span></span><br><span class="line"><span class="comment">// 注意到signal的形参也有一个函数指针void (*func)(int)，这两个函数指针指向的都是同一种函数，即返回值为void，形参为int</span></span><br><span class="line"><span class="keyword">void</span> (*)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此给公共部分起一个别名sighandler_t，sighandler_t本质上是一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化后的形式：</span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> func)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>UNIX系统信号机制最简单的接口是<code>signal</code>函数，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CONFORMING TO C89, C99, POSIX.1-2001.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意typedef没有定义在头文件中，因此必须要写出，否则按照下面的形式给出signal函数，APUE上的就是这种形式：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (* signal(<span class="keyword">int</span> signum, <span class="keyword">void</span> (*func)(<span class="keyword">int</span>)))(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>signum</code>参数是上图中的信号名，常用宏名来表示，例如<code>SIGINT</code></li>
<li><code>func</code>参数是下面的一种：<ul>
<li><code>SIG_IGN</code>：向内核忽略此信号，除了<code>SIGKILL</code>和<code>SIGSTOP</code></li>
<li><code>SIG_DFL</code>：执行系统默认动作</li>
<li>当接到此信号后要调用的函数的地址：在信号发生时，调用该函数；称这种处理为捕捉该信号，称此函数为<strong>信号处理程序</strong>或信号捕捉函数</li>
</ul>
</li>
<li>作用：<code>signal</code>函数为<code>signum</code>所代表的信号设置一个信号处理程序<code>func</code>，换句话说，<code>signal</code>就是一个注册函数。</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 忽略SIGINT信号</span></span><br><span class="line">    signal(SIGINT, SIG_IGN);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每1s向终端打印1个*</span></span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号<code>SIGINT</code>产生的方式就是快捷键<code>CTRL + C</code>。</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 向终端打印!</span></span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 函数名就是函数的地址</span></span><br><span class="line">    signal(SIGINT, int_handler);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每按1次<code>CTRL + C</code>，终端就打印1个<code>!</code></p>
<blockquote>
<p>代码示例3——阻塞和非阻塞</p>
</blockquote>
<p>上述程序，如果一直按着<code>CTRL + C</code>，程序会小于10S就会结束。</p>
<p>原因在于：<strong>信号会打断阻塞的系统调用</strong>。这里的阻塞是<code>write</code>和<code>sleep</code>函数。</p>
<p>分析：进程运行到<code>sleep(1)</code>的时候，由运行态进入阻塞态，此时如果有信号到来，例如<code>SIGINT</code>，会打断阻塞（唤醒进程），让进程进入就绪态，获得时间片进入运行态，此时进程还没阻塞到1s，就进入了就绪态，即信号会打断阻塞的系统调用。</p>
<ul>
<li>阻塞：为了完成一个功能，发起一个调用，<strong>如果不具备条件的话则一直等待,直到具备条件则完成</strong></li>
<li>非阻塞：为了完成一个功能，发起一个调用，<strong>具备条件直接输出,不具备条件直接报错返回</strong></li>
</ul>
<p>此前学习过的所有IO函数，都是阻塞IO，即阻塞的系统调用。</p>
<p>以<code>open</code>为例，进程调用<code>open</code>时，进入阻塞态，等待IO设备打开，如果IO设备打开时间过长，此时有一个信号到来，就会打断<code>open</code>调用，使其打开设备失败。</p>
<p>因此，在设备打开失败的时候，需要判断是因为<code>open</code>自身引发的错误，还是因为信号打断而没有打开，对于前者，以以往的方式处理错误，而对于后者应该尝试再次打开设备，而不是报错后退出程序。</p>
<p>注意：对于所有的阻塞系统调用，都要处理是因为自身调用出现的真错，还是因为信号中断导致的假错。</p>
<p>在宏中，有一个名为<code>EINTR</code>的<code>errno</code>，即为被信号中断而引发的错误。当进程在执行一个阻塞的系统调用时捕捉到一个信号，则被中断不再执行该系统调用，该系统调用返回错误，<code>errno</code>就会被设置为<code>EINTR</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221217170001027.png" alt="image-20221217170001027"></p>
<p>以前面的一个程序为例，修改后的代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE 1024 <span class="comment">// 缓冲区大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) &#123;</span><br><span class="line">                <span class="comment">// 不是信号导致的错误，就退出</span></span><br><span class="line">                perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((dfd = open(argv[<span class="number">2</span>], O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0600</span>)) &lt; <span class="number">0</span>) &#123;			</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) &#123;</span><br><span class="line">                close(sfd);</span><br><span class="line">                perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(dfd &lt; <span class="number">0</span>)</span><br><span class="line">    	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">&quot;write()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(dfd);</span><br><span class="line">    close(sfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-4-不可靠的信号"><a href="#7-4-不可靠的信号" class="headerlink" title="7.4 不可靠的信号"></a>7.4 不可靠的信号</h3><p>信号处理程序由内核调用，在执行该程序时，内核为该处理程序布置现场，此时如果又来一个信号，内核再次调用信号处理程序，可能会冲掉第一次调用布置的现场。</p>
<h3 id="7-5-可重入函数"><a href="#7-5-可重入函数" class="headerlink" title="7.5 可重入函数"></a>7.5 可重入函数</h3><p>可重入函数（即可以被中断的函数）可以被一个以上的任务调用，而不担心数据破坏。可重入函数在任何时候都可以被中断，而一段时间之后又可以恢复运行，而相应的数据不会破坏或者丢失。</p>
<p>不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。I/O代码通常不是可重入的，因为它们依赖于像磁盘这样共享的，单独的资源。</p>
<p>所有的系统调用都是可重入的，一部分库函数也是可重入的，例如<code>memcpy</code>。</p>
<blockquote>
<p>函数不可重入的条件</p>
</blockquote>
<ul>
<li>函数内使用了静态的数据。</li>
<li>函数内使用了malloc或者free函数</li>
<li>函数内调用了标准的I/O函数</li>
</ul>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *ex1, <span class="keyword">int</span> *ex2)</span> </span>&#123;</span><br><span class="line">    temp = *ex1; <span class="comment">//(1)</span></span><br><span class="line">    *ex1 = *ex2;</span><br><span class="line">    *ex2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：该函数中的全局变量temp是的函数变成了一个不可重入的函数，因为在多任务系统中，假如在任务1中调用swap函数，而程序执行到（1）处时被中断，进而执行其它的任务2，而刚好任务2也调用了swap函数，则temp里存的值则会被任务2改变。从而回到任务1被中断处继续执行的时候，temp里存的值已经不再是原来存的temp值了，进而产生了错误。</p>
<blockquote>
<p>使得函数可重入的方法</p>
</blockquote>
<ul>
<li>不要使用全局变量，防止别的代码覆盖这些变量的值。</li>
<li>调用这类函数之前先关掉中断，调用完之后马上打开中断。防止函数执行期间被中断进入别的任务执行。</li>
<li>使用信号量（互斥条件）</li>
</ul>
<h3 id="7-6-信号的响应过程"><a href="#7-6-信号的响应过程" class="headerlink" title="7.6 信号的响应过程"></a>7.6 信号的响应过程</h3><blockquote>
<p>补充：用户态和内核态的切换</p>
</blockquote>
<p>Linux系统中的内核态本质是内核，是一种特殊的软件程序，用于控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。0-4G范围的虚拟空间地址都可以操作，尤其是对3-4G范围的高位虚拟空间地址必须由内核态去操作。</p>
<p>用户态提供应用程序运行的空间，为了使应用程序访问到内核管理的资源，例如CPU，内存，I/O等。用户态只能受限的访问内存，且不允许访问外设(硬盘、网卡等);内核态CPU可以访问内存所有数据，包括外设，且可以将自己从一个程序切换到另一个程序。</p>
<p>用户态切换到内核态的三种方式：</p>
<ul>
<li>发生系统调用时：（主动）这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现的，即<strong>软中断</strong>。</li>
<li>产生异常时：（被动）当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。</li>
<li>外设产生中断时：（被动）当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。  </li>
</ul>
<blockquote>
<p>信号在内核中的表示</p>
</blockquote>
<ul>
<li><strong>信号递达</strong>（<code>Delivery</code>）：实际执行信号处理的动作。</li>
<li><strong>信号未决</strong>（<code>Pending</code>）：信号从产生到递达之间的状态。 </li>
<li><strong>信号阻塞</strong>（<code>Block</code>）：被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。</li>
</ul>
<p>有如下结论：</p>
<ul>
<li>信号从收到到响应有一个不可避免的延迟。</li>
<li>标准信号的响应没有严格顺序。</li>
</ul>
<p>内核为<strong>每个进程</strong>都维护了两个位图，一般为32位，两个位图进行<strong>与操作</strong>：</p>
<ul>
<li><strong>信号屏蔽字 mask</strong> ：用来屏蔽信号，mask初始值一般全部都是1，表示不屏蔽全部信号</li>
<li><strong>位图 pending</strong>： 用来记录当前进程收到哪些信号，一般初始值全部都是0，表示没有收到信号，未决信号集。</li>
</ul>
<blockquote>
<p>信号响应过程</p>
</blockquote>
<p>以打印<code>*</code>和<code>!</code>的程序为例。</p>
<ul>
<li>在没有其他中断的情况下，当时间片耗尽时，进程被计时器中断，使得该进程被切换至内核态，在内核态中运行计时器中断的处理函数（<code>handler</code>），进程调度算法就发生在计时器中断的处理函数中（在这个处理函数中，系统会根据任务调度算法，从就绪队列里选择下一个运行的进程）。该进程等待调度。<ul>
<li>进程当前的状态和信息被压入到内核栈中，其中包括程序的返回地址。</li>
<li>进程被内核调度时，进程从内核态切换至用户态，从内核栈中保存的返回地址继续运行</li>
<li>进程从内核态切换至用户态时（也只有在这个时刻），会执行<code>mask &amp; pending</code>，确认自己是否收到信号。对于这种情况，按位与结果为每位都为0，表示进程没有收到信号。</li>
</ul>
</li>
<li>当进程在某一刻收到<code>SIGINT</code>信号，此时将<code>pending</code>第2位置为1，表示收到<code>SIGINT</code>信号，但此时进程并不会被该信号中断（即响应该信号）。当时间片耗尽，一直到被调度，进程从内核态切换至用户态，执行<code>mask &amp; pending</code>时，发现只有第2位结果为1，此时进程才响应该信号。因此说，信号从收到到响应有一个不可避免的延迟。<ul>
<li>响应信号时的操作：内核将该位的<code>mask</code>和<code>pending</code>都置为0，并将程序返回地址修改为<code>int_handler</code>即信号响应程序的地址，此时在用户态执行信号响应程序。换句话说，<strong>信号的收到的时刻是随机的，而信号的响应总是在从内核态切换到用户态时进行的</strong>；</li>
<li>信号响应程序执行完毕后，从用户态切换至内核态，内核将返回地址修改为程序的返回地址，并将<code>mask</code>的该位置为1；</li>
<li>再次被调度到时，切换至用户态，执行<code>mask &amp; pending</code>，发现均为0，说明刚才的信号已经被响应了，则继续向下执行程序；</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何忽略一个信号？</p>
</blockquote>
<p>注意到<code>func</code>（信号处理程序）可以为宏<code>SIG_ING</code>，实质上是将<code>mask</code>的位置为0，表示屏蔽该信号。</p>
<p>注意：我们能做的是不响应信号，即不对信号做处理（屏蔽），而不是阻止信号产生和到来。信号的随时都会到来，将<code>pending</code>置为1。</p>
<blockquote>
<p><strong>标准信号</strong>为什么不可靠，或者说标准信号为什么会丢失？</p>
</blockquote>
<p>信号响应时，位图为<code>(m0 p0)</code>，此时又来<strong>多个</strong>信号，则<code>p</code>被反复置为1，即结果总是为<code>(m0 p1)</code>；信号响应完毕时，将<code>m</code>置为1，此时为<code>(m1 p1)</code>；返回用户态时，发现该位仍然为1，说明又来<strong>一个</strong>信号（注意不是多个），则继续响应…所以多个信号到来时，只有最后一个信号能够被响应，前面的信号都被丢失了。</p>
<blockquote>
<p>总结：mask和pending的变化情况</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mask pending</span><br><span class="line"><span class="number">1</span>		<span class="number">0</span>	<span class="comment">// 初始化</span></span><br><span class="line"><span class="number">1</span>		<span class="number">1</span>	<span class="comment">// 信号到来</span></span><br><span class="line"><span class="number">0</span>		<span class="number">0</span>	<span class="comment">// 信号响应 内核态-&gt;用户态时</span></span><br><span class="line"><span class="number">1</span>		<span class="number">0</span>	<span class="comment">// 信号响应完毕</span></span><br></pre></td></tr></table></figure>
<h3 id="7-7-常用函数Ⅰ"><a href="#7-7-常用函数Ⅰ" class="headerlink" title="7.7 常用函数Ⅰ"></a>7.7 常用函数Ⅰ</h3><h4 id="7-7-1-kill"><a href="#7-7-1-kill" class="headerlink" title="7.7.1 kill"></a>7.7.1 kill</h4><p>kill函数用于向进程发送信号，注意不是杀死进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>pid：向哪个进程发送信号<ul>
<li><code>pid &gt; 0</code>：发送信号给指定进程</li>
<li><code>pid = 0</code>：发送信号给跟调用kill函数的那个进程处于同一进程组的进程，相当于组内广播。</li>
<li><code>pid &lt; -1</code>：发送信号给该绝对值所对应的进程组的所有组员，相当于组内广播。</li>
<li><code>pid = -1</code>：发送信号给所有权限发送的所有进程。</li>
</ul>
</li>
<li><code>sig</code>：待发送的信号<ul>
<li><code>sig = 0</code>：没有信号发送，但会返回-1并设置<code>errno</code>，用来检测某个进程id或进程组id是否存在。注意返回-1时并不能表明该id不存在，而是要根据<code>errno</code>来判断，详见下面的返回值。</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回0</li>
<li>失败返回-1，并设值errno<ul>
<li><code>EINVAL</code>：无效的信号<code>sig</code></li>
<li><code>EPERM</code>：调用进程没有权限给<code>pid</code>的进程发送信号</li>
<li><code>ESRCH</code>：进程或进程组不存在</li>
</ul>
</li>
</ul>
<h4 id="7-7-2-raise"><a href="#7-7-2-raise" class="headerlink" title="7.7.2 raise"></a>7.7.2 raise</h4><p>raise函数用于向调用进程发送信号，即自己给自己发送信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">kill(getpid(), sig);</span><br></pre></td></tr></table></figure>
<h4 id="7-7-3-alarm"><a href="#7-7-3-alarm" class="headerlink" title="7.7.3 alarm"></a>7.7.3 alarm</h4><p>alarm函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>;</span><br></pre></td></tr></table></figure>
<p>作用：设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送<code>SIGALRM</code>信号（定时器超时）。进程收到该信号，默认动作终止。每个进程都有且只有唯一的一个定时器，所以多个alarm函数共同调用时，后面设置的时钟会覆盖掉前面的时钟。</p>
<p>返回值：返回0或剩余的秒数，无失败。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./alarm </span></span><br><span class="line">Alarm clock</span><br></pre></td></tr></table></figure>
<h4 id="7-7-4-pause"><a href="#7-7-4-pause" class="headerlink" title="7.7.4 pause"></a>7.7.4 pause</h4><p>pause函数用于等待信号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pause</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>进程调用pause函数时，会造成进程主动挂起（处于阻塞状态，并主动放弃CPU），并且等待信号将其唤醒。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        pause();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用到<code>pause()</code>时，该进程挂起，此时不再占用CPU，5s过后，接收到<code>SIGALRM</code>信号，采取默认动作终止。</p>
<p>信号的处理方式有三种：</p>
<ul>
<li>默认动作</li>
<li>忽略处理</li>
<li>捕捉</li>
</ul>
<p>进程收到一个信号后，会先处理响应信号，再唤醒pause函数。于是有下面几种情况：</p>
<ul>
<li>如果信号的默认处理动作是终止进程，则进程将被终止，也就是说一收到信号进程就终止了，pause函数根本就没有机会返回，例如上面的例子</li>
<li>如果信号的默认处理动作是忽略，则进程将直接忽略该信号，相当于没收到这个信号，进程继续处于挂起状态，pause函数不返回</li>
<li>如果信号的处理动作是捕捉，则进程调用完信号处理函数之后，pause返回-1，errno设置为EINTR，表示“被信号中断”</li>
<li>pause收到的信号不能被屏蔽，如果被屏蔽，那么pause就不能被唤醒</li>
</ul>
<p><code>sleep = alarm + pause</code></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：让程序等待5s</p>
<ul>
<li>使用<code>time</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> end;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    end = time(<span class="literal">NULL</span>) + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(time(<span class="literal">NULL</span>) &lt;= end) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./pause &gt; /tmp/out</span></span><br><span class="line">real    0m5.142s</span><br><span class="line">user    0m4.950s</span><br><span class="line">sys     0m0.005s</span><br><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./pause &gt; /tmp/out</span></span><br><span class="line">real    0m5.181s</span><br><span class="line">user    0m5.045s</span><br><span class="line">sys     0m0.008s</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>alarm</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环跳出的标志</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loop = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    loop = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 对信号SIGALRM注册信号处理函数</span></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">while</span>(loop)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, count);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./5sec_sig &gt; /tmp/out</span></span><br><span class="line">real    0m5.029s</span><br><span class="line">user    0m4.821s</span><br><span class="line">sys     0m0.012s</span><br><span class="line">[root@HongyiZeng signal]<span class="comment"># time ./5sec_sig &gt; /tmp/out</span></span><br><span class="line">real    0m5.017s</span><br><span class="line">user    0m4.864s</span><br><span class="line">sys     0m0.006s</span><br></pre></td></tr></table></figure>
<hr>
<p>当对上述程序进行编译优化时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc 5sec_sig.c -O1</span><br></pre></td></tr></table></figure>
<p>再次执行，发现程序一直在运行。</p>
<p>原因：编译优化时，gcc看到下面的循环体中没有出现<code>loop</code>，所以gcc认为loop是不变的，将loop的值存储在高速缓存（CPU的寄存器）中，每次读取loop的值时，从高速缓存中读取，而不是在loop实际存放的内存地址中读取，因此一直在此处循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(loop)</span><br><span class="line">    count++;</span><br></pre></td></tr></table></figure>
<p>解决方法：用<code>volatile</code>修饰<code>loop</code>，此时编译器认为该变量易变，每次读取时从实际内存地址中读取：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>从汇编的角度来看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S 5sec_sig.c -O1</span><br></pre></td></tr></table></figure>
<p>未加易变修饰前：（省略不重要的代码）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB24:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        movl    $5, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    alarm</span><br><span class="line">        movl    $alrm_handler, %esi</span><br><span class="line">        movl    $14, %edi</span><br><span class="line">        call    signal</span><br><span class="line">        cmpl    $0, loop(%rip) # 判断loop</span><br><span class="line">        jne     .L5 # 跳转到循环体中</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf</span><br><span class="line">        movl    $0, %edi</span><br><span class="line">        call    exit</span><br><span class="line">.L5:</span><br><span class="line">        jmp     .L5 # 死循环</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></table></figure>
<p>加上易变修饰后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line">.LFB24:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        subq    $8, %rsp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        movl    $5, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    alarm</span><br><span class="line">        movl    $alrm_handler, %esi</span><br><span class="line">        movl    $14, %edi</span><br><span class="line">        call    signal</span><br><span class="line">        movl    loop(%rip), %eax</span><br><span class="line">        testl   %eax, %eax # 判断loop</span><br><span class="line">        je      .L5 # 跳入循环</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">.L4:</span><br><span class="line">        addq    $1, %rsi</span><br><span class="line">        movl    loop(%rip), %eax</span><br><span class="line">        testl   %eax, %eax</span><br><span class="line">        jne     .L4</span><br><span class="line">        jmp     .L3</span><br><span class="line">.L5:</span><br><span class="line">        movl    $0, %esi</span><br><span class="line">.L3:</span><br><span class="line">        movl    $.LC0, %edi</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        call    printf</span><br><span class="line">        movl    $0, %edi</span><br><span class="line">        call    exit</span><br><span class="line">        .cfi_endproc</span><br></pre></td></tr></table></figure>
<h4 id="7-7-5-漏桶"><a href="#7-7-5-漏桶" class="headerlink" title="7.7.5 漏桶"></a>7.7.5 漏桶</h4><p><code>leaky bucket</code>也叫漏桶，就是将请求先放到一个桶中进行排队，然后按一个固定的速率来处理请求，即所谓的漏出。</p>
<p>桶具有一定的容量，即最大容量的请求数，当排队请求的数量超过桶的容量时，再进来的请求就直接过滤掉，不再被处理。换句话说就是请求先在桶中排队，系统或服务只以一个恒定的速度从桶中将请求取出进行处理。如果排队的请求数量超过桶能够容纳的最大数量，即桶装满了，则直接丢弃。</p>
<p>漏桶算法(Leaky Bucket)是网络世界中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。</p>
<p>需求：实现一个复制文本到标准输出的程序，要求10字符10字符的复制，且不能让CPU空转。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPS     10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFSIZE CPS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> loop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alrm_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">    loop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sfd, dfd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">int</span> len, ret, pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGALRM, alrm_handler);</span><br><span class="line">    alarm(<span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>((sfd = open(argv[<span class="number">1</span>], O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR) &#123;</span><br><span class="line">                perror(<span class="string">&quot;open()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(sfd &lt; <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!loop)</span><br><span class="line">            <span class="comment">// 防止CPU空转</span></span><br><span class="line">            pause();</span><br><span class="line">        loop = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = read(sfd, buf, BUFSIZE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            perror(<span class="string">&quot;read()&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((ret = write(dfd, buf + pos, len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                perror(<span class="string">&quot;write()&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pos += ret;</span><br><span class="line">            len -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-7-6-令牌桶"><a href="#7-7-6-令牌桶" class="headerlink" title="7.7.6 令牌桶"></a>7.7.6 令牌桶</h4><p>系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。 当桶满时，新添加的令牌被丢弃或拒绝。</p>
<p>令牌桶算法是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。令牌桶算法基本可以用下面的几个概念来描述：</p>
<ul>
<li>令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。</li>
<li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li>
<li>当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。</li>
<li>如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li>
</ul>
<blockquote>
<p>令牌桶和漏桶的区别</p>
</blockquote>
<p>主要区别在于漏桶算法能够强行限制数据的传输速率，而令牌桶算法在能够限制数据的平均传输速率外，还允许某种程度的突发传输。在令牌桶算法中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它<strong>适合于具有突发特性的流量</strong>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>暂略</p>
<h3 id="7-8-信号集"><a href="#7-8-信号集" class="headerlink" title="7.8 信号集"></a>7.8 信号集</h3><p>信号集是一个能够表示多个信号的数据类型。</p>
<p><code>POSIX.1</code>定义数据类型<code>sigset_t</code>来表示一个信号集（本质为整型），并且定义了下列5个处理信号集的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 置空一个信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充满一个信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个信号加入信号集</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个信号从信号集删除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述函数成功返回0，失败返回-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查一个信号集中是否有这个信号，存在返回1，不存在返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> signum)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-9-sigprocmask函数"><a href="#7-9-sigprocmask函数" class="headerlink" title="7.9 sigprocmask函数"></a>7.9 sigprocmask函数</h3><p><code>sigprocmask</code>函数可以检测或更改，或同时进行检测和更改进程的信号屏蔽字（阻塞信号集）。注：对信号来说，阻塞和屏蔽是一个意思。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>how</code>：用于指定信号修改的方式，有三种选择：<ul>
<li><code>SIG_BLOCK</code>：该进程新的信号屏蔽字是其当前信号屏蔽字和set指向信号集的并集。即set包含了希望阻塞的附加信号；</li>
<li><code>SIG_UNBLOCK</code>：该进程新的信号屏蔽字是其当前信号屏蔽字和set所指向信号集补集的交集。即set包含了希望解除阻塞的信号；</li>
<li><code>SIG_SETMASK</code>：该进程新的信号屏蔽是set指向的值；</li>
</ul>
</li>
<li><code>*set</code>：和how结合使用</li>
<li><code>*oldset</code>：进程的当前信号屏蔽字通过<code>oset</code>返回</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    <span class="comment">// 置空一个信号集set</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 将SIGINT加入到信号集set中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置信号屏蔽字</span></span><br><span class="line">        <span class="comment">// 将SIGINT屏蔽</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 打印5个*后，将SIGINT解除屏蔽</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./block</span></span><br><span class="line">*****</span><br><span class="line">*^C****</span><br><span class="line">!*^C^C^C^C*^C^C^C^C^C^C^C^C^C***</span><br><span class="line">!***^C^C^C**</span><br><span class="line">!****^\Quit</span><br></pre></td></tr></table></figure>
<p>解析：第三行发送SIGINT信号时，SIGINT的屏蔽字位为0，pending位置为1，当打印完成后，解除屏蔽，进程响应该信号，在第四行打印了<code>!</code>；第四行多次发送SIGINT信号，也只是对pending位反复置为1，在第五行也只打印一次<code>!</code>；</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将SIGINT阻塞，并将原始的屏蔽字存储在oset中，且原始屏蔽字都是1</span></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将屏蔽字设置为oset信号集的值，即全1，没有屏蔽</span></span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能和代码示例1相同。</p>
<blockquote>
<p>代码示例3</p>
</blockquote>
<p>为了保证在进入模块和退出模块时进程的信号屏蔽字是一致，需要修改代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 将进程起始的信号屏蔽字保存在saveset中</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 退出时，还原信号屏蔽字</span></span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-10-sigpending函数"><a href="#7-10-sigpending函数" class="headerlink" title="7.10 sigpending函数"></a>7.10 sigpending函数</h3><p>略</p>
<h3 id="7-11-常用函数Ⅱ"><a href="#7-11-常用函数Ⅱ" class="headerlink" title="7.11 常用函数Ⅱ"></a>7.11 常用函数Ⅱ</h3><h4 id="7-11-1-sigsuspend函数"><a href="#7-11-1-sigsuspend函数" class="headerlink" title="7.11.1 sigsuspend函数"></a>7.11.1 sigsuspend函数</h4><p>该函数通过将进程的屏蔽字替换为由参数<code>sigmask</code>给出的信号集，然后将进程挂起（阻塞）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigsuspend</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *mask)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能描述上和<code>pause</code>函数相同，即在等待信号的时候让进程挂起。</p>
<p>区别：sigsuspend实际是将sigprocmask和pause结合起来原子操作。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：先打印一排<code>*</code>，等待信号，然后打印一排<code>*</code>，以此类推。</p>
<ul>
<li>使用<code>pause</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        sigprocmask(SIG_SETMASK, &amp;oset, <span class="literal">NULL</span>);</span><br><span class="line">        pause();</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng signal]<span class="comment"># ./susp </span></span><br><span class="line">*****</span><br><span class="line">^C!*****</span><br><span class="line">^C!**^C^C^C***</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
<p>第二行开始处：当内层循环执行完毕后，到pause处挂起，此时SIGINT到来，首先处理信号，然后唤醒进程，继续执行内层循环打印。</p>
<p>注意第四行，当在内层循环执行时，有多个SIGINT信号到来，由于被屏蔽，所以不打印叹号，打印星号结束后，代码第十九行解除屏蔽（注意，代码第十九行和第二十行之间也会存在多个中断），响应信号（第五行的第一个叹号），再执行到代码第二十行处时，此时没有信号到来，所以一直挂起。</p>
<ul>
<li>使用<code>sigsuspend</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">int_handler</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	write(<span class="number">1</span>, <span class="string">&quot;!&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>, oset, saveset;</span><br><span class="line">	signal(SIGINT, int_handler);</span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="comment">// 保存初始屏蔽字</span></span><br><span class="line">    sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, &amp;saveset);</span><br><span class="line">    <span class="comment">// 设置阻塞</span></span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, &amp;oset);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            write(<span class="number">1</span>, <span class="string">&quot;*&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">        write(<span class="number">1</span>, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 挂起</span></span><br><span class="line">        sigsuspend(&amp;oset);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        sigset_t tmpset;</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;oset, &amp;tmpset);</span></span><br><span class="line"><span class="comment">        pause();</span></span><br><span class="line"><span class="comment">        sigprocmask(SIG_SETMASK, &amp;tmpset, NULL);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK, &amp;saveset, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-11-2-sigaction函数"><a href="#7-11-2-sigaction函数" class="headerlink" title="7.11.2 sigaction函数"></a>7.11.2 sigaction函数</h4><p>sigaction函数是升级版的signal函数。</p>
<p>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>signum参数指出要捕获的信号类型</li>
<li>act参数指定新的信号处理方式</li>
<li>oldact参数输出先前信号的处理方式（如果不为NULL的话）</li>
</ul>
<p><code>struct sigaction</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sa_handler</code>：此参数和signal()的参数handler相同，代表新的信号处理函数</li>
<li><code>sa_mask</code>：用来设置在处理该信号时暂时将 sa_mask 指定的信号集屏蔽</li>
<li><code>sa_flags</code>：用来设置信号处理的其他相关操作，下列的数值可用。 <ul>
<li><code>SA_RESETHAND</code>：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</li>
<li><code>SA_RESTART</code>：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</li>
<li><code>SA_NODEFER</code> ：一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</li>
<li><code>SA_SIGINFO</code>：调用信号处理器程序时携带了额外参数，其中提供了关于信号的深入信息</li>
</ul>
</li>
<li><code>sa_sigaction</code>：这是一个三个参数的<code>sa_handler</code>函数版本。如果设置了<code>SA_SIGINFO</code>标志位，则会使用<code>sa_sigaction</code>处理函数，否则使用<code>sa_handler</code>处理函数。其中参数<code>siginfo_t</code>是一个结构体类型</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：三种信号SIGQUIT，SIGTERM，SIGINT共用一个信号处理函数，且该函数中释放了重要的资源，因此不可重入。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">daemon_exit</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放相关资源</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="comment">// 设置信号处理函数</span></span><br><span class="line">    sa.sa_handler = daemon_exit;</span><br><span class="line">    sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">    <span class="comment">// 将SIGQUIT，SIGTERM，SIGINT信号阻塞，防止重入</span></span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGQUIT);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGTERM);</span><br><span class="line">    sigaddset(&amp;sa.sa_mask, SIGINT);</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 要捕获SIGQUIT，SIGTERM，SIGINT三种信号</span></span><br><span class="line">    sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGTERM, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    sigaction(SIGQUIT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>暂略</p>
<h3 id="7-12-实时信号"><a href="#7-12-实时信号" class="headerlink" title="7.12 实时信号"></a>7.12 实时信号</h3><p>暂略</p>
<h3 id="7-13-信号实现原理"><a href="#7-13-信号实现原理" class="headerlink" title="7.13 信号实现原理"></a>7.13 信号实现原理</h3><p>该节是对<code>7.6节信号的响应过程</code>的补充扩展。</p>
<h4 id="7-13-1-未决和阻塞信号集"><a href="#7-13-1-未决和阻塞信号集" class="headerlink" title="7.13.1 未决和阻塞信号集"></a>7.13.1 未决和阻塞信号集</h4><p>在 PCB 中有两个非常重要的信号集。一个称之为 <code>阻塞信号集 mask</code>，另一个称之为 <code>未决信号集 pending</code>。这两个信号集体现在内核中就是两张表。</p>
<p>但是操作系统不允许我们直接对这两个信号集进行任何操作，而是需要自定义另外一个集合，借助<strong>信号集操作函数</strong>（详见<code>7.8-7.10节</code>）来对 PCB 中的这两个信号集进行修改。</p>
<ul>
<li>信号的 “未决（<code>pending</code>）” 是一种状态，指的是从信号的产生到信号被处理前的这一段时间。</li>
<li>信号的 “阻塞（<code>mask</code>）” 是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。</li>
</ul>
<p>阻塞信号集和未决信号集在内核中的结构是相同的，它们都是一个整形数组 (被封装过的)，一共 <code>128</code> 字节 （<code>int [32] == 1024 bit</code>），1024 个标志位，其中前 31 个标志位，每一个都对应一个 Linux 中的标准信号，通过标志位的值来标记当前信号在信号集中的状态。</p>
<h4 id="7-13-2-原理介绍"><a href="#7-13-2-原理介绍" class="headerlink" title="7.13.2 原理介绍"></a>7.13.2 原理介绍</h4><h5 id="①-信号处理相关的数据结构"><a href="#①-信号处理相关的数据结构" class="headerlink" title="① 信号处理相关的数据结构"></a>① 信号处理相关的数据结构</h5><p>在进程管理结构 <code>task_struct</code>（详见<code>8.1.2.①节</code>） 中有几个与信号处理相关的字段，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> sigpending; <span class="comment">// </span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">sig</span>;</span> <span class="comment">// 信号的处理方法</span></span><br><span class="line">    <span class="keyword">sigset_t</span> blocked; <span class="comment">// 阻塞信号集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span> <span class="comment">// 未决信号集</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sigpending</code>：表示进程是否有信号需要处理（1表示有，0表示没有）</li>
<li><code>blocked</code>：表示被屏蔽的信息，每个位代表一个被屏蔽的信号</li>
<li><code>sig</code>：表示信号相应的处理方法，其类型是 <code>struct signal_struct</code>，定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _NSIG  64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span>	<span class="title">action</span>[_<span class="title">NSIG</span>];</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		siglock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sigaction详见7.11.2节</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> sa_flags;</span><br><span class="line">	<span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">	<span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pending</code>：其类型为 <code>struct sigpending</code>，存储着进程接收到的信号<strong>队列</strong>，定义如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">next</span>;</span></span><br><span class="line">	<span class="keyword">siginfo_t</span> info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">head</span>, **<span class="title">tail</span>;</span></span><br><span class="line">	<span class="keyword">sigset_t</span> signal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当进程接收到一个信号时，就需要把接收到的信号添加 <code>pending</code> 这个队列中。</p>
<h5 id="②-发送信号"><a href="#②-发送信号" class="headerlink" title="② 发送信号"></a>② 发送信号</h5><p>暂略</p>
<h2 id="8-线程"><a href="#8-线程" class="headerlink" title="8 线程"></a>8 线程</h2><p>本节对应APUE第十一、十二章内容</p>
<h3 id="8-1-线程概念"><a href="#8-1-线程概念" class="headerlink" title="8.1 线程概念"></a>8.1 线程概念</h3><p>线程本质：一个正在运行的函数。</p>
<p>进程本质：加载到内存的程序。</p>
<p>进程是操作系统分配资源的单位，线程是调度的基本单位，线程之间共享进程资源。</p>
<p>典型的UNIX进程可以看成只有一个控制线程：一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。</p>
<p>每个线程都包含有表示执行环境所必需的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。</p>
<p>一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</p>
<h4 id="8-1-1-POSIX线程接口"><a href="#8-1-1-POSIX线程接口" class="headerlink" title="8.1.1 POSIX线程接口"></a>8.1.1 POSIX线程接口</h4><p>POSIX线程（英语：POSIX Threads，常被缩写为<code>Pthreads</code>）是POSIX的<strong>线程标准</strong>，定义了创建和操纵线程的一套API。</p>
<p>Pthreads定义了一套C语言的类型、函数与常量，它以<code>pthread.h</code>头文件和一个线程库实现。Pthreads API中大致共有100个函数调用，全都以<code>pthread_</code>开头，并可以分为四类：</p>
<ul>
<li>线程管理，例如创建线程，等待(join)线程，查询线程状态等。</li>
<li>互斥锁（Mutex）：创建、摧毁、锁定、解锁、设置属性等操作</li>
<li>条件变量（Condition Variable）：创建、摧毁、等待、通知、设置与查询属性等操作</li>
<li>使用了互斥锁的线程间的同步管理</li>
</ul>
<p>因此在编译时需要makefile的编译和链接选项：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread <span class="comment"># 编译选项</span></span><br><span class="line">LDFLAGS+=-pthread <span class="comment"># 链接选项</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -pthread  -pthread  create.c   -o create</span><br></pre></td></tr></table></figure>
<h4 id="8-1-2-进程和线程"><a href="#8-1-2-进程和线程" class="headerlink" title="8.1.2 进程和线程"></a>8.1.2 进程和线程</h4><h5 id="①-进程控制块"><a href="#①-进程控制块" class="headerlink" title="① 进程控制块"></a>① 进程控制块</h5><p>进程控制块是用于保存一个进程信息的结构体，称之为PCB（<code>process control block</code>），相当于进程的身份证；<strong>PCB是进程存在的唯一标识</strong>。</p>
<p>在Linux中PCB的信息存放在<code>task_struct</code>结构体中。结构体的主要成员如下：</p>
<ul>
<li>进程状态</li>
</ul>
<p>进程执行时，它会根据具体情况改变状态。进程状态是调度和对换的依据。Linux中的进程主要有如下状态：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TASK_RUNNING</code></td>
<td>可运行</td>
</tr>
<tr>
<td><code>TASK_INTERRUPTIBLE</code></td>
<td>可中断的等待状态</td>
</tr>
<tr>
<td><code>TASK_UNINTERRUPTIBLE</code></td>
<td>不可中断的等待状态</td>
</tr>
<tr>
<td><code>TASK_ZOMBIE</code></td>
<td>僵死</td>
</tr>
<tr>
<td><code>TASK_STOPPED</code></td>
<td>暂停</td>
</tr>
<tr>
<td><code>TASK_SWAPPING</code></td>
<td>换入/换出</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程调度信息</li>
</ul>
<p>调度程序利用这部分信息决定系统中哪个进程最应该运行，并结合进程的状态信息保证系统运转的公平和高效。这一部分信息通常包括进程的类别（普通进程还是实时进程）、进程的优先级等等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>need_resched</td>
<td>调度标志</td>
</tr>
<tr>
<td>Nice</td>
<td>静态优先级</td>
</tr>
<tr>
<td>Counter</td>
<td>动态优先级</td>
</tr>
<tr>
<td>Policy</td>
<td>调度策略</td>
</tr>
<tr>
<td>rt_priority</td>
<td>实时优先级</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>标识符</li>
</ul>
<p>每个进程有进程标识符、用户标识符、组标识符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pid</td>
<td>进程标识符</td>
</tr>
<tr>
<td>Uid、gid</td>
<td>用户标识符、组标识符</td>
</tr>
<tr>
<td>Euid、egid</td>
<td>有效用户标识符、有效组标识符</td>
</tr>
<tr>
<td>Suid、sgid</td>
<td>备份用户标识符、备份组标识符</td>
</tr>
<tr>
<td>Fsuid、fsgid</td>
<td>文件系统用户标识符、文件系统组标识符</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>进程通信有关信息</li>
</ul>
<p>为了使进程能在同一项任务上协调工作，进程之间必须能进行通信即交流数据。</p>
<p>Linux支持多种不同形式的通信机制。它支持典型的Unix通信机制（IPC Mechanisms）：<strong>信号</strong>（Signals）、<strong>管道</strong>（Pipes），也支持System V通信机制：<strong>共享内存（Shared Memory）、信号量和消息队列（Message Queues）</strong></p>
<ul>
<li>进程链接信息</li>
</ul>
<p>程序创建的进程具有父/子关系。因为一个进程能创建几个子进程，而子进程之间有兄弟关系，在task_struct结构中有几个成员来表示这种关系。</p>
<ul>
<li>时间和定时器信息</li>
</ul>
<p>一个进程从创建到终止叫做该进程的生存期（lifetime）。进程在其生存期内使用CPU的时间，内核都要进行记录，以便进行统计、计费等有关操作。</p>
<p>进程耗费CPU的时间由两部分组成：一是在用户模式（或称为用户态）下耗费的时间，一是在系统模式（或称为系统态）下耗费的时间。每个时钟滴答，也就是每个时钟中断，内核都要更新当前进程耗费CPU的时间信息，例如将进程的时间片减一。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>域名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Start_time</td>
<td>进程创建时间</td>
</tr>
<tr>
<td>Per_cpu_utime</td>
<td>进程在某个CPU上运行时在用户态下耗费的时间</td>
</tr>
<tr>
<td>Per_cpu_stime</td>
<td>进程在某个CPU上运行时在系统态下耗费的时间</td>
</tr>
<tr>
<td>Counter</td>
<td><strong>进程剩余的时间片</strong></td>
</tr>
</tbody>
</table>
</div>
<p>进程中的定时器如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221227214742773.png" alt="image-20221227214742773"></p>
<p>其余略</p>
<h5 id="②-线程共享和私有内容"><a href="#②-线程共享和私有内容" class="headerlink" title="② 线程共享和私有内容"></a>② 线程共享和私有内容</h5><p>私有资源：所属线程的栈区、程序计数器、栈指针以及函数运行使用的寄存器是线程私有的。这些资源又称为线程上下文。</p>
<p>除此之外的所有资源均由线程共享。</p>
<h3 id="8-2-线程标识"><a href="#8-2-线程标识" class="headerlink" title="8.2 线程标识"></a>8.2 线程标识</h3><p>就像每个进程有一个进程ID一样，每个线程也有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义。</p>
<p>进程ID是用<code>pid_t</code>数据类型来表示的，是一个非负整数。线程ID是用<code>pthread_t</code> 数据类型来表示的，实现的时候可以用一个<strong>结构</strong>来代表pthread_t数据类型，所以可移植的操作系统实现不能把它作为整数处理。</p>
<p>因此需要一个函数来对两个线程ID进行比较：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相等返回非零，不等返回0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> t1, <span class="keyword">pthread_t</span> t2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>获取自身的线程id：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-线程创建"><a href="#8-3-线程创建" class="headerlink" title="8.3 线程创建"></a>8.3 线程创建</h3><p>在传统 UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程的模型中每个进程只包含一个线程是相同的。在POSIX线程（pthread）的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。</p>
<p>新增的线程可以通过调用<code>pthread_create</code>函数创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 成功返回0，失败返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thread</code>：事先创建好的<code>pthread_t</code>类型的参数。成功时thread指向的内存单元被设置为新创建线程的线程ID。</li>
<li><code>attr</code>：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。</li>
<li><code>start_routine</code>：新创建线程从此函数开始运行，无参数时<code>arg</code>设为NULL即可。形参是函数指针（该函数返回值和形参均为<code>void*</code>），因此需要传入函数地址。</li>
<li><code>arg</code>：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">func</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./create </span></span><br><span class="line">Begin!</span><br><span class="line">End!</span><br></pre></td></tr></table></figure>
<p>分析：线程的调度取决于调度器策略。创建线程后，新的线程还没来得及被调度，main线程就执行了<code>exit(0)</code>使得进程退出，所以新的线程并没有被执行就退出了。</p>
<h3 id="8-4-线程终止"><a href="#8-4-线程终止" class="headerlink" title="8.4 线程终止"></a>8.4 线程终止</h3><h4 id="8-4-1-终止方式"><a href="#8-4-1-终止方式" class="headerlink" title="8.4.1 终止方式"></a>8.4.1 终止方式</h4><p>如果进程中的任意线程调用了 <code>exit</code>、<code>_Exit</code> 或者 <code>_exit</code>，那么<strong>整个进程</strong>就会终止。与此相类似，如果默认的动作是终止进程，那么，发送到线程的信号就会终止整个进程。</p>
<p>单个线程可以通过3种方式退出，因此可以在不终止整个进程的情况下，停止它的控制流：</p>
<ul>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码</li>
<li>线程可以被同一进程中的其他线程取消</li>
<li>线程调用<code>pthread_exit</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// return NULL;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>函数<code>pthread_join</code>用来等待一个线程的结束。相当于进程控制中的<code>wait</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>thread</code>：为被等待的线程标识符</li>
<li><code>retval</code>：为用户定义的指针，它可以用来存储被等待线程的返回值，即<code>pthread_exit</code>的参数。这是一个二级指针，因此传入的参数为一级指针的地址，如果不关心返回值则用NULL</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// join</span></span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./create </span></span><br><span class="line">Begin!</span><br><span class="line">Thread is working!</span><br><span class="line">End!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_fn1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 is working!\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_fn2</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread2 is working!\n&quot;</span>);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread is working!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thr_fn1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, thr_fn2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create():%s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_join(tid1, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread1 exit code %ld\n&quot;</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid2, &amp;tret);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread2 exit code %ld\n&quot;</span>, (<span class="keyword">long</span>)tret);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng pthread]<span class="comment"># ./test</span></span><br><span class="line">main thread is working!</span><br><span class="line">thread1 is working!</span><br><span class="line">thread1 <span class="built_in">exit</span> code 1</span><br><span class="line">thread2 is working!</span><br><span class="line">thread2 <span class="built_in">exit</span> code 2</span><br><span class="line">main thread <span class="built_in">exit</span>!</span><br></pre></td></tr></table></figure>
<hr>
<p>补充：<code>void*</code></p>
<ul>
<li><code>void*</code>可以指向任何类型的地址。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">5.5</span>;</span><br><span class="line"><span class="keyword">float</span>* pf = &amp;f;</span><br><span class="line"><span class="keyword">void</span>* pv = pf; <span class="comment">// pv可以指向float类型的地址</span></span><br><span class="line"><span class="keyword">float</span>* pf2 = pv; <span class="comment">//编译错误，有类型的指针变量不能指向void*变量</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>void*</code>指针只有强制类型转换以后才可以解引用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">5.5</span>;</span><br><span class="line">    <span class="keyword">float</span>* pf = &amp;f;</span><br><span class="line">    <span class="keyword">void</span>* pv;</span><br><span class="line">    </span><br><span class="line">    pv = pf; <span class="comment">//这句是可以的</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*pv&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//编译错误，这样直接对pv取值是错误的</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*(<span class="keyword">float</span>*)pv&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//强制类型转换后可以取值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>void*</code>指针变量和普通指针一样可以通过等于0或者NULL来初始化，表示一个空指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* pv = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">void</span>* pv2 = <span class="literal">NULL</span>; <span class="comment">// 指针保存的地址为空或0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当<code>void*</code>指针作为函数的输入和输出时，表示可以接受任意类型的输入指针和输出任意类型的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">test</span><span class="params">(<span class="keyword">void</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test: %d\n&quot;</span>, *(<span class="keyword">int</span> *)a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span>* pi = &amp;a;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, pi);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, test(pi));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: %d\n&quot;</span>, *(<span class="keyword">int</span> *)test(pi));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffcd39fa0d4</span><br><span class="line">test: 5</span><br><span class="line">0x7ffcd39fa0d4</span><br><span class="line">test: 5</span><br><span class="line">main: 5</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-栈的清理"><a href="#8-4-2-栈的清理" class="headerlink" title="8.4.2 栈的清理"></a>8.4.2 栈的清理</h4><p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。这样的函数称为<strong>线程清理处理程序</strong>（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录在栈中，也就是说，它们的执行顺序与它们注册时相反。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*routine)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当线程执行以下动作时，清理函数<code>routine</code>是由<code>pthread_cleanup_push</code>函数调度的，调用时只有一个参数<code>arg</code>：</p>
<ul>
<li>调用pthread_exit时；</li>
<li>响应取消请求时；</li>
<li>用非零execute参数调用pthread_cleanup_pop 时。如果 execute 参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次 pthread_cleanup_push调用建立的清理处理程序。</li>
</ul>
<p>注意：这些函数有一个限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以<strong>匹配对</strong>的形式使用。pthread_cleanup_push 的宏定义可以包含字符<code>&#123;</code>，这种情况下，在 pthread cleanup_pop 的定义中要有对应的匹配字符<code>&#125;</code>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanup_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Thread is working!&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:1&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:2&quot;</span>);</span><br><span class="line">    pthread_cleanup_push(cleanup_func, <span class="string">&quot;cleanup:3&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;push over!&quot;</span>);</span><br><span class="line">    <span class="comment">// 成对出现</span></span><br><span class="line">    pthread_cleanup_pop(<span class="number">1</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Begin!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;End!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Begin!</span><br><span class="line">Thread is working!</span><br><span class="line">push over!</span><br><span class="line">cleanup:3</span><br><span class="line">End!</span><br></pre></td></tr></table></figure>
<h4 id="8-4-3-线程的取消"><a href="#8-4-3-线程的取消" class="headerlink" title="8.4.3 线程的取消"></a>8.4.3 线程的取消</h4><p>多线程程序中，一个线程可以借助 <code>pthread_cancel()</code> 函数向另一个线程发送“终止执行”的信号，从而令目标线程结束执行。</p>
<p><code>pthread_cancel</code>调用并不等待线程终止，它只提出请求。线程在取消请求发出后会继续运行，直到到达某个取消点<code>(CancellationPoint)</code>。取消点是线程检查是否被取消并按照请求进行动作的一个位置。</p>
<p>与线程取消相关的函数有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送终止信号给thread线程，如果成功则返回0，否则为非0值。发送成功并不意味着thread会终止。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置本线程取消动作的执行时机</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">int</span> *oldtype)</span>  </span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_testcancel</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_Fun</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;新建线程开始执行\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> myThread;</span><br><span class="line">    <span class="keyword">void</span> * mess;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="comment">//创建 myThread 线程</span></span><br><span class="line">    res = pthread_create(&amp;myThread, <span class="literal">NULL</span>, thread_Fun, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程创建失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//向 myThread 线程发送 Cancel 信号</span></span><br><span class="line">    res = pthread_cancel(myThread);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;终止 myThread 线程失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取已终止线程的返回值</span></span><br><span class="line">    res = pthread_join(myThread, &amp;mess);</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;等待线程失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果线程被强制终止，其返回值为 PTHREAD_CANCELED</span></span><br><span class="line">    <span class="keyword">if</span> (mess == PTHREAD_CANCELED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;myThread 线程被强制终止\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-线程同步"><a href="#8-5-线程同步" class="headerlink" title="8.5 线程同步"></a>8.5 线程同步</h3><h4 id="8-5-1-概念和例子"><a href="#8-5-1-概念和例子" class="headerlink" title="8.5.1 概念和例子"></a>8.5.1 概念和例子</h4><blockquote>
<p>线程竞争的实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1) <span class="comment">// 线程个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = *(<span class="keyword">int</span> *)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++)</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：发现每次都不一样，并且每次的结果都是相同的。</p>
<p>原因：线程发生了竞争。</p>
<p>创建线程时，main线程传递给函数<code>thr_prime</code>的参数<code>&amp;i</code>是同一个地址，但是地址保存的值不相同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, &amp;i);</span><br></pre></td></tr></table></figure>
<p>后面线程执行时，会对这个地址进行解引用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = *(<span class="keyword">int</span> *)p;</span><br></pre></td></tr></table></figure>
<p>注意：main线程和创建的线程的调度是由调度算法决定，因此会出现，在线程解引用之前，main线程就将该地址上的i值进行了修改，所以后面线程得到的i值都是同一个值。</p>
<blockquote>
<p>解决竞争</p>
</blockquote>
<p>定义一个结构体，成员为要计算判断的数，然后每次动态分配内存，将地址作为线程函数的参数即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="comment">// 先将void*强转为struct thr_arg_st *</span></span><br><span class="line">    i = ((struct thr_arg_st *)p) -&gt; n;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">    <span class="comment">// 将p作为返回值</span></span><br><span class="line">	pthread_exit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thr_arg_st</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">void</span> * ret;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        <span class="comment">// 动态分配内存</span></span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p));</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;malloc()&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; n = i; </span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, p);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        <span class="comment">// 用ret来接收（一级指针的地址）</span></span><br><span class="line">        pthread_join(tid[i-LEFT], &amp;ret);</span><br><span class="line">        <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">        <span class="built_in">free</span>(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>当多个控制线程共享相同的内存时，需要确保每个线程看到一致的数据视图。如果每个线程使用的变量都是其他线程不会读取和修改的，那么就不存在一致性问题。同样，如果变量是只读的，多个线程同时读取该变量也不会有一致性问题。但是，当一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保它们在访问变量的存储内容时不会访问到无效的值。</p>
<p>当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。在变量修改时间多于一个存储器访问周期的处理器结构中，当存储器读与存储器写这两个周期交叉时，这种不一致就会出现。当然，这种行为是与处理器体系结构相关的，但是可移植的程序并不能对使用何种处理器体系结构做出任何假设。</p>
<p>图11-7描述了两个线程读写相同变量的假设例子。在这个例子中，线程A读取变量然后给这个变量赋予一个新的数值，但写操作需要两个存储器周期。当线程B在这两个存储器写周期中间读取这个变量时，它就会得到不一致的值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122215903.png" alt="image-20221230122215903"></p>
<p>为了解决这个问题，线程不得不使用锁，同一时间只允许一个线程访问该变量。图11-8描述了这种同步。如果线程B希望读取变量，它首先要获取<strong>锁</strong>。同样，当线程A更新变量时，也需要获取同样的这把锁。这样，线程B在线程A释放锁以前就不能读取变量。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221230122240495.png" alt="image-20221230122240495"></p>
<h4 id="8-5-2-互斥量"><a href="#8-5-2-互斥量" class="headerlink" title="8.5.2 互斥量"></a>8.5.2 互斥量</h4><p>可以使用 pthread 的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（<code>mutex</code>）<strong>从本质上说是一把锁</strong>，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放（解锁）互斥量。</p>
<p>对互斥量进行加锁以后，任何其他试图再次对互斥量加锁的线程都会<strong>被阻塞</strong>直到当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p>
<p>只有将所有线程都设计成遵守相同数据访问规则的，互斥机制才能正常工作。操作系统并不会为我们做数据访问的串行化。如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他的线程在使用共享资源前都申请锁，也还是会出现数据不一致的问题。</p>
<p>互斥变量是用 <code>pthread_mutex_t</code> 数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量<code>PTHREAD_MUTEX_INITIALIZER</code>（只适用于静态分配的互斥量），也可以通过调用<code>pthread_mutex_init</code>函数进行初始化。如果动态分配互斥量（例如，通过调用malloc函数），在释放内存前需要调用<code>pthread_mutex_destroy</code>。</p>
<p>相关函数：</p>
<ul>
<li>初始化和销毁：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 销毁互斥量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态分配互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure>
<ul>
<li>加锁和解锁</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 非阻塞加锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——20个线程读写一个文件</p>
</blockquote>
<p>先向<code>/tmp/out</code>下入1，然后创建20个线程来读这个文件内容并加1，然后写入。期望内容为<code>21</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fgets(linebuf, LINESIZE, fp);</span><br><span class="line">    <span class="comment">// 读完后将文件指针指向文件起始处</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 向文件写入内容</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, atoi(linebuf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng posix]<span class="comment"># echo 1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># cat /tmp/out</span></span><br><span class="line">1</span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># ./add</span></span><br><span class="line">[root@HongyiZeng posix]<span class="comment"># cat /tmp/out</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>分析：由于调度和竞争，线程读到文件内容1后，休眠1s，然后一起写入2，所以结果就为2；</p>
<blockquote>
<p>代码示例——互斥量的使用</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FNAME <span class="meta-string">&quot;/tmp/out&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_add</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> linebuf[LINESIZE];</span><br><span class="line"></span><br><span class="line">    fp = fopen(FNAME, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在进入临界区前加上互斥锁</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut);</span><br><span class="line">    fgets(linebuf, LINESIZE, fp);</span><br><span class="line">    <span class="comment">// 读完后将文件指针指向文件起始处</span></span><br><span class="line">    fseek(fp, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 向文件写入内容</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d\n&quot;</span>, atoi(linebuf) + <span class="number">1</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="comment">// 退出临界区后解锁</span></span><br><span class="line">    pthread_mutex_unlock(&amp;mut);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_add, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng posix]<span class="meta"># echo 1 &gt; /tmp/out</span></span><br><span class="line">[root@HongyiZeng posix]# ./add</span><br><span class="line">[root@HongyiZeng posix]<span class="meta"># cat /tmp/out</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例3——使用互斥锁实现线程同步</p>
</blockquote>
<p>需求：四个线程依次打印<code>abcd</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut[THRNUM];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回下一个线程的编号0~3，3的下一个为0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) == THRNUM ? <span class="number">0</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p; <span class="comment">// 线程编号</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">&#x27;a&#x27;</span> + (<span class="keyword">int</span>)p; <span class="comment">// 线程打印的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(mut + n);</span><br><span class="line">        <span class="comment">// 向终端打印字符</span></span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 释放下一个线程的锁</span></span><br><span class="line">        pthread_mutex_unlock(mut + next(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(mut + i, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(mut + i);</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放打印a的线程的锁</span></span><br><span class="line">    pthread_mutex_unlock(mut + <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 运行3s终止进程</span></span><br><span class="line">    alarm(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-3-线程池"><a href="#8-5-3-线程池" class="headerlink" title="8.5.3 线程池"></a>8.5.3 线程池</h4><p>线程数是有一定限制的，<code>8.5.1节</code>用201个线程来检测质数，本节利用线程池来解决。</p>
<p>假设线程池提供4个线程来检测201个质数。设置临界区资源<code>num</code>，当：</p>
<ul>
<li><code>num = 0</code>：当前没有任务</li>
<li><code>num = -1</code>：当前任务已经全部完成</li>
<li><code>num = 300000~3000200</code>：当前有一个任务，需要一个线程来接受任务</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4 <span class="comment">// 假设线程池中有4个线程</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 临界区资源</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="comment">// 死循环：领取任务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 循环检测是否有任务</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>) &#123; <span class="comment">// 当前没有任务</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到任务，判断是否为-1，即任务已经结束</span></span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 要释放锁，防止其他线程死锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拿到任务</span></span><br><span class="line">        i = num;</span><br><span class="line">        <span class="comment">// 将num设置为0，即没有任务</span></span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        <span class="comment">//---------线程做任务：检测是否为质数-------</span></span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[thread-%d]%d is a primer.\n&quot;</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="comment">// 启动线程池</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 主线程下发任务</span></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 循环检测任务是否被线程领走</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123; <span class="comment">// 没有领走任务</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="comment">// 让出CPU</span></span><br><span class="line">            sched_yield();</span><br><span class="line">            pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置num，即下发任务</span></span><br><span class="line">        num = i;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125; <span class="comment">// 下发任务完毕</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置num为-1，代表任务全部结束</span></span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="comment">// 循环检测最后一个任务是否被完成</span></span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) &#123; <span class="comment">// 没有完成</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已完成，则设置为-1</span></span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">	<span class="comment">// 收尸</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[thread-0]30000001 is a primer.</span><br><span class="line">[thread-2]30000041 is a primer.</span><br><span class="line">[thread-3]30000023 is a primer.</span><br><span class="line">[thread-1]30000037 is a primer.</span><br><span class="line">[thread-1]30000079 is a primer.</span><br><span class="line">[thread-0]30000059 is a primer.</span><br><span class="line">[thread-3]30000071 is a primer.</span><br><span class="line">[thread-2]30000049 is a primer.</span><br><span class="line">[thread-0]30000083 is a primer.</span><br><span class="line">[thread-1]30000109 is a primer.</span><br><span class="line">[thread-3]30000137 is a primer.</span><br><span class="line">[thread-2]30000133 is a primer.</span><br><span class="line">[thread-3]30000163 is a primer.</span><br><span class="line">[thread-1]30000149 is a primer.</span><br><span class="line">[thread-0]30000167 is a primer.</span><br><span class="line">[thread-2]30000169 is a primer.</span><br><span class="line">[thread-0]30000199 is a primer.</span><br><span class="line">[thread-3]30000193 is a primer.</span><br></pre></td></tr></table></figure>
<p>不足：该程序存在盲等，即查询法的不足，上游main线程一直在循环查看任务是否被领走，而下游一直在循环查看是否有任务。</p>
<p>通知法：上游将设置任务后，唤醒下游来处理任务。如果没有领走任务，则阻塞自己，等待下游来唤醒。</p>
<p>下游发现有任务，则领走任务，并唤醒上游；没有任务，则阻塞，等待上游来唤醒。</p>
<h4 id="8-5-4-线程令牌桶"><a href="#8-5-4-线程令牌桶" class="headerlink" title="8.5.4 线程令牌桶"></a>8.5.4 线程令牌桶</h4><p>暂略</p>
<h4 id="8-5-5-条件变量"><a href="#8-5-5-条件变量" class="headerlink" title="8.5.5 条件变量"></a>8.5.5 条件变量</h4><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<p>在使用条件变量之前，必须先对它进行初始化。由<code>pthread_cond_t</code>数据类型表示的条件变量可以用两种方式进行初始化。可以把常量<code>PTHREAD_COND_INITTALIZER</code>赋给静态分配的条件变量但是如果条件变量是动态分配的，则需要使用<code>pthread_cond_init</code>函数对它进行初始化。在释放条件变量底层的内存空间之前，可以使用<code>pthread_cond_destroy</code>函数对条件变量进行反初始化。</p>
<p>相关函数和作用：</p>
<blockquote>
<p>初始化条件变量</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>阻塞当前线程，等待条件成立</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有时间的条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>cond</code>：已初始化好的条件变量</li>
<li><code>mutex</code>：与条件变量配合使用的互斥锁</li>
<li><code>abstime</code>：阻塞线程的时间</li>
</ul>
<p>调用两个函数之前，我们必须先创建好一个互斥锁并完成加锁操作，然后才能作为实参传递给 <code>mutex</code> 参数。两个函数会完成以下两项工作：</p>
<ul>
<li>阻塞线程，直至接收到条件成立的信号</li>
<li>当线程被添加到等待队列上时，将互斥锁解锁，即释放mutex</li>
</ul>
<p>也就是说，函数尚未接收到“条件成立”的信号之前，它将一直阻塞线程执行。注意，当函数接收到“条件成立”的信号后，它并不会立即结束对线程的阻塞，而是先完成对互斥锁的“加锁”操作，然后才解除阻塞。</p>
<p>两个函数都以“原子操作”的方式完成“阻塞线程+解锁”或者“重新加锁+解除阻塞”这两个过程。</p>
<blockquote>
<p>解除线程的“阻塞”状态</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 唤醒所有的阻塞线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒所有正在的至少一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于被上面两个函数阻塞的线程，我们可以借助如上两个函数向它们发送“条件成立”的信号，解除它们的“阻塞”状态。</p>
<p>由于互斥锁的存在，解除阻塞后的线程也不一定能立即执行。当互斥锁处于“加锁”状态时，解除阻塞状态的所有线程会组成等待互斥锁资源的队列，等待互斥锁“解锁”。</p>
<blockquote>
<p>代码示例1——查询法转通知法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut_num = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond_num = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 查看是否有任务</span></span><br><span class="line">        <span class="keyword">while</span>(num == <span class="number">0</span>) &#123; <span class="comment">// 没有任务</span></span><br><span class="line">            <span class="comment">// 则阻塞自己，释放互斥锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 领走任务</span></span><br><span class="line">        i = num;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 唤醒所有阻塞线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">                mark = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(mark)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[thread-%d]%d is a primer.\n&quot;</span>, (<span class="keyword">int</span>)p, i);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        err = pthread_create(tid+i, <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">        <span class="comment">// 查看任务是否领走</span></span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>) &#123; <span class="comment">// 任务没有领走</span></span><br><span class="line">            <span class="comment">// 阻塞自己，并释放互斥锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond_num, &amp;mut_num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经被领走，则设置任务</span></span><br><span class="line">        num = i; <span class="comment">// 设置任务</span></span><br><span class="line">        <span class="comment">// 唤醒任何一个阻塞的线程</span></span><br><span class="line">        pthread_cond_signal(&amp;cond_num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    <span class="keyword">while</span>(num != <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line">        sched_yield();</span><br><span class="line">        pthread_mutex_lock(&amp;mut_num);</span><br><span class="line">    &#125;</span><br><span class="line">    num = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 唤醒所有线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;cond_num);</span><br><span class="line">    pthread_mutex_unlock(&amp;mut_num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mut_num);</span><br><span class="line">    pthread_cond_destroy(&amp;cond_num);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2——打印abcd</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) == THRNUM ? <span class="number">0</span> : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>)p;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="string">&#x27;a&#x27;</span> + (<span class="keyword">int</span>)p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mut);</span><br><span class="line">        <span class="comment">// 向终端打印字符</span></span><br><span class="line">        <span class="keyword">while</span>(num != n) &#123;</span><br><span class="line">            <span class="comment">// 如果num不是自己的编号，则阻塞并释放锁</span></span><br><span class="line">            pthread_cond_wait(&amp;cond, &amp;mut);</span><br><span class="line">        &#125;</span><br><span class="line">        write(<span class="number">1</span>, &amp;c, <span class="number">1</span>);</span><br><span class="line">        num = next(num); <span class="comment">// 将num修改为下一个线程的编号</span></span><br><span class="line">        <span class="comment">// 广播唤醒所有阻塞的线程</span></span><br><span class="line">        pthread_cond_broadcast(&amp;cond);</span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++) &#123;</span><br><span class="line">        err = pthread_create(tid + i, <span class="literal">NULL</span>, thr_func, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    alarm(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; THRNUM; i++)</span><br><span class="line">        pthread_join(tid[i], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_destroy(&amp;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;cond);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-5-6-信号量"><a href="#8-5-6-信号量" class="headerlink" title="8.5.6 信号量"></a>8.5.6 信号量</h4><p>使用互斥量和条件变量可以实现信号量的功能。</p>
<p>需求：产生4个线程（4个资源）来筛选质数，任务完成后线程退出，然后又产生线程。这里的共享资源就是4个线程。</p>
<ul>
<li><code>mysem.h</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYSEM_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYSEM_H__</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为void取别名为mysem_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> <span class="keyword">mysem_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mysem_t</span> *<span class="title">mysem_init</span><span class="params">(<span class="keyword">int</span> initval)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_add</span><span class="params">(<span class="keyword">mysem_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_sub</span><span class="params">(<span class="keyword">mysem_t</span> *, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_destroy</span><span class="params">(<span class="keyword">mysem_t</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>mysem.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mysem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value; <span class="comment">// 现有资源数（相当于信号量）</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mut; <span class="comment">// 互斥量</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond; <span class="comment">// 条件变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量初始化，initval为资源总数</span></span><br><span class="line"><span class="function"><span class="keyword">mysem_t</span> *<span class="title">mysem_init</span><span class="params">(<span class="keyword">int</span> initval)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span>;</span></span><br><span class="line">    me = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*me));</span><br><span class="line">    <span class="keyword">if</span>(me == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;value = initval;</span><br><span class="line">    pthread_mutex_init(&amp;me-&gt;mut, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;me-&gt;cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> me;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_add</span><span class="params">(<span class="keyword">mysem_t</span> *ptr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将void*的指针指向mysem_st*</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr; </span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    me-&gt;value += n;</span><br><span class="line">    <span class="comment">// 广播唤醒所有等待线程</span></span><br><span class="line">    pthread_cond_broadcast(&amp;me-&gt;cond);</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 减少信号量，索要n个资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_sub</span><span class="params">(<span class="keyword">mysem_t</span> *ptr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line">    pthread_mutex_lock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">while</span>(me-&gt;value &lt; n) &#123; <span class="comment">// 当资源总数少于需要的n</span></span><br><span class="line">        <span class="comment">// 条件等待</span></span><br><span class="line">        pthread_cond_wait(&amp;me-&gt;cond, &amp;me-&gt;mut);</span><br><span class="line">    &#125;</span><br><span class="line">    me-&gt;value -= n;</span><br><span class="line">    pthread_mutex_unlock(&amp;me-&gt;mut);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁信号量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysem_destroy</span><span class="params">(<span class="keyword">mysem_t</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mysem_st</span> *<span class="title">me</span> =</span> ptr;</span><br><span class="line">    pthread_mutex_destroy(&amp;me-&gt;mut);</span><br><span class="line">    pthread_cond_destroy(&amp;me-&gt;cond);</span><br><span class="line">    <span class="built_in">free</span>(me);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>main.c</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mysem.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT  30000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT 30000200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THRNUM (RIGHT-LEFT+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4 <span class="comment">// 资源总量（可创建的线程总数）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mysem_t</span> *sem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_prime</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, mark;</span><br><span class="line">    i = (<span class="keyword">int</span>)p;</span><br><span class="line">    mark = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">2</span>; j &lt; i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">            mark = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mark)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is a primer.\n&quot;</span>, i);</span><br><span class="line">   	<span class="comment">// 假设任务需要5s完成</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 增加信号量</span></span><br><span class="line">    mysem_add(sem, <span class="number">1</span>);</span><br><span class="line">	pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[THRNUM];</span><br><span class="line">    </span><br><span class="line">    sem = mysem_init(N);</span><br><span class="line">    <span class="keyword">if</span>(sem == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mysem_init() failed!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        <span class="comment">// 减少信号量</span></span><br><span class="line">        mysem_sub(sem, <span class="number">1</span>);</span><br><span class="line">        err = pthread_create(tid+(i-LEFT), <span class="literal">NULL</span>, thr_prime, (<span class="keyword">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = LEFT; i &lt;= RIGHT; i++) &#123;</span><br><span class="line">        pthread_join(tid[i-LEFT], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mysem_destroy(sem);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>makefile</code></li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS+=-pthread</span><br><span class="line">LDFLAGS+=-pthread</span><br><span class="line"></span><br><span class="line"><span class="section">all: mysem</span></span><br><span class="line"></span><br><span class="line"><span class="section">mysem:main.o mysem.o</span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o mysem</span><br></pre></td></tr></table></figure>
<blockquote>
<p>执行结果</p>
</blockquote>
<p>使用命令，查看线程关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps ax -L</span><br></pre></td></tr></table></figure>
<p>由下图所示，主线程<code>main[3134]</code>创建了4个线程来筛选质数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093757431.png" alt="image-20221231093757431"></p>
<p>当某个线程完成任务后，增加信号量，并唤醒阻塞线程，下图表示原来的4个线程已经完成任务退出，主线程又创建了4个新的线程来筛选质数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093816207.png" alt="image-20221231093816207"></p>
<p>同理，图表示原来的4个线程已经完成任务退出，主线程又创建了4个新的线程来筛选质数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221231093834252.png" alt="image-20221231093834252"></p>
<h3 id="8-6-线程属性"><a href="#8-6-线程属性" class="headerlink" title="8.6 线程属性"></a>8.6 线程属性</h3><p>pthread 接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常，管理这些属性的函数都遵循相同的模式。</p>
<p>在所有调用<code>pthread_create</code>函数的实例中，传入的参数都是空指针，而不是指向<code>pthread_attr_t</code>结构的指针。可以使用<code>pthread_attr_t</code>结构修改线程默认属性，并把这些属性与创建的线程联系起来。</p>
<p>可以使用<code>pthread_attr_init</code>函数初始化 <code>pthread_attr_t</code> 结构。在调用 <code>pthread attr_init</code> 以后，<code>pthread_attr_t</code> 结构所包含的就是操作系统实现支持的所有线程属性的<strong>默认值</strong>。</p>
<blockquote>
<p>初始化和销毁</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下图总结了 POSIX.1 定义的线程属性。POSIX.1 还为线程执行调度（Thread Execution Scheduling）选项定义了额外的属性，用以支持实时应用。下图同时给出了各个操作系统平台对每个线程属性的支持情况。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231175621629.png" alt="image-20221231175621629"></p>
<hr>
<blockquote>
<p>线程分离状态属性</p>
</blockquote>
<p>线程分离：在我们使用默认属性创建一个线程的时候，线程是 joinable 的。 joinable 状态的线程，必须在另一个线程中使用 pthread_join() 等待其结束， 如果一个 joinable 的线程在结束后，没有使用 pthread_join() 进行操作， 这个线程就会变成”僵尸线程”。可以使用<code>pthread_detach</code>函数让线程分离。</p>
<p>当线程被设置为分离状态后，线程结束时，它的资源会被操作系统自动的回收， 而不再需要在其它线程中对其进行 pthread_join() 操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设置状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 获取状态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>detachstate</code>：可以设置为以下属性<ul>
<li><code>PTHREAD_CREATE_DETACHED</code>：线程分离状态</li>
<li><code>PTHREAD_CREATE_JONINABLE</code>：线程可joinable状态</li>
</ul>
</li>
</ul>
<p>代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">fn</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 设置创建的线程为分离状态</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    err = pthread_create(&amp;tid, &amp;attr, fn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>线程的栈和栈大小</p>
</blockquote>
<p>可以使用下列函数设置线程的栈属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *stackaddr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstack</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> **stackaddr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于进程来说，虚地址空间的大小是固定的。因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚地址空间必须被所有的线程栈共享。如果应用程序使用了许多线程，以致这些线程栈的累计大小超过了可用的虚地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了大量的自动变量，或者调用的函数涉及许多很深的栈帧（stack frame），那么需要的栈大小可能要比默认的大。</p>
<p>如果线程栈的虚地址空间都用完了，那可以使用malloc或者mmap来为可替代的栈分配空间，并用<code>pthread_attr_setstack</code>函数来改变新建线程的栈位置。由<code>stackaddr</code> 参数指定的地址可以用作线程视的内容范围中的最低可寻找地址，该地址与处理器结构相应的边界应对齐。当然，这要假设malloc和mmap所用的虚地址范围与线程栈当前使用的虚地址范围不同。</p>
<p><code>stackaddr</code>线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么 <code>stackaddr</code>线程属性将是栈的结尾位置，而不是开始位置。</p>
<p>应用程序也可以通过下列函数读取或设置线程属性<code>stacksize</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> stacksize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getstacksize</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">size_t</span> *stacksize)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果希望改变默认的栈大小，但又不想自己处理线程栈的分配问题，这时使用<code>pthread_attr_setstacksize</code>函数就非常有用。设置stacksize属性时，选择的stacksize不能小于<code>PTHREAD_STACK_MIN</code>。</p>
<p>代码示例——测试线程数量的上限：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 定义线程的栈大小为10M</span></span><br><span class="line">    pthread_attr_setstacksize(&amp;attr, <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i ; i++) &#123;</span><br><span class="line">        err = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(err) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create(): %s\n&quot;</span>, stderror(err));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-7-同步属性"><a href="#8-7-同步属性" class="headerlink" title="8.7 同步属性"></a>8.7 同步属性</h3><p>线程的同步对象也具有属性。</p>
<h4 id="8-7-1-互斥量属性"><a href="#8-7-1-互斥量属性" class="headerlink" title="8.7.1 互斥量属性"></a>8.7.1 互斥量属性</h4><p>互斥量属性是用 <code>pthread_mutexattr_t</code> 结构表示的。在<code>8.5.2节</code>每次对互斥量进行初始化时，都是通过使用<code>PTHREAD_MUTEX_INITTALIZER</code> 常量或者用指向互斥量属性结构的空指针作为参数调用 <code>pthread_mutex_init</code> 函数，得到互斥量的默认属性。</p>
<p>对于非默认属性，可以使用下列函数进行初始化和销毁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_destroy</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>互斥量的三个主要属性：</p>
<ul>
<li>进程共享属性</li>
<li>健壮属性（略）</li>
<li>类型属性</li>
</ul>
<blockquote>
<p>进程共享</p>
</blockquote>
<p>在进程中，多个线程可以访问同一个同步对象。正如在<code>8.5.2节</code>看到的，这是默认的行为。在这种情况下，进程共享互斥量属性需设置为<code>PTHREAD_PROCESS_PRIVATE</code>。</p>
<p>但也存在这样的机制：允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为<code>PTHREAD_PROCESS_SHARED</code>，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步。</p>
<p>相关函数调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> * <span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>pshared</code>：这里的p指的就是进程process<ul>
<li><code>PTHREAD_PROCESS_PRIVATE</code>：进程独占互斥量</li>
<li><code>PTHREAD_PROCESS_SHARED</code>：进程共享互斥量</li>
</ul>
</li>
</ul>
<blockquote>
<p>类型属性</p>
</blockquote>
<p>类型互斥量属性控制着互斥量的锁定特性。POSIX.1定义了4种类型。</p>
<ul>
<li><code>PTHREAD_MUTEX_NORMAL</code>：一种标准互斥量类型，不做任何特殊的错误检查或死锁检测。</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>：此互斥量类型提供错误检查。</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code> ：此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以，如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处于加锁状态，对它再次解锁以前不能释放该锁。</li>
<li><code>PTHREAD_MUTEX_DEFAULT</code>：此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候可以把这种类型自由地映射到其他互斥量类型中的一种。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20221231194113676.png" alt="image-20221231194113676"></p>
<p>上图不占用解锁是指解锁不是自己加的锁（解锁别人加的锁），例如打印abcd的程序。</p>
<p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="keyword">pthread_mutexattr_t</span> *attr, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="8-7-2-条件变量属性"><a href="#8-7-2-条件变量属性" class="headerlink" title="8.7.2 条件变量属性"></a>8.7.2 条件变量属性</h4><p>相关函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_destroy</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_init</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_getpshared</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr, <span class="keyword">int</span> *<span class="keyword">restrict</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_condattr_setpshared</span><span class="params">(<span class="keyword">pthread_condattr_t</span> *attr,<span class="keyword">int</span> pshared)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-8-线程安全IO"><a href="#8-8-线程安全IO" class="headerlink" title="8.8 线程安全IO"></a>8.8 线程安全IO</h3><p>此前介绍过的IO都是线程安全的IO，即在当多个线程操作IO时，都必须对缓冲区进行加锁和解锁，防止出现对缓冲区进行竞争的现象。</p>
<p>例如三个线程，分别向标准输出终端打印连续字符<code>aaa</code>，<code>bbb</code>和<code>ccc</code>，如果使用线程安全的io，例如<code>puts</code>，可能出现的情况有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aaabbbccc</span><br><span class="line">aaacccbbb</span><br><span class="line">cccbbbaaa</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>但绝不会出现下面这种情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcabcabc</span><br><span class="line">aabbccabc</span><br><span class="line"><span class="comment">// ... </span></span><br></pre></td></tr></table></figure>
<p>原因就在于，<code>puts</code>是线程安全的，在对缓冲区操作前，需要加锁。</p>
<p>也存在线程不安全的IO调用，当考虑到效率问题（省去加锁和解锁的时间），并且确保只有单线程操作缓冲区时，可以使用下面的这些函数，这些函数在后面都加上了<code>_unlocked</code>，表示不加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar_unlocked</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar_unlocked</span><span class="params">(<span class="keyword">int</span> c)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc_unlocked</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc_unlocked</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread_unlocked</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                      FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="params"><span class="function">                       FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets_unlocked</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> n, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs_unlocked</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-9-线程和信号"><a href="#8-9-线程和信号" class="headerlink" title="8.9 线程和信号"></a>8.9 线程和信号</h3><p>对多线程的进程而言，只有进程级别的未决信号集<code>pending</code>，没有信号屏蔽字<code>mask</code>，而每个线程都有自己的<code>pending</code>和<code>mask</code>（线程级别）。</p>
<p>进程向进程发送信号，改变的是进程级别的<code>pending</code>，线程向线程发送信号，改变的是线程级别的<code>pending</code>。对于线程级别的信号响应，使用当前线程的<code>pending</code>和<code>mask</code>进行按位与。对于进程级别的信号响应，使用当前工作线程的<code>mask</code>和进程级别的<code>pending</code>进行按位与。</p>
<p>此前讨论了进程如何使用 <code>sigprocmask</code> 函数来阻止信号发送。然而，<code>sigprocmask</code> 的行为在多线程的进程中并没有定义，线程必须使用<code>pthread_sigmask</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改线程级别的信号屏蔽字</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向指定线程发送信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p>线程可以调用<code>sigwait</code>等待一个或多个信号的出现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待信号集set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>, <span class="keyword">int</span> *sig)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="8-10-线程与fork"><a href="#8-10-线程与fork" class="headerlink" title="8.10 线程与fork"></a>8.10 线程与fork</h3><p>暂略</p>
<h2 id="9-高级IO"><a href="#9-高级IO" class="headerlink" title="9 高级IO"></a>9 高级IO</h2><p>本节对应第十四章高级IO</p>
<h3 id="9-1-非阻塞IO"><a href="#9-1-非阻塞IO" class="headerlink" title="9.1 非阻塞IO"></a>9.1 非阻塞IO</h3><p>阻塞IO：当资源不可用的时候，应用程序就会挂起。当资源可用的时候，唤醒任务。</p>
<p>阻塞IO图示如下，应用程序调用 read 函数从设备中读取数据，当设备不可用或数据未准备好的时候就会进入到休眠态。等设备可用的时候就会从休眠态唤醒，然后从设备中读取数据返回给应用程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230101113458287.png" alt="image-20230101113458287"></p>
<p>非阻塞IO：当资源不可用的时候，应用程序轮询查看，或放弃，会有超时处理机制。</p>
<p>非阻塞IO图示如下，可以看出，应用程序使用非阻塞访问方式从设备读取数据，当设备不可用或数据未准备好的时候会立即向内核返回一个错误码，表示数据读取失败。应用程序会再次重新读取数据，这样一直往复循环，直到数据读取成功。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230101113602025.png" alt="image-20230101113602025"></p>
<h3 id="9-2-有限状态机"><a href="#9-2-有限状态机" class="headerlink" title="9.2 有限状态机"></a>9.2 有限状态机</h3><p>需求：有左右两个设备，第一个任务为读左设备，写右设备，第二个任务读右设备，写左设备。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230101115616601.png" alt="image-20230101115616601"></p>
<blockquote>
<p>代码实现</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a></div><div class="post_share"><div class="social-share" data-image="/img/linux.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/21/Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/"><img class="prev-cover" src="/img/leetcode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Leetcode刷题笔记（简单）</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80/"><img class="next-cover" src="/img/51danpianji.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">51单片机基础</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Linux系统编程学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%89%8D%E8%A8%80"><span class="toc-text">1 前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%8E%AF%E5%A2%83"><span class="toc-text">1.1 环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-GCC"><span class="toc-text">1.2 GCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-make"><span class="toc-text">1.3 make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-makefile"><span class="toc-text">1.4 makefile</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-%E4%BD%BF%E7%94%A8gcc%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">1.4.1 使用gcc的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-text">1.4.2 语法规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-POSIX"><span class="toc-text">1.5 POSIX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1.5.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-%E5%8E%86%E5%8F%B2"><span class="toc-text">1.5.2 历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-%E5%8F%AF%E7%A7%BB%E6%A4%8D%E6%80%A7"><span class="toc-text">1.5.3 可移植性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%92%8C%E5%BA%93%E5%87%BD%E6%95%B0"><span class="toc-text">① 系统调用和库函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8C%BA%E5%88%AB"><span class="toc-text">② 区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.5.4 实例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%87%E5%87%86IO"><span class="toc-text">2 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-fopen"><span class="toc-text">2.2 fopen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-fclose"><span class="toc-text">2.3 fclose</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-fgetc%E5%92%8Cfputc"><span class="toc-text">2.4 fgetc和fputc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-fgets%E5%92%8Cfputs"><span class="toc-text">2.5 fgets和fputs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-fread%E5%92%8Cfwrite"><span class="toc-text">2.6 fread和fwrite</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-printf%E5%92%8Cscanf"><span class="toc-text">2.7 printf和scanf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-fseek%E5%92%8Cftell"><span class="toc-text">2.8 fseek和ftell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-fflush"><span class="toc-text">2.9 fflush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-10-getline"><span class="toc-text">2.10 getline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6"><span class="toc-text">2.11 临时文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8IO"><span class="toc-text">3 系统调用IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">3.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">3.2 文件描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-FILE%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3.2.1 FILE结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">3.2.2 文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-open%E5%92%8Cclose"><span class="toc-text">3.3 open和close</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-text">3.3.1 文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-rwx"><span class="toc-text">① rwx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-text">② 文件属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-umask"><span class="toc-text">③ umask</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-open"><span class="toc-text">3.3.2 open</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-close"><span class="toc-text">3.3.3 close</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-read%EF%BC%8Cwrite%E5%92%8Clseek"><span class="toc-text">3.4 read，write和lseek</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-IO%E6%95%88%E7%8E%87"><span class="toc-text">3.5 IO效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E5%B8%83%E5%B1%80"><span class="toc-text">3.6 C程序的内存空间布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-1-%E5%8A%A8%E6%80%81%E5%8C%BA"><span class="toc-text">3.6.1 动态区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A0%88%E5%8C%BA"><span class="toc-text">① 栈区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%A0%86%E5%8C%BA"><span class="toc-text">② 堆区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-2-%E9%9D%99%E6%80%81%E5%8C%BA"><span class="toc-text">3.6.2 静态区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-text">① 数据区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%B8%B8%E9%87%8F%E5%8C%BA"><span class="toc-text">② 常量区</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-text">③ 代码区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-3-%E6%A0%88%E7%9A%84%E5%9C%B0%E5%9D%80%E6%B5%8B%E8%AF%95"><span class="toc-text">3.6.3 栈的地址测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-4-%E5%A0%86%E7%9A%84%E5%9C%B0%E5%9D%80%E6%B5%8B%E8%AF%95"><span class="toc-text">3.6.4 堆的地址测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-5-%E9%9D%99%E6%80%81%E5%8C%BA%E6%BC%94%E7%A4%BA"><span class="toc-text">3.6.5 静态区演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="toc-text">3.7 文件共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-dup%E5%92%8Cdup2"><span class="toc-text">3.8 dup和dup2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-fcntl%E5%92%8Cioctl"><span class="toc-text">3.9 fcntl和ioctl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-dev-fd%E7%9B%AE%E5%BD%95"><span class="toc-text">3.10 &#x2F;dev&#x2F;fd目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E8%A1%A5%E5%85%85%EF%BC%9A%E5%87%A0%E4%B8%AA%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.11 补充：几个文件的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-1-%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="toc-text">3.11.1 用户变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-2-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">3.11.2 全局变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-Linux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9E%84%E6%88%90"><span class="toc-text">4.1 Linux文件目录构成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-etc-passwd"><span class="toc-text">4.1.2 &#x2F;etc&#x2F;passwd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-etc-group"><span class="toc-text">4.1.3 &#x2F;etc&#x2F;group</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-usr-include"><span class="toc-text">4.1.4 &#x2F;usr&#x2F;include</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85-inode"><span class="toc-text">补充 inode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%AE%80%E4%BB%8B"><span class="toc-text">① 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-inode%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">② inode的信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-text">③ 相关命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-text">④ 硬链接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-text">⑤ 符号链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-text">4.2 文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-stat"><span class="toc-text">4.2.1 stat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E7%A9%BA%E6%B4%9E%E6%96%87%E4%BB%B6"><span class="toc-text">4.2.2 空洞文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-st-mode"><span class="toc-text">4.2.3 st_mode</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%AE%80%E4%BB%8B-1"><span class="toc-text">① 简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">② 实例分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%AE%8F"><span class="toc-text">③ 宏</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">④ 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-text">4.2.4 文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-umask"><span class="toc-text">① umask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-chmod"><span class="toc-text">② chmod</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E7%B2%98%E4%BD%8F%E4%BD%8D"><span class="toc-text">③ 粘住位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.2.5 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E7%A3%81%E7%9B%98%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">① 磁盘的结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-text">② 文件系统简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E9%93%BE%E6%8E%A5"><span class="toc-text">③ 链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-6-%E6%9D%82%E9%A1%B9"><span class="toc-text">4.2.6 杂项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-7-glob"><span class="toc-text">4.2.7 glob</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-text">5 进程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-main%E5%87%BD%E6%95%B0"><span class="toc-text">5.1 main函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">5.2 进程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">5.2.1 终止方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-main%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">5.2.2 main函数的返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0atexit"><span class="toc-text">5.2.3 钩子函数atexit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-4-exit%E5%92%8C-exit"><span class="toc-text">5.2.4 exit和_exit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">5.3 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4 环境变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">5.4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E6%9F%A5%E7%9C%8B%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4.2 查看环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">5.4.3 设置环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-%E7%8E%AF%E5%A2%83%E8%A1%A8"><span class="toc-text">5.4.4 环境表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="toc-text">5.5 共享库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%87%BD%E6%95%B0%E9%97%B4%E8%B7%B3%E8%BD%AC"><span class="toc-text">5.6 函数间跳转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E8%B5%84%E6%BA%90%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E6%8E%A7%E5%88%B6"><span class="toc-text">5.7 资源的获取和控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">6 进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-text">6.1 进程标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%BF%9B%E7%A8%8B%E4%BA%A7%E7%94%9F"><span class="toc-text">6.2 进程产生</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-fork"><span class="toc-text">6.2.1 fork</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-vfork"><span class="toc-text">6.2.2 vfork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-wait%E5%92%8Cwaitpid"><span class="toc-text">6.3 wait和waitpid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-text">6.4 exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">6.4.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E4%BD%BF%E7%94%A8"><span class="toc-text">6.4.2 使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-shell%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.5 shell外部命令实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%92%8C%E7%BB%84%E6%9D%83%E9%99%90"><span class="toc-text">6.6 用户权限和组权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-1-UID%E5%92%8CGID"><span class="toc-text">6.6.1 UID和GID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-2-SUID%E5%92%8CSGID"><span class="toc-text">6.6.2 SUID和SGID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-3-%E7%9B%B8%E5%85%B3%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">6.6.3 相关系统调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-text">6.7 解释器文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-system%E5%87%BD%E6%95%B0"><span class="toc-text">6.8 system函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">6.9 守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-text">6.10 系统日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BF%A1%E5%8F%B7"><span class="toc-text">7 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%89%8D%E7%BD%AE%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 前置概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">7.1 信号的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-signal%E5%87%BD%E6%95%B0"><span class="toc-text">7.3 signal函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-text">7.4 不可靠的信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">7.5 可重入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%93%8D%E5%BA%94%E8%BF%87%E7%A8%8B"><span class="toc-text">7.6 信号的响应过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-7-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E2%85%A0"><span class="toc-text">7.7 常用函数Ⅰ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-1-kill"><span class="toc-text">7.7.1 kill</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-2-raise"><span class="toc-text">7.7.2 raise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-3-alarm"><span class="toc-text">7.7.3 alarm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-4-pause"><span class="toc-text">7.7.4 pause</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-5-%E6%BC%8F%E6%A1%B6"><span class="toc-text">7.7.5 漏桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-6-%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-text">7.7.6 令牌桶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">7.8 信号集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-9-sigprocmask%E5%87%BD%E6%95%B0"><span class="toc-text">7.9 sigprocmask函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-10-sigpending%E5%87%BD%E6%95%B0"><span class="toc-text">7.10 sigpending函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-11-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E2%85%A1"><span class="toc-text">7.11 常用函数Ⅱ</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-1-sigsuspend%E5%87%BD%E6%95%B0"><span class="toc-text">7.11.1 sigsuspend函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-11-2-sigaction%E5%87%BD%E6%95%B0"><span class="toc-text">7.11.2 sigaction函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-12-%E5%AE%9E%E6%97%B6%E4%BF%A1%E5%8F%B7"><span class="toc-text">7.12 实时信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-13-%E4%BF%A1%E5%8F%B7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">7.13 信号实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-13-1-%E6%9C%AA%E5%86%B3%E5%92%8C%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">7.13.1 未决和阻塞信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-13-2-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-text">7.13.2 原理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">① 信号处理相关的数据结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">② 发送信号</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B"><span class="toc-text">8 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">8.1 线程概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-POSIX%E7%BA%BF%E7%A8%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">8.1.1 POSIX线程接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">8.1.2 进程和线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-text">① 进程控制块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%92%8C%E7%A7%81%E6%9C%89%E5%86%85%E5%AE%B9"><span class="toc-text">② 线程共享和私有内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="toc-text">8.2 线程标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-text">8.3 线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-text">8.4 线程终止</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E7%BB%88%E6%AD%A2%E6%96%B9%E5%BC%8F"><span class="toc-text">8.4.1 终止方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E6%A0%88%E7%9A%84%E6%B8%85%E7%90%86"><span class="toc-text">8.4.2 栈的清理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-text">8.4.3 线程的取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">8.5 线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BE%8B%E5%AD%90"><span class="toc-text">8.5.1 概念和例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-text">8.5.2 互斥量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">8.5.3 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-4-%E7%BA%BF%E7%A8%8B%E4%BB%A4%E7%89%8C%E6%A1%B6"><span class="toc-text">8.5.4 线程令牌桶</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">8.5.5 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-6-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">8.5.6 信号量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">8.6 线程属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7 同步属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-1-%E4%BA%92%E6%96%A5%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7.1 互斥量属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">8.7.2 条件变量属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8IO"><span class="toc-text">8.8 线程安全IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-text">8.9 线程和信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-%E7%BA%BF%E7%A8%8B%E4%B8%8Efork"><span class="toc-text">8.10 线程与fork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%AB%98%E7%BA%A7IO"><span class="toc-text">9 高级IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="toc-text">9.1 非阻塞IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">9.2 有限状态机</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>