<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C语言学习笔记 | Kisugi Takumi</title><meta name="keywords" content="C语言学习"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。C语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。尽管C语言提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的C语言程序可在包括类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2022/11/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="C语言是一门面向过程的、抽象化的通用程序设计语言，广泛应用于底层开发。C语言能以简易的方式编译、处理低级存储器。C语言是仅产生少量的机器语言以及不需要任何运行环境支持便能运行的高效率程序设计语言。尽管C语言提供了许多低级处理的功能，但仍然保持着跨平台的特性，以一个标准规格写出的C语言程序可在包括类似嵌入式处理器以及超级计算机等作业平台的许多计算机平台上进行编译。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/C.png">
<meta property="article:published_time" content="2022-11-05T06:46:25.000Z">
<meta property="article:modified_time" content="2022-11-27T11:36:59.810Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="C语言学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/C.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2022/11/05/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-27 19:36:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">68</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C语言学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-05T06:46:25.000Z" title="发表于 2022-11-05 14:46:25">2022-11-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-27T11:36:59.810Z" title="更新于 2022-11-27 19:36:59">2022-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">C语言学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>129分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C语言学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="C语言学习笔记"><a href="#C语言学习笔记" class="headerlink" title="C语言学习笔记"></a>C语言学习笔记</h1><p>学习时间：2022年11月5日</p>
<p>学习来源：C primer plus 中文版第六版</p>
<h2 id="0-编程环境搭建"><a href="#0-编程环境搭建" class="headerlink" title="0 编程环境搭建"></a>0 编程环境搭建</h2><p>IDE：<code>Visual Studio 2022</code></p>
<ul>
<li>创建一个空项目</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221105091610638.png" alt="image-20221105091610638"></p>
<ul>
<li>在资源管理器“源文件”-&gt;“添加”-&gt;“新建项”</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221105091737427.png" alt="image-20221105091737427"></p>
<ul>
<li>选择“C++文件(.cpp)”，<strong>但是文件命名以.c为后缀</strong>，如：helloWorld.c</li>
</ul>
<h2 id="1-初识C语言"><a href="#1-初识C语言" class="headerlink" title="1 初识C语言"></a>1 初识C语言</h2><p>1972年，贝尔实验室的丹尼斯·里奇（Demnis Ritch）和肯·汤普逊（Ken Thompson）在开发UNIX操作系统时设计了C语言。然而，C语言不完全是里奇突发奇想而来，他是在B语言（汤普逊发明）的基础上进行设计。</p>
<p>语言标准：美国国家标准协会（ANSI）开发了一套新标准，并于1989年正式公布。ANSI/ISO标准的最终版本通常叫作<code>C89</code>。此后又有<code>C99</code>和<code>C11</code>标准。</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221106064032394.png" alt="image-20221106064032394"></p>
<p>编程机制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C编程的基本策略是，用程序把源代码文件转换为<strong>可执行文件</strong>（其中包含可直接运行的机器语言代码）。</p>
<p>典型的C实现通过<strong>编译和链接</strong>两个步骤来完成这一过程。<strong>编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件</strong>。C 使用这种分而治之的方法方便对程序进行模块化，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。另外，<strong>链接器还将你编写的程序和预编译的库代码合并</strong>。</p>
<p>中间文件有多种形式。最普遍的一种形式，即把源代码转换为机器语言代码，并把结果放在<strong>目标代码文件</strong>（或简称目标文件）中（这里假设源代码只有一个文件）。虽然目标文件中包含机器语言代码，但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序。</p>
<ul>
<li><p>目标代码文件缺失<strong>启动代码</strong>（starrup code）。启动代码充当着程序和操作系统之间的接口。</p>
</li>
<li><p>目标代码还缺少库函数。几乎所有的C程序都要使用C标准库中的函数。例如，concrete.c中就使用了<code>printf</code>函数。目标代码文件并不包含该函数的代码，<strong>它只包含了使用printf函数的指令</strong>。printf函数真正的代码储存在另一个被称为库的文件中。库文件中有许多函数的<strong>目标代码</strong>。</p>
</li>
</ul>
<p>链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这3部分合并成一个文件，即<strong>可执行文件</strong>。</p>
<p>简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码。</p>
<h2 id="2-C语言概述"><a href="#2-C语言概述" class="headerlink" title="2 C语言概述"></a>2 C语言概述</h2><p>略</p>
<h2 id="3-数据和C"><a href="#3-数据和C" class="headerlink" title="3 数据和C"></a>3 数据和C</h2><p>复习：</p>
<ul>
<li>位（比特）：<code>bit</code>，可以存储0或1</li>
<li>字节：<code>byte</code>，<code>1 byte = 8 bits</code></li>
<li>字：<code>word</code>，设计计算机时给定的自然存储单位。常见的有8,16,32和如今的64位</li>
</ul>
<hr>
<p>C语言基本数据类型：</p>
<ul>
<li><p>C提供了3个附属关键字修饰基本数据类型：<code>short</code>,<code>long</code>和<code>unsigned</code></p>
</li>
<li><p><code>int</code>：有符号整型，一般而言，存储一个 <code>int</code> 要占用一个机器字长，早期的16位IBM PC兼容机使用 16 位（2字节）来储存一个int 值，其取值范围（即int 值的取值范围）是<code>-32768～32767</code>。目前的个人计算机一般是32位，因此用32位（4字节）储存一个int 值。现在，个人计算机产业正逐步向着64位处理器发展，自然能储存更大的整数。ISOC规定int的取值范围最小为<code>-32768～32767</code>（2字节）。</p>
</li>
<li><code>short int(short)</code>，<code>long int(long)</code>，<code>long long int(long long)</code>，<code>unsigned int(unsigned)</code>等，个人计算机上最常见的设置是，long long 占64位，long 占32位，short 占16位，int 占16位或32位（依计算机的自然字长而定）。</li>
<li><code>char</code>：存储字符，通常占8位1字节。用<strong>单引号</strong>括起来。</li>
<li><code>_Bool</code>：布尔值，占用1位。<code>_Bool</code>是C99新增的布尔类型，包含在头文件<code>stdbool.c</code>里，可以用bool表示_Bool，true表示1，false表示0，让代码与C++兼容。C99之前，用0表示假，1表示真。</li>
<li><code>float</code>，<code>double</code>，<code>long double</code>：浮点数。</li>
<li><code>_Complex</code>，<code>_Imaginary</code>：复数和虚数</li>
</ul>
<h2 id="4-字符串和格式化输入输出"><a href="#4-字符串和格式化输入输出" class="headerlink" title="4 字符串和格式化输入输出"></a>4 字符串和格式化输入输出</h2><p>略</p>
<h2 id="5-运算符、表达式和语句"><a href="#5-运算符、表达式和语句" class="headerlink" title="5 运算符、表达式和语句"></a>5 运算符、表达式和语句</h2><p>略</p>
<h2 id="6-循环"><a href="#6-循环" class="headerlink" title="6 循环"></a>6 循环</h2><p>略</p>
<h2 id="7-分支和跳转"><a href="#7-分支和跳转" class="headerlink" title="7 分支和跳转"></a>7 分支和跳转</h2><p>略</p>
<h2 id="8-字符输入输出"><a href="#8-字符输入输出" class="headerlink" title="8 字符输入输出"></a>8 字符输入输出</h2><p>略</p>
<h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9 函数"></a>9 函数</h2><h3 id="9-1-函数示例"><a href="#9-1-函数示例" class="headerlink" title="9.1 函数示例"></a>9.1 函数示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">&quot;Mark&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">&quot;China&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">&quot;Chengdu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 函数原型 function prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	starbar(); <span class="comment">// 函数调用</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, NAME);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ADDRESS);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, PLACE);</span><br><span class="line">	starbar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= WIDTH; count++) &#123;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">****************************************</span><br><span class="line">Mark</span><br><span class="line">China</span><br><span class="line">Chengdu</span><br><span class="line">****************************************</span><br></pre></td></tr></table></figure>
<h3 id="9-2-查找地址：-amp-运算符"><a href="#9-2-查找地址：-amp-运算符" class="headerlink" title="9.2 查找地址：&amp;运算符"></a>9.2 查找地址：&amp;运算符</h3><p>一元运算符<code>&amp;</code>给出变量的存储地址，如果<code>pooh</code>是变量名，则<code>&amp;pooh</code>是变量的地址。<code>&amp;</code>被称为<strong>取地址符</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pooh = <span class="number">2</span>, bah = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main(), pooh = %d and &amp;pooh = %p\n&quot;</span>, pooh, &amp;pooh); <span class="comment">// 使用%p打印地址格式</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In main(), bah = %d and &amp;bah = %p\n&quot;</span>, bah, &amp;bah);</span><br><span class="line">	mikado(pooh);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mikado</span><span class="params">(<span class="keyword">int</span> bah)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pooh = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In mikado(), pooh = %d and &amp;pooh = %p\n&quot;</span>, pooh, &amp;pooh);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In mikado(), bah = %d and &amp;bah = %p\n&quot;</span>, bah, &amp;bah);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In main(), pooh = 2 and &amp;pooh = 0000003D7DB2F5B4</span><br><span class="line">In main(), bah = 5 and &amp;bah = 0000003D7DB2F5D4</span><br><span class="line">In mikado(), pooh = 10 and &amp;pooh = 0000003D7DB2F494</span><br><span class="line">In mikado(), bah = 2 and &amp;bah = 0000003D7DB2F590</span><br></pre></td></tr></table></figure>
<p>首先，两个pooh的地址不同，两个bah的地址也不同。因此，计算机把它们看成4个独立的变量。其次，函数调用<code>mikado(pooh)</code>把实际参数（<code>main()</code>中的<code>pooh</code>）的值（<code>2</code>）传递给形式参数（<code>mikado()</code>中的<code>bah</code>）。<strong>注意，这种传递只传递了值</strong>。</p>
<blockquote>
<p>更改主调函数中的变量</p>
</blockquote>
<p>有时需要在一个函数中更改其他函数的变量，例如交换两个变量的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    swap(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = u;</span><br><span class="line">    u = v;</span><br><span class="line">    v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Originally x = 5 and y = 10.</span><br><span class="line">Now x = 5 and y = 10.</span><br></pre></td></tr></table></figure>
<p>注意main函数中两个变量的值并未交换。</p>
<h3 id="9-3-指针"><a href="#9-3-指针" class="headerlink" title="9.3 指针"></a>9.3 指针</h3><p>指针（pointer）是一个值为内存地址的变量。指针类型的变量的值是地址，正如char类型的变量的值是字符，int类型的变量的值是一个整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;pooh;</span><br></pre></td></tr></table></figure>
<p> 上述语句把pooh的地址赋给ptr，说ptr <strong>指向</strong> pooh，注意<code>ptr</code>是指针类型的<strong>变量</strong>，而<code>$pooh</code>是一个<strong>地址常量</strong>，本质为十六进制数。或者说，ptr是<strong>可修改的左值</strong>。</p>
<h4 id="9-3-1-间接运算符："><a href="#9-3-1-间接运算符：" class="headerlink" title="9.3.1 间接运算符：*"></a>9.3.1 间接运算符：*</h4><p><code>*</code>：称为<strong>间接运算符</strong>，或<strong>解引用运算符</strong>，用于找出指针指向地址的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;bah;</span><br><span class="line">val = *ptr;</span><br><span class="line"><span class="comment">// 相当于：</span></span><br><span class="line">val = bah;</span><br></pre></td></tr></table></figure>
<h4 id="9-3-2-声明指针"><a href="#9-3-2-声明指针" class="headerlink" title="9.3.2 声明指针"></a>9.3.2 声明指针</h4><p>略，详见<code>10.3</code>小节</p>
<h4 id="9-3-3-使用指针在函数间通信"><a href="#9-3-3-使用指针在函数间通信" class="headerlink" title="9.3.3 使用指针在函数间通信"></a>9.3.3 使用指针在函数间通信</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>, x, y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Originally x = 5 and y = 10.</span><br><span class="line">Now x = 10 and y = 5.</span><br></pre></td></tr></table></figure>
<h2 id="10-指针和数组"><a href="#10-指针和数组" class="headerlink" title="10 指针和数组"></a>10 指针和数组</h2><h3 id="10-1-数组"><a href="#10-1-数组" class="headerlink" title="10.1 数组"></a>10.1 数组</h3><h4 id="10-1-1-数组的声明"><a href="#10-1-1-数组的声明" class="headerlink" title="10.1.1 数组的声明"></a>10.1.1 数组的声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> candy[<span class="number">365</span>]; <span class="comment">// 声明一个大小为365的float数组，索引范围是0~364，即0~sizeof(candy)-1</span></span><br><span class="line"><span class="keyword">char</span> code[<span class="number">12</span>];</span><br><span class="line"><span class="keyword">int</span> states[<span class="number">50</span>];</span><br></pre></td></tr></table></figure>
<h4 id="10-1-2-初始化数组"><a href="#10-1-2-初始化数组" class="headerlink" title="10.1.2 初始化数组"></a>10.1.2 初始化数组</h4><blockquote>
<p>一般形式</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="keyword">int</span> arr1[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="keyword">int</span> arr2[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">// 如果初始化数组时省略大小，编译器会根据初始化列表中的项数来决定该数组的大小</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果不初始化数组，数组元素和未初始化的普通变量一样，存储的都是垃圾值。即编译器使用的值是内存相应位置上的现有值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no_data[SIZE];<span class="comment">// 未初始化数组</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 注意这句格式化输出的含义：</span></span><br><span class="line">    <span class="comment">// 1.&quot;i&quot;和&quot;no_data[i]&quot;是输出参数（字符串类型），分别对应了前面的两个输出控制符</span></span><br><span class="line">    <span class="comment">// 2.数字代表最小字段宽度：如果该字段不能容纳待打印的数字或字符串，系统会使用更宽的字段，否则用空格补齐</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2s%14s\n&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;no_data[i]&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,no_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223744390.png" alt="image-20211215223744390"></p>
<ul>
<li>如果部分初始化数组，剩余的元素会被初始化为0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no_data[SIZE]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;<span class="comment">// 未初始化数组</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%2s%14s\n&quot;</span>,<span class="string">&quot;i&quot;</span>,<span class="string">&quot;no_data[i]&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SIZE; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d%14d\n&quot;</span>,i,no_data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223800875.png" alt="image-20211215223800875"></p>
<ul>
<li>如果初始化列表的项数多于数组元素个数，编译器会报错。</li>
</ul>
<h4 id="10-1-3-指定初始化器-C99标准"><a href="#10-1-3-指定初始化器-C99标准" class="headerlink" title="10.1.3 指定初始化器 C99标准"></a>10.1.3 指定初始化器 C99标准</h4><p>C99特性：指定初始化器。利用该特性可以初始化指定的数组元素，例如只初始化最后一个元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">6</span>]=&#123;[<span class="number">5</span>]=<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果指定初始化器后面有更多的值，会依次将这些值赋给初始化指定元素后面的元素。</li>
<li>如果再次初始化指定的元素，那么<code>最后</code>的初始化将会取代之前的初始化。</li>
<li>如果未指定数组大小，编译器会把数组的大小设置为足够装得下初始化的值。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MONTHS 12</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days[MONTHS]=&#123;<span class="number">31</span>,<span class="number">28</span>,[<span class="number">4</span>]=<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,[<span class="number">1</span>]=<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MONTHS;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%2d %d\n&quot;</span>,i+<span class="number">1</span>,days[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223807797.png" alt="image-20211215223807797"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr1[] = &#123;<span class="number">1</span>,[<span class="number">6</span>]=<span class="number">1</span>&#125;;<span class="comment">// 数组大小会被设定为7</span></span><br><span class="line"><span class="keyword">int</span> arr2[] = &#123;<span class="number">1</span>,[<span class="number">6</span>]=<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;<span class="comment">// 数组大小会被设定为9</span></span><br></pre></td></tr></table></figure>
<h4 id="10-1-4-为数组元素赋值"><a href="#10-1-4-为数组元素赋值" class="headerlink" title="10.1.4 为数组元素赋值"></a>10.1.4 为数组元素赋值</h4><ul>
<li>C不允许把数组作为一个单元赋给另一个数组</li>
<li>除初始化以外，不允许使用花括号列表的形式赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[SIZE]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">// 此句为声明和初始化，剩余元素初始化为0，没有问题</span></span><br><span class="line">    <span class="keyword">int</span> b[SIZE];<span class="comment">// 数组声明，没有问题</span></span><br><span class="line">    b=a;<span class="comment">// 不允许这样赋值</span></span><br><span class="line">    b[SIZE]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">// 不允许这样赋值</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-1-5-数组边界"><a href="#10-1-5-数组边界" class="headerlink" title="10.1.5 数组边界"></a>10.1.5 数组边界</h4><p>C不检查边界。不检查边界可以使C的运行速度更快。</p>
<h4 id="10-1-6-指定数组的大小"><a href="#10-1-6-指定数组的大小" class="headerlink" title="10.1.6 指定数组的大小"></a>10.1.6 指定数组的大小</h4><p>在C99之前，声明数组时只能在方括号中使用<code>整型常量表达式</code>。而C99标准允许变长数组，即声明数组大小时可以使用变量，变长数组简称为VLA，C11放弃了这一设定，将其设为可选操作，而不是C必备的特性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> a1[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> a2[<span class="number">5</span>*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a3[<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> a4[<span class="number">-4</span>];<span class="comment">// 不被允许，数组大小必须大于0</span></span><br><span class="line">    <span class="keyword">int</span> a5[<span class="number">0</span>];<span class="comment">// 不被允许</span></span><br><span class="line">    <span class="keyword">int</span> a6[<span class="number">2.5</span>];<span class="comment">// 不被允许，必须为整数</span></span><br><span class="line">    <span class="keyword">int</span> a7[(<span class="keyword">int</span>)<span class="number">2.5</span>];<span class="comment">// 允许，已将2.5强制转换为int</span></span><br><span class="line">    <span class="keyword">int</span> a8[m];<span class="comment">// C99允许</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-多维数组"><a href="#10-2-多维数组" class="headerlink" title="10.2 多维数组"></a>10.2 多维数组</h3><blockquote>
<p>二维数组的声明和初始化</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">// 声明一个3行4列的二维数组</span></span><br><span class="line"><span class="comment">// arr[0]也是个数组，是一维数组，具有4个数组元素</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">&#125;;<span class="comment">// 声明并初始化一个2行2列的二维数组</span></span><br></pre></td></tr></table></figure>
<p>以上的初始化使用了2个数值列表，每个列表用花括号括起来。</p>
<p>也可以省略内部的花括号，按行优先的顺序进行初始化，若初始化的数值不够时，用0进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>]=&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// arr[1][1]和arr[1][2]为0</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">2</span>][<span class="number">3</span>]=&#123;&#123;<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// arr[0][2]和arr[1][2]为0</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3-数组和指针"><a href="#10-3-数组和指针" class="headerlink" title="10.3 数组和指针"></a>10.3 数组和指针</h3><h4 id="10-3-1-指针简介"><a href="#10-3-1-指针简介" class="headerlink" title="10.3.1 指针简介"></a>10.3.1 指针简介</h4><blockquote>
<p>指针的概念</p>
</blockquote>
<p>指针是一个值为内存地址的变量。在大部分系统中，地址由一个无符号整数表示，但是不要认为指针就是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。指针实际上是一个新类型，不是整数类型。ANSI C专门为指针提供了<code>%p</code>格式的转换说明（输入输出控制参数）。</p>
<p>假设一个指针变量名时ptr</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;pooh;<span class="comment">// 把pooh的地址赋给ptr，此处的区别是，ptr是变量，而&amp;pooh是常量</span></span><br><span class="line">ptr = &amp;bah;<span class="comment">// 现在，ptr的值变成了bah的地址</span></span><br></pre></td></tr></table></figure>
<p><strong>指针变量的值是地址</strong>，或者说，<strong>指针变量指向了该地址</strong>。</p>
<blockquote>
<p>间接运算符：*</p>
</blockquote>
<p>间接运算符<code>*</code>也被称为<code>解引用运算符</code>。作用是找出存储在某个地址中的值。后跟一个指针名或地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nurse = <span class="number">22</span>;</span><br><span class="line">ptr = &amp;nurse;<span class="comment">// 指向nurse的指针</span></span><br><span class="line">val = *ptr;<span class="comment">// 把ptr指向的地址上的值赋给val</span></span><br><span class="line"><span class="comment">// 以上三条语句的最终结果同：val = nurse; 或者 val = *(&amp;nurse)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>地址运算符：&amp;</p>
</blockquote>
<p>后跟一个变量名时，&amp;给出该变量的地址。例如&amp;nurse表示变量nurse的地址。</p>
<blockquote>
<p>声明指针</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi;</span><br><span class="line"><span class="keyword">float</span> * pf, *pg;</span><br><span class="line"><span class="keyword">char</span> * pc;</span><br></pre></td></tr></table></figure>
<ul>
<li>类型说明符表明了指针所指向对象的类型，星号表明声明的变量是一个指针。</li>
<li>*和指针名之间的空格可有可无，一般而言，声明时使用空格，在解引用变量时省略空格。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> * ptr;<span class="comment">// 先声明指针</span></span><br><span class="line">    ptr = &amp;i;<span class="comment">// 再赋值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> * ptr = &amp;i;<span class="comment">// 声明指针并初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：上面两个程序是相同的</p>
<h4 id="10-3-2-数组和指针的关系"><a href="#10-3-2-数组和指针的关系" class="headerlink" title="10.3.2 数组和指针的关系"></a>10.3.2 数组和指针的关系</h4><blockquote>
<p>关系</p>
</blockquote>
<p>数组名就是数组<code>首元素的地址</code>。假设arr是一个数组，则有：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr和&amp;arr[0]都是常量</span></span><br><span class="line">arr == &amp;arr[<span class="number">0</span>];<span class="comment">// 数组名就是首元素的地址。arr[0]是首元素，*arr[0]是取出首元素的地址</span></span><br><span class="line">arr+<span class="number">2</span> == &amp;arr[<span class="number">2</span>];<span class="comment">// arr+2后的地址就是arr数组中第三个元素的首地址，即&amp;arr[2]</span></span><br><span class="line">*(arr+<span class="number">2</span>) == arr[<span class="number">2</span>];<span class="comment">// *就取出了首地址加2后的地址中存储的值，即arr[3]</span></span><br></pre></td></tr></table></figure>
<p>程序示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[SIZE]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)&#123;</span><br><span class="line">      	<span class="comment">// 下面注释处左侧为指针表示法，右侧为数组表示法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,*(arr+i));<span class="comment">// *(arr+i) == arr[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着，数组的表示方法就有两种了，一种是原始的表达方法，一种是利用指针的表示方法。</p>
<blockquote>
<p>指针的加减</p>
</blockquote>
<p>地址按字节编址。<strong>指针加1指的是增加一个存储单元，即指针的值递增它所指向类型的大小（以字节为单位）</strong>。对数组而言，加1的地址是下一个元素的地址，而不是下一个字节的地址，二者是等价的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> arr[SIZE];</span><br><span class="line">    <span class="keyword">short</span> * ptr;</span><br><span class="line">    ptr = arr;<span class="comment">// 把数组首元素的地址赋给指针变量ptr</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%23s\n&quot;</span>,<span class="string">&quot;short&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> index=<span class="number">0</span>;index&lt;SIZE;index++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pointers + %d: %10p\n&quot;</span>,index,ptr+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223822611.png" alt="image-20211215223822611"></p>
<p>解读：<code>60FF20</code>是short数组首元素的地址，也是ptr指向的地址。加1后，因为short占用2字节，所以第一个元素的地址范围是<code>60FF20~60FF21</code>，因此第二个元素的首地址为<code>60FF22</code>，也就是指针加1后的值。</p>
<h3 id="10-4-指针与函数"><a href="#10-4-指针与函数" class="headerlink" title="10.4 指针与函数"></a>10.4 指针与函数</h3><h4 id="10-4-1-使用指针在函数间通信"><a href="#10-4-1-使用指针在函数间通信" class="headerlink" title="10.4.1 使用指针在函数间通信"></a>10.4.1 使用指针在函数间通信</h4><p>一般而言，可以把变量相关的两类信息传递给函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function1</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">function2</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span></span><br></pre></td></tr></table></figure>
<p>如果要计算值或处理值，那么使用第一种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第二种形式的函数调用。<strong>第二种函数调用传过去的值必须是变量的地址</strong>，需要用指针ptr来接收，相当于语句（若传过去的是&amp;x）：<code>int * ptr = &amp;x</code>。</p>
<p>下面的程序的功能是交换x，y的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型，其中的形参名u和v可以省略，但是在函数定义中，形参名不可省略</span></span><br><span class="line"><span class="comment">// void interchange(int *,int *);也可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u, <span class="keyword">int</span> * v)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Originally x = %d and y = %d.\n&quot;</span>,x,y);</span><br><span class="line">    interchange(&amp;x,&amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Now x = %d and y = %d.\n&quot;</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interchange</span><span class="params">(<span class="keyword">int</span> * u,<span class="keyword">int</span> * v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    temp = *u;</span><br><span class="line">    *u = *v;</span><br><span class="line">    *v = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223833072.png" alt="image-20211215223833072"></p>
<h4 id="10-4-2-函数，数组和指针"><a href="#10-4-2-函数，数组和指针" class="headerlink" title="10.4.2 函数，数组和指针"></a>10.4.2 函数，数组和指针</h4><p>编写一个处理数组的函数，该函数返回数组所有元素之和，待处理的是名为<code>arr</code>的<code>int</code>类型数组，则可能的函数调用为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> total = sum(arr);</span><br></pre></td></tr></table></figure>
<p>注意：数组名是该数组首元素的地址，因此，实际参数<code>arr</code>是一个存储<code>int</code>类型值的<code>地址</code>，则应该把它赋给一个指针类型的参数，那么该函数原型应为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> * ptr)</span></span>;</span><br><span class="line"><span class="comment">// 形式2，这种形式仍然把arr同形式1的ptr等价起来，即arr是一个指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></table></figure>
<p>程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// 形式2：int sum(int *,int n);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[SIZE] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">long</span> total = sum(arr,SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum of the arr is %ld.\n&quot;</span>,total);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of the arr is %zd bytes.\n&quot;</span>,<span class="keyword">sizeof</span> arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 形式2：int sum(int * ar,int n)&#123;...&#125;</span></span><br><span class="line"><span class="comment">// 注意这里的ar不是arr数组本身，而是指向数组首元素地址的指针</span></span><br><span class="line"><span class="comment">// 相当于语句：int * ar = arr;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">        total += ar[i];</span><br><span class="line">      	<span class="comment">// total += *(ar+i);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The size of ar is %zd bytes.\n&quot;</span>,<span class="keyword">sizeof</span> ar);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223842006.png" alt="image-20211215223842006"></p>
<p>注意：ar是指向数组首元素地址的指针，类型为<code>int</code>，所以占用字节为4字节。</p>
<h3 id="10-5-指针操作"><a href="#10-5-指针操作" class="headerlink" title="10.5 指针操作"></a>10.5 指针操作</h3><p>以下程序涉及到多个指针的操作，打印出了指针的值（该指针指向的地址），存储在指针指向地址上的值，以及指针自己的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> * ptr1, * ptr2, * ptr3;</span><br><span class="line">    ptr1 = arr;<span class="comment">// 把arr[0]地址赋给指针</span></span><br><span class="line">    ptr2 = &amp;arr[<span class="number">2</span>];<span class="comment">// 把arr[2]地址赋给指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针存储的地址  指针指向地址的值  指针的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointer value, dereferenced pointer, pointer address:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\n&quot;</span>,ptr1,*ptr1,&amp;ptr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针加法</span></span><br><span class="line">    ptr3 = ptr1 + <span class="number">4</span>;<span class="comment">// ptr3移动4个int大小的位置，即移动到arr[5]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nadding an int to a pointer:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr1 + 4 = %p, *(ptr1 + 4) = %d\n&quot;</span>, ptr3,*ptr3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221106115749473.png" alt="image-20221106115749473"></p>
<ul>
<li>赋值：可以地址赋给指针，例如用数组名，带地址运算符的变量名，另一个指针进行赋值。</li>
<li>解引用</li>
<li>取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，取址运算符给出了指针本身的地址。</li>
<li>指针与整数相加（减）：整数会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与指针指向的初始地址相加。</li>
<li>递增（减）指针</li>
<li>指针求差：指针求差可以求出两个元素之间的距离，差值的单位与指针所指的类型的单位相同。</li>
</ul>
<blockquote>
<p>千万不要解引用未初始化的指针！</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;<span class="comment">// 未初始化的指针</span></span><br><span class="line">*ptr = <span class="number">5</span>;<span class="comment">// 严重的错误</span></span><br></pre></td></tr></table></figure>
<p>第二行的意思是将5存储在ptr所指向的地址，但是ptr未被初始化，其值是一个随机值，所以不知道将5存在何处，这可能不会出什么错误，也可能擦写数据或代码，也可能导致程序崩溃。</p>
<h3 id="10-6-保护数组中的数据"><a href="#10-6-保护数组中的数据" class="headerlink" title="10.6 保护数组中的数据"></a>10.6 保护数组中的数据</h3><h4 id="10-6-1-对形式参数使用const"><a href="#10-6-1-对形式参数使用const" class="headerlink" title="10.6.1 对形式参数使用const"></a>10.6.1 对形式参数使用<code>const</code></h4><p>如果函数的意图不是修改数组中的数据内容（例如只求出数组中所有元素之和），那么在函数原型和函数定义中声明形式参数时应该使用关键字<code>const</code>，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>;<span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">//函数定义</span></span><br><span class="line">	<span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    	total += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，如果编写的函数需要修改数组，在声明数组形参时不使用<code>const</code>，反之则最好使用<code>const</code>。</p>
<p>下面的程序有两个函数，一个函数是只打印出数组的元素，一个函数是将原数组的每个元素都乘以一个固定的常数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 5</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> ar[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用数组的每个数乘以某个固定的常量</span></span><br><span class="line"><span class="comment"> * @param ar</span></span><br><span class="line"><span class="comment"> * @param n</span></span><br><span class="line"><span class="comment"> * @param mult</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mult_array</span><span class="params">(<span class="keyword">double</span> ar[],<span class="keyword">int</span> n,<span class="keyword">double</span> mult)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> arr[SIZE]=&#123; <span class="number">20.0</span>, <span class="number">17.66</span>, <span class="number">8.2</span>, <span class="number">13.2</span>, <span class="number">9.9</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The original arr is:\n&quot;</span>);</span><br><span class="line">    show_array(arr,SIZE);</span><br><span class="line">    mult_array(arr,SIZE,<span class="number">0.2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The arr after calling mult_array():\n&quot;</span>);</span><br><span class="line">    show_array(arr,SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_array</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> arr[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%8.3f &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mult_array</span><span class="params">(<span class="keyword">double</span> arr[],<span class="keyword">int</span> n,<span class="keyword">double</span> mult)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        arr[i] *= mult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223851335.png" alt="image-20211215223851335"></p>
<h4 id="10-6-2-关键字const的其它内容"><a href="#10-6-2-关键字const的其它内容" class="headerlink" title="10.6.2 关键字const的其它内容"></a>10.6.2 关键字<code>const</code>的其它内容</h4><ul>
<li>可以创建<code>const</code>的数组，指针和指向<code>const</code>的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * ptr;<span class="comment">// 指向const的指针</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr;<span class="comment">// const的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> ptr; <span class="comment">// 指向const的const指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>指向<code>const</code>的指针不能用于改变值，但是可以改变指针指向的地址。<code>const</code>指针不能改变其指向的地址。指向<code>const</code>的<code>const</code>指针既不能改变值，也不能改变指向的地址.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> arr[<span class="number">3</span>] = &#123; <span class="number">1.2</span>, <span class="number">3.6</span>, <span class="number">4.8</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * ptr1 = arr;</span><br><span class="line">*ptr = <span class="number">1.0</span>;<span class="comment">// 不允许，不能改变指针的值</span></span><br><span class="line">ptr1++;<span class="comment">// 让ptr1指向arr[1]，允许</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> * <span class="keyword">const</span> ptr2 = arr;</span><br><span class="line">ptr2 = &amp;arr[<span class="number">1</span>];<span class="comment">// 不允许，因为该指针不能指向别处</span></span><br><span class="line">*ptr2 = <span class="number">99.9</span>;<span class="comment">//允许改变值</span></span><br></pre></td></tr></table></figure>
<h3 id="10-7-指针与多维数组"><a href="#10-7-指针与多维数组" class="headerlink" title="10.7 指针与多维数组"></a>10.7 指针与多维数组</h3><h4 id="10-7-1-指向二维数组的指针"><a href="#10-7-1-指向二维数组的指针" class="headerlink" title="10.7.1 指向二维数组的指针"></a>10.7.1 指向二维数组的指针</h4><blockquote>
<p>关系推导<code>（重要）</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>数组名<code>array</code>是该二维数组的首元素的地址，首元素仍是一个数组，一维数组，含有2个<code>int</code>类型的元素。因此<code>array</code>是这个内含两个<code>int</code>值的数组的地址。</li>
<li><code>array</code>的值与<code>&amp;array[0]</code>和<code>array[0]</code>的值相同。<code>array[0]</code>本身是一个含有两个<code>int</code>元素的一维数组，因此<code>array[0]</code>的值和它首元素（一个整数）的地址（即<code>&amp;array[0][0]</code>）相同。但是注意：<code>array[0]</code>是一个占用一个int大小对象的地址，而<code>array</code>是一个占用两个int大小对象的地址，尽管二者的值是相同的。</li>
<li>给指针或地址加1，其值会增加对应类型大小的数值，在这方面，<code>array</code>和<code>array[0]</code>不同，前者增加2个int大小，后者增加1个int大小。也就是array+1的意思是从array[0]位移到了array[1]，而array[0]+1的意思是从<code>array[0][0]</code>位移到了<code>array[0][1]</code>。</li>
<li><code>array</code>是==地址的地址==，需要两次解引用才可得到值。<code>**array</code>与<code>*&amp;array[0][0]</code>等价，也就是<code>array[0][0]</code>。<code>*(array[0])</code>与<code>array[0][0]</code>等价。</li>
</ul>
<p>阅读下面代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">2</span>]=&#123;</span><br><span class="line">        &#123;<span class="number">2</span>,<span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>,<span class="number">7</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   array = %p,    array[0]  = %p,    &amp;array[0] = %p\n&quot;</span>,<span class="built_in">array</span>,<span class="built_in">array</span>[<span class="number">0</span>],&amp;<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   array = %p,    array + 1 = %p\n&quot;</span>,<span class="built_in">array</span>,<span class="built_in">array</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0] = %p, array[0] + 1 = %p\n&quot;</span>,<span class="built_in">array</span>[<span class="number">0</span>],<span class="built_in">array</span>[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *array = %p,   *array + 1 = %p\n&quot;</span>,*<span class="built_in">array</span>,*<span class="built_in">array</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;array[0][0] = %d\n&quot;</span>,<span class="built_in">array</span>[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *array[0] = %d\n&quot;</span>,*<span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    **array = %d\n&quot;</span>,**<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      array[2][1] = %d\n&quot;</span>,<span class="built_in">array</span>[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(*(array+2) + 1) = %d\n&quot;</span>,*(*(<span class="built_in">array</span>+<span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223901319.png" alt="image-20211215223901319"></p>
<p>注意：<code>*(*(array+2) + 1)</code>等价于<code>array[2][1]</code></p>
<p>分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 二维数组首元素的地址，每个元素都是包含两个int的一维数组</span></span><br><span class="line"><span class="comment">// array+2 二维数组第三个元素的地址，即一维数组&#123;1,3&#125;的地址，但不是该一维数组的地址</span></span><br><span class="line"><span class="comment">// *(array+2) 一维数组&#123;1,3&#125;的地址</span></span><br><span class="line"><span class="comment">// *(array+2)+1 一维数组&#123;1,3&#125;的第二个元素的地址</span></span><br><span class="line"><span class="comment">// *(*(array+2)+1) 取出该地址中的值，即3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*(*(array+2) + 1) = %d\n&quot;</span>,*(*(<span class="built_in">array</span>+<span class="number">2</span>) + <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指向二维数组的指针</p>
</blockquote>
<p>声明一个指向二维数组的指针变量ptr：ptr必须指向一个含x个某类型的数组，而不是指向一个某类型值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (* ptr)[<span class="number">2</span>]; <span class="comment">//声明一个ptr指向内含两个int类型值的数组</span></span><br></pre></td></tr></table></figure>
<p>程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">4</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;,</span><br><span class="line">            &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> (* ptr)[<span class="number">3</span>];</span><br><span class="line">    ptr = <span class="built_in">array</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   ptr = %p,    ptr + 1 = %p\n&quot;</span>,ptr,ptr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr[0] = %p, ptr[0] + 1 = %p\n&quot;</span>,ptr[<span class="number">0</span>],ptr[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *ptr = %p,   *ptr + 1 = %p\n&quot;</span>,*ptr,*ptr+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ptr[0][0] = %d\n&quot;</span>,ptr[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *ptr[0] = %d\n&quot;</span>,*ptr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    **ptr = %d\n&quot;</span>,**ptr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ptr[2][1] = %d\n&quot;</span>,ptr[<span class="number">2</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*(*(ptr+2) + 1) = %d\n&quot;</span>,*(*(ptr+<span class="number">2</span>) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223910381.png" alt="image-20211215223910381"></p>
<p>注意：虽然ptr是一个指针，不是数组名，但是也可以使用<code>ptr[2][1]</code>这样的写法。</p>
<p>以下表示等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[m][n] == *(*(<span class="built_in">array</span> + m) + n);<span class="comment">// 数组表示法</span></span><br><span class="line">ptr[m][n] == *(*(ptr + m) + n);<span class="comment">// 指针表示法</span></span><br></pre></td></tr></table></figure>
<h4 id="10-7-2-指针的兼容性"><a href="#10-7-2-指针的兼容性" class="headerlink" title="10.7.2 指针的兼容性"></a>10.7.2 指针的兼容性</h4><ul>
<li>两个类型的指针不能相互转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="keyword">int</span> * p1 = &amp;n;</span><br><span class="line"><span class="keyword">double</span> * p2 = &amp;x;</span><br><span class="line">x = n;<span class="comment">// 隐式类型转换</span></span><br><span class="line">p2 = p1;<span class="comment">// 编译时错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>更复杂的类型也是如此：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pt;</span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ar1[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ar2[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> **p2;<span class="comment">// 一个指向指针的指针</span></span><br><span class="line"><span class="comment">//-----------------------------------</span></span><br><span class="line">pt = &amp;ar1[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">// 都是指向int的指针</span></span><br><span class="line">pt = ar1[<span class="number">0</span>];<span class="comment">// 都是指向int的指针</span></span><br><span class="line">pt = ar1;<span class="comment">// 无效</span></span><br><span class="line">pa = ar1;<span class="comment">// 都是指向内含3个int类型元素数组的指针</span></span><br><span class="line">pa = ar2;<span class="comment">// 无效</span></span><br><span class="line">p2 = &amp;pt;<span class="comment">// 都是指向int *的指针</span></span><br><span class="line">*p2 = ar2[<span class="number">0</span>];<span class="comment">// 都是指向int的指针</span></span><br><span class="line">p2 = ar2;<span class="comment">// 无效</span></span><br></pre></td></tr></table></figure>
<h4 id="10-7-3-函数和多维数组"><a href="#10-7-3-函数和多维数组" class="headerlink" title="10.7.3 函数和多维数组"></a>10.7.3 函数和多维数组</h4><ul>
<li>设arr是一个3行4列的二维数组，那么arr[i]就是一个一维数组，可将其视为二维数组中的一行，数组名arr实质上是一个指向内含4个int的数组的指针。声明的函数原型格式应当如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> (*pt)[<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"><span class="comment">// 形式2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> pt[][<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"><span class="comment">// 错误的形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> pt[][],<span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"><span class="comment">// 一般而言，对多维数组只能省略最左边方括号里的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> pt[][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>],<span class="keyword">int</span> rows)</span></span>;<span class="comment">// 形参为四维数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> (*pt)[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COLS 4</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_rows</span><span class="params">(<span class="keyword">int</span> arr[][COLS],<span class="keyword">int</span> rows)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_cols</span><span class="params">(<span class="keyword">int</span> [][COLS],<span class="keyword">int</span>)</span></span>;<span class="comment">// 省略参数名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d</span><span class="params">(<span class="keyword">int</span> (*arr)[COLS],<span class="keyword">int</span> rows)</span></span>;<span class="comment">// 另一种语法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[ROWS][COLS]=&#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    sum_rows(arr,ROWS);</span><br><span class="line">    sum_cols(arr,ROWS);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum of all elements = %d\n&quot;</span>,sum_2d(arr,ROWS));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算二维数组每行元素之和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_rows</span><span class="params">(<span class="keyword">int</span> arr[][COLS],<span class="keyword">int</span> rows)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_rows;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;rows;r++)&#123;</span><br><span class="line">        total_rows=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;COLS;c++)&#123;</span><br><span class="line">            total_rows+=arr[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;row %d: sum = %d\n&quot;</span>,r,total_rows);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二维数组每列元素之和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_cols</span><span class="params">(<span class="keyword">int</span> arr[][COLS],<span class="keyword">int</span> rows)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total_cols;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;COLS;c++)&#123;</span><br><span class="line">        total_cols=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;rows;r++)&#123;</span><br><span class="line">            total_cols+=arr[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;col %d: sum = %d\n&quot;</span>,c,total_cols);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二维数组之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_2d</span><span class="params">(<span class="keyword">int</span> (*arr)[COLS],<span class="keyword">int</span> rows)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;rows;r++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;COLS;c++)&#123;</span><br><span class="line">            total+=arr[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223920655.png" alt="image-20211215223920655"></p>
<h3 id="10-8-变长数组VLA"><a href="#10-8-变长数组VLA" class="headerlink" title="10.8 变长数组VLA"></a>10.8 变长数组VLA</h3><p>注意：变长数组中的变不是指可以修改已创建数组的大小。一旦创建变长数组，它的大小不能够改变，这里的变是指在创建数组时，可以使用变量指定数组的维度。</p>
<ul>
<li>声明一个带二维变长数组参数的函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形参rows和cols必须声明在变长数组ar之前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> ar[rows][cols])</span></span>;</span><br><span class="line"><span class="comment">// 无效的声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ar[rows][cols],<span class="keyword">int</span> rows,<span class="keyword">int</span> cols)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>变长数组允许动态分配</li>
</ul>
<h3 id="10-9-复合字面量-C99"><a href="#10-9-复合字面量-C99" class="headerlink" title="10.9 复合字面量 C99"></a>10.9 复合字面量 C99</h3><p>字面量是指除符号常量（如<code>define</code>和枚举类型）以外的常量。例如5是<code>int</code>类型字面量，81.3是<code>double</code>类型的字面量，<code>’Y’</code>是<code>char</code>类型的字面量。</p>
<ul>
<li>复合字面量类似数组初始化列表，前面是用括号括起来的类型名。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125; <span class="comment">// 复合字面量，也叫匿名数组</span></span><br><span class="line">(<span class="keyword">int</span> [])&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; <span class="comment">// 大小可以省略</span></span><br></pre></td></tr></table></figure>
<ul>
<li>因为复合字面量是匿名的，因此必须在创建的同时使用它。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> [<span class="number">3</span>])&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>本例中，*ptr是10，ptr[1]是20，这时可把ptr既可看作是指针，又可看作该匿名数组的数组名。</p>
<ul>
<li>还可以把复合字面量作为实际参数传给函数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> arr[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="keyword">int</span> total = sum((<span class="keyword">int</span> [])&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>复合字面量是提供只临时需要的值的一种手段。</li>
</ul>
<h2 id="11-字符串和字符串函数"><a href="#11-字符串和字符串函数" class="headerlink" title="11 字符串和字符串函数"></a>11 字符串和字符串函数</h2><h3 id="11-1-字符串简介"><a href="#11-1-字符串简介" class="headerlink" title="11.1 字符串简介"></a>11.1 字符串简介</h3><p>字符串是一个或多个字符的序列。</p>
<h4 id="11-1-1-char类型数组和null字符"><a href="#11-1-1-char类型数组和null字符" class="headerlink" title="11.1.1 char类型数组和null字符"></a>11.1.1 char类型数组和null字符</h4><p>C语言没有专门用于存储字符串的变量类型，字符串都是存储在char类型的数组中（称之为派生类型）。每个字符串的末尾都以<code>\0</code>结尾，表示字符串的结束，称之为<strong>空字符</strong>。这是<strong>非打印字符</strong>，其ASCII值为0；</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot;You are an extraordinary being.&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name? &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);<span class="comment">// 注意没有&amp;，因为数组名就代表了地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s. %s\n&quot;</span>,name,PRAISE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223929804.png" alt="image-20211215223929804"></p>
<p>注意：<code>scanf()</code>只读取了<code>Zeng Hongyi</code>的前半段，因为它在遇到第一个空白（空格，制表符或换行符）时就不再读取输入。</p>
<h4 id="11-1-2-strlen-函数"><a href="#11-1-2-strlen-函数" class="headerlink" title="11.1.2 strlen()函数"></a>11.1.2 <code>strlen()</code>函数</h4><p><code>strlen()</code>给出字符串的长度（<strong>不过包括末尾的结束</strong>），头文件<code>string.h</code>给出了多个与字符串相关的函数原型，当然也给出了该函数的原型。</p>
<blockquote>
<p>程序实例——strlen和sizeof的区别</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAISE <span class="meta-string">&quot;You are an extraordinary being.&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">40</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s your name? &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s. %s\n&quot;</span>,name,PRAISE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your name of %zd letters occupies %zd memory cells.\n&quot;</span>,<span class="built_in">strlen</span>(name),<span class="keyword">sizeof</span> name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The phase of praise has %zd letters &quot;</span>,<span class="built_in">strlen</span>(PRAISE));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;and occupies %zd memory cells.\n&quot;</span>,<span class="keyword">sizeof</span> PRAISE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>C99和C10标准专门为<code>sizeof</code>运算符的返回类型添加了<code>%zd</code>转换说明，同样也适用于<code>strlen</code>，但两者返回的实际类型通常是<code>unsigned</code>或<code>unsigned long</code>，也可使用<code>%u</code>或<code>%lu</code>接收</li>
<li>注意比较两者的不同</li>
</ul>
<h3 id="11-2-表示字符串和字符串IO"><a href="#11-2-表示字符串和字符串IO" class="headerlink" title="11.2 表示字符串和字符串IO"></a>11.2 表示字符串和字符串IO</h3><blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">&quot;I am a symbolic string constant&quot;</span> <span class="comment">//字符串常量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLENGTH 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[MAXLENGTH] = <span class="string">&quot;I am a string in an array.&quot;</span>;<span class="comment">// char类型数组</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * ptr = <span class="string">&quot;Something is pointing at me.&quot;</span>;<span class="comment">// 指向char的指针</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Here are some strings:&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(MSG);</span><br><span class="line">    <span class="built_in">puts</span>(words);</span><br><span class="line">    <span class="built_in">puts</span>(ptr);</span><br><span class="line">    words[<span class="number">8</span>] = <span class="string">&#x27;p&#x27;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(words);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223939043.png" alt="image-20211215223939043"></p>
<ul>
<li><code>puts()</code>也属于<code>stdio.h</code>系列的输入输出函数，只显示字符串，而且<strong>自动换行</strong>。</li>
</ul>
<h4 id="11-2-1-在程序中定义字符串"><a href="#11-2-1-在程序中定义字符串" class="headerlink" title="11.2.1 在程序中定义字符串"></a>11.2.1 在程序中定义字符串</h4><h5 id="①-字符串字面量（字符串常量）"><a href="#①-字符串字面量（字符串常量）" class="headerlink" title="① 字符串字面量（字符串常量）"></a>① 字符串字面量（字符串常量）</h5><p>用<strong>双引号</strong>括起来的内容成为字符串<strong>字面量</strong>或字符串<strong>常量</strong>。</p>
<ul>
<li>如果在字符串内部使用双引号需要在前面加上反斜杠</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\&quot;run, Spot, run!\&quot; exclaimed Dick.\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串常量属于<strong>静态存储类别</strong>，这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。<strong>用双引号括起来的内容被视为指向该字符串存储位置的指针</strong>（例如<code>“Hello World”</code>就是一个指针，指向<code>“H”</code>），这类似于把数组名作为指向该数组位置的指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s, %p, %c\n&quot;</span>,<span class="string">&quot;We&quot;</span>,<span class="string">&quot;are&quot;</span>,*<span class="string">&quot;space farers&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223947590.png" alt="image-20211215223947590"></p>
<h5 id="②-字符数组和初始化"><a href="#②-字符数组和初始化" class="headerlink" title="② 字符数组和初始化"></a>② 字符数组和初始化</h5><ul>
<li>用指定的字符串初始化字符数组m1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> m1[] = <span class="string">&quot;Hello World!&quot;</span>;<span class="comment">// 数组大小可以省略</span></span><br></pre></td></tr></table></figure>
<p>这种初始化的形势比标准的数组初始化形式简单得多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> m1[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;!&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意最后的空字符。若没有该空字符，这就不是一个字符串m1，而是一个普通的字符数组。</p>
<p>字符数组名和其它数组名一样，代表该数组首元素的地址。</p>
<ul>
<li>还可以使用指针表示法创建字符串，注意指针类型是<code>char</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptr = <span class="string">&quot;Hello World!&quot;</span>;<span class="comment">// ptr指向该字符串的首地址</span></span><br></pre></td></tr></table></figure>
<p>这种方式几乎和上面的字符串数组的创建形式相同，但原理仍有不同，下面会说。</p>
<h5 id="③-数组和指针"><a href="#③-数组和指针" class="headerlink" title="③ 数组和指针"></a>③ 数组和指针</h5><ul>
<li>数组形式（<code>m1[]</code>）：字符串作为可执行文件的一部分存储在程序的数据段中。当把程序载入内存时，也载入了字符串。字符串存储在内存的静态存储区。但是程序在开始运行时（被cpu调度），才为数组m1分配内存（动态内存），并将静态存储区的字符串<code>拷贝</code>到该数组中。此时，<strong>该字符串有两个副本，一个位于静态存储区，一个位于动态内存中的数组m1中</strong>，两者的地址是不同的。此外，m1是==地址常量==，不能够更改m1，即不能实现<code>++m1</code>操作，只能实现<code>m1+1</code>操作。</li>
<li>指针形式（<code>*ptr</code>）：指针形式也使得编译器为字符串在静态存储区开辟一个地址空间。开始执行程序时，就会为==指针变量==ptr留出一个存储位置，把字符串的地址存储在指针变量中，该变量最初指向字符串的首字符的地址，但可以改变，即可以实现<code>++ptr</code>的操作，将ptr指向第二个字符的地址。此时，<strong>字符串只有一个副本，位于内存的静态存储区</strong>。后面会说为什么要用<code>const</code>修饰。</li>
</ul>
<p>总之，初始化数组是把静态存储区的字符串拷贝到使用动态内存的数组当中，而初始化指针是直接把静态存储区的字符串的地址拷贝给指针。且数组名是常量，指针名是变量。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MSG <span class="meta-string">&quot;Hello World&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ar[]  = MSG;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * ptr = MSG;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address of \&quot;Hello World\&quot;: %p \n&quot;</span>,<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 静态存储区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;              address ar: %p\n&quot;</span>,ar); <span class="comment">// 动态内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;             address ptr: %p\n&quot;</span>,ptr); <span class="comment">// 静态存储区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;          address of MSG: %p \n&quot;</span>,MSG); <span class="comment">// 静态存储区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address of \&quot;Hello World\&quot;: %p \n&quot;</span>,<span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 静态存储区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215223956794.png" alt="image-20211215223956794"></p>
<p>说明：</p>
<ul>
<li>静态数据（字符串常量和ptr）使用的内存和ar使用的动态内存不同</li>
<li>字符串常量<code>Hello World</code>在程序的两个地方出现了两次（最开始和最结束），但是编译器只使用了一个存储地址，还和<code>MSG</code>的地址相同，说明编译器可以把多次使用的相同字面量存储在一处。但这个取决于编译器的逻辑，也可能存储在三个不同的地址。</li>
</ul>
<h5 id="④-数组和指针的区别"><a href="#④-数组和指针的区别" class="headerlink" title="④ 数组和指针的区别"></a>④ 数组和指针的区别</h5><p>初始化字符数组来储存字符串和初始化指针来指向字符串有何区别？例如，假设有下面两个声明∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> heart[] = <span class="string">&quot;I love Mary!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *head = <span class="string">&quot;I love Mike!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>两者最主要的区别是：数组名<code>heart</code>是常量，而<code>head</code>是变量。</p>
<p>两者都可以使用数组表示法和指针表示法。但是指针可以进行递增操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(*(head) != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    putschar(*(head++));</span><br><span class="line">	<span class="comment">// putschar(*(heart++)); 错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>以下代码中：<code>ptr = arr;</code>不会导致ptr指向的字符串消失，这样做只是改变了存储在ptr中的地址（ptr指向了另一个地址）。除非保存了<code>&quot;Hello Sekai!&quot;</code>的地址，否则当ptr指向别处时，就无法再访问该字符串。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * ptr = <span class="string">&quot;Hello Sekai!&quot;</span>;</span><br><span class="line">    arr = ptr;<span class="comment">// 不允许</span></span><br><span class="line">    ptr = arr;<span class="comment">// 允许</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于未用<code>const</code>修饰的指针初始化，编译器可能允许指针修改该字符串，但对于当前的C标准而言，这样的行为是未定义的。字符串常量被视为<code>const</code>数据，建议在指针初始化为字符串常量时使用<code>const</code>限定符。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐的形式</span></span><br><span class="line"><span class="keyword">char</span> * p1 = <span class="string">&quot;Klingon&quot;</span>;</span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">&quot;F&quot;</span>;<span class="comment">// 这条语句能否执行取决于编译器的逻辑，经测试，在mingw编译运行时会导致程序陷入死循环</span></span><br><span class="line"><span class="comment">// 推荐的指针初始化形式，此时ptr不能够修改指向的值，但可以让ptr指向别处</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * ptr = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">p1[<span class="number">0</span>] = <span class="string">&quot;F&quot;</span>; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对非<code>const</code>数组初始化为字符串常量不会导致以上问题，因为数组获得的是原始字符串的副本。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;Hello World!&quot;</span>;<span class="comment">// 非const初始化</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="string">&#x27;3&#x27;</span>;<span class="comment">// 允许</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,arr); <span class="comment">// 3ello World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>总结</strong>：如果要修改字符串，使用字符数粗存储；如果不修改字符串，就是用指针指向字符串。</li>
</ul>
<h5 id="⑤-字符串数组"><a href="#⑤-字符串数组" class="headerlink" title="⑤ 字符串数组"></a>⑤ 字符串数组</h5><blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEN 40</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIM 5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mytalents[LIM] = &#123;</span><br><span class="line">            <span class="string">&quot;Adding numbers swiftly&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Multiplying accurately&quot;</span>, <span class="string">&quot;Stashing data&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Following instructions to the letter&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Understanding the C language&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> yourtalents[LIM][SLEN] = &#123;</span><br><span class="line">            <span class="string">&quot;Walking in a straight line&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Sleeping&quot;</span>, <span class="string">&quot;Watching television&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Mailing letters&quot;</span>, <span class="string">&quot;Reading email&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s compare talents.&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-36s %-25s\n&quot;</span>, <span class="string">&quot;My Talents&quot;</span>, <span class="string">&quot;Your Talents&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; LIM; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%-36s %-25s\n&quot;</span>, mytalents[i], yourtalents[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nsizeof mytalents: %zd, sizeof yourtalents: %zd\n&quot;</span>,</span><br><span class="line">           <span class="keyword">sizeof</span>(mytalents), <span class="keyword">sizeof</span>(yourtalents));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224006003.png" alt="image-20211215224006003"></p>
<ul>
<li>mytalents和yourtalents非常类似，都表示5个字符串。使用一个下标时代表一个字符串，例如<code>mytalents[0]</code>和<code>youtalents[0]</code>。使用两个下标时，代表一个字符，例如<code>mytalents[1][2]</code>表示数组中第2个指针所指向的第3个字符<code>‘i’</code>，<code>youtalents[1][2]</code>表示数组第2个字符串的第3个字符<code>‘e’</code>。</li>
<li>区别1：mytalents是一个内含5个指针的数组（注意指针占用字节与数据类型无关，而与系统的地址有关，这里是4字节），占用20字节。而yourtalents是一个内含5个数组的数组，每个数组又内含40个char，则总共占用5*40=200个字节。</li>
<li>区别2：数组初始化形式的内存利用率较低，因为每个数组中的字符串都是静态存储区中原始字符串的副本。</li>
<li>区别3：要使用数组表示一系列待显示的字符串，采用指针数组。要改变字符串或为字符串输入预留空间，则采用普通的二维数组，因为指针指向的字符串常量不能更改。</li>
</ul>
<h4 id="11-2-2-指针和字符串"><a href="#11-2-2-指针和字符串" class="headerlink" title="11.2.2 指针和字符串"></a>11.2.2 指针和字符串</h4><p>实际上，<strong>字符串的绝大多数操作都是通过指针完成的</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * mesg = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * copy;</span><br><span class="line">    copy = mesg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mesg = %s; &amp;mesg = %p; value = %p.\n&quot;</span>,mesg,&amp;mesg,mesg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;copy = %s; &amp;copy = %p; value = %p.\n&quot;</span>,copy,&amp;copy,copy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述程序中，对输出参数mesg，可以用输出控制符（转换说明）<code>%s</code>输出，也可以用<code>%p</code>输出，前者是字符串，后者是指针的值（指针指向的地址）。</li>
<li>&amp;mesg是指针自身的地址。因为指针自身也是一个变量，需要为其分配内存地址。</li>
<li>通过赋值操作，mesg和copy指向了同一地址，说明程序并未拷贝字符串，而是让两个指针指向同一地址。</li>
</ul>
<h3 id="11-3-字符串输入"><a href="#11-3-字符串输入" class="headerlink" title="11.3 字符串输入"></a>11.3 字符串输入</h3><h4 id="11-3-1-gets-函数"><a href="#11-3-1-gets-函数" class="headerlink" title="11.3.1 gets()函数"></a>11.3.1 <code>gets()</code>函数</h4><ul>
<li>功能：读取整行输入，直到遇到换行符，然后丢弃换行符，存储其余字符并在末尾添加空字符，使其成为一个字符串</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRLEN 81</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> words[STRLEN];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter a string, please.&quot;</span>);</span><br><span class="line">    gets(words);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your string twice:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,words);</span><br><span class="line">    <span class="built_in">puts</span>(words);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224015312.png" alt="image-20211215224015312"></p>
<ul>
<li>可能出现的问题：该函数只有一个参数，无法检查数组是否装得下输入行，可能会导致缓冲区溢出，即多余的字符超出了指定的目标空间。</li>
<li>C11从标准中废除了get函数，但是实际应用中仍有大量用到该函数的地方</li>
</ul>
<h4 id="11-3-2-fgets-函数"><a href="#11-3-2-fgets-函数" class="headerlink" title="11.3.2 fgets()函数"></a>11.3.2 <code>fgets()</code>函数</h4><p>下略</p>
<h3 id="11-4-字符串函数"><a href="#11-4-字符串函数" class="headerlink" title="11.4 字符串函数"></a>11.4 字符串函数</h3><p>C库提供了多个处理字符串的函数，ANSI C把这些函数的原型放在<code>string.h</code>头文件中。其中最常用的函数有<code>strlen()</code>、<code>strcat()</code>、<code>strcmp()</code>、<code>strncmp()</code>、<code>strcpy()</code>和<code>strncpy()</code>。另外，还有<code>sprintf()</code>函数，其原型在<code>stdio.h</code>头文件中。</p>
<h4 id="11-4-1-strlen"><a href="#11-4-1-strlen" class="headerlink" title="11.4.1 strlen"></a>11.4.1 strlen</h4><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br></pre></td></tr></table></figure>
<p>用于统计字符串的长度。</p>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">&quot;Things should be as simple as possible,&quot;</span></span><br><span class="line">                 <span class="string">&quot;but not simpler&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    fit(msg, <span class="number">38</span>);</span><br><span class="line">    <span class="built_in">puts</span>(msg);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Let&#x27;s look at some more of the string.&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(msg + <span class="number">39</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fit</span><span class="params">(<span class="keyword">char</span> * <span class="built_in">string</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(<span class="built_in">string</span>) &gt; size) &#123;</span><br><span class="line">        <span class="built_in">string</span>[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Things should be as simple as possible,but not simpler</span><br><span class="line">Things should be as simple as possible</span><br><span class="line">Let&#x27;s look at some more of the string.</span><br><span class="line">but not simpler</span><br></pre></td></tr></table></figure>
<p>注：<code>puts</code>函数在空字符串<code>\0</code>处停止输出，剩余的字符仍处在缓冲区内。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221107132403921.png" alt="image-20221107132403921"></p>
<h4 id="11-4-2-strcat"><a href="#11-4-2-strcat" class="headerlink" title="11.4.2 strcat"></a>11.4.2 strcat</h4><p><code>strcat</code>（用于拼接字符串）函数接受两个字符串作为参数。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * destination, <span class="keyword">const</span> <span class="keyword">char</span> * source)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数把第2个字符串的备份附加在第1个字符串末尾，并把拼接后形成的新字符串作为第1个字符串，<strong>第2个字符串不变</strong>。<code>strcat</code>函数的返回类型是char *（即，指向 char 的指针）。</p>
<p><code>strcat</code>函数返回第1个参数，即拼接第2个字符串后的第1个字符串的地址。</p>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 80</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> flower[SIZE];</span><br><span class="line">    <span class="keyword">char</span> addon[] = <span class="string">&quot;s smell like old shoes.&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;What is your favorite flower?&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (s_gets(flower, SIZE)) &#123;</span><br><span class="line">        <span class="built_in">strcat</span>(flower, addon);</span><br><span class="line">        <span class="built_in">puts</span>(flower);</span><br><span class="line">        <span class="built_in">puts</span>(addon);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;End of file encountered!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;bye&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> * ret_val;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读取一行输入</span></span><br><span class="line">    ret_val = fgets(st, n, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret_val) &#123;</span><br><span class="line">        <span class="keyword">while</span> (st[i] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; st[i] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            st[i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What is your favorite flower?</span><br><span class="line">wonderflower</span><br><span class="line">wonderflowers smell like old shoes.</span><br><span class="line">s smell like old shoes.</span><br><span class="line">bye</span><br></pre></td></tr></table></figure>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcat_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> arr2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(arr1, arr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    strcat_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-4-3-strncat"><a href="#11-4-3-strncat" class="headerlink" title="11.4.3 strncat"></a>11.4.3 strncat</h4><p><code>strcat</code>函数无法检查第1个数组是否能容纳第2个字符串。如果分配给第1个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题，如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221126175732572.png" alt="image-20221126175732572"></p>
<p><code>strncat</code>函数的声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncat</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">size_t</span> n)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>dest</strong> — 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符。</li>
<li><strong>src</strong> — 要追加的字符串。</li>
<li><strong>n</strong> — 要追加的最大字符数。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcat_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr1[<span class="number">7</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> arr2[<span class="number">20</span>] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    <span class="built_in">strncat</span>(arr1, arr2, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, arr1); <span class="comment">// HelloW</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    strcat_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arr1</code>的容量为7，已经使用了6个存储空间（包括0字符），只能再追加一个额外的字符，因此设定<code>n=1</code>来防止溢出。</p>
<h4 id="11-4-4-strcmp"><a href="#11-4-4-strcmp" class="headerlink" title="11.4.4 strcmp"></a>11.4.4 strcmp</h4><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str1, <span class="keyword">const</span> <span class="keyword">char</span> *str2)</span></span></span><br></pre></td></tr></table></figure>
<p>该函数返回值如下：</p>
<ul>
<li>如果返回值小于 0，则表示 str1 小于 str2。</li>
<li>如果返回值大于 0，则表示 str1 大于 str2。</li>
<li>如果返回值等于 0，则表示 str1 等于 str2。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcmp_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">char</span> str2[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(str1, <span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str2, <span class="string">&quot;ABCDEF&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">strcmp</span>(str1, str2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 &lt; str2&quot;</span>); <span class="comment">// 打印这一句</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 &gt; str2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str1 = str2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    strcmp_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-4-5-strcpy"><a href="#11-4-5-strcpy" class="headerlink" title="11.4.5 strcpy"></a>11.4.5 strcpy</h4><p>将一个字符串复制到另一块空间地址中 的函数，<code>\0</code>是停止拷贝的终止条件，同时也会将<code>\0</code>也复制到目标空间。</p>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* destination,<span class="keyword">const</span> <span class="keyword">char</span>* source)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>char* destination</code>：目标字符串的首地址</li>
<li><code>const char* source</code>：源地址，被复制的字符串的首地址，用const修饰，避免修改掉被拷贝的字符串</li>
<li><code>char*</code>：返回的是目标字符串的首地址 </li>
</ul>
<p><code>strcpy</code>接受两个字符串指针作为参数，可以把指向源字符串的第2个指针声明为指针、数组名或字符串常量；<strong>而指向源字符串副本的第1个指针应指向一个数据对象（如，数组），且该对象有足够的空间储存源字符串的副本</strong>，否则会造成缓冲溢出。记住，声明数组将分配储存数据的空间，而声明指针只分配储存一个地址的空间。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> arr1[<span class="number">10</span>] = <span class="string">&quot;**********&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> arr2[<span class="number">10</span>] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strcpy</span>(arr1, arr2)); <span class="comment">// abcd</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>目标空间必须可变，因此不能使用指针指向字符串常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">	<span class="keyword">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;*********&quot;</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, <span class="built_in">strcpy</span>(str1,str2)); <span class="comment">// error</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>str1</code>指向的是常量字符串，是不可以被修改掉的，目标空间必须是可以被修改的，因为要将拷贝的字符串放在目标空间中。而源字符串可以是能够修改的、也可以是不能修改的，因为<code>strcpy</code>函数的第二个参数已经用const关键字修饰了，保证了拷贝过程中不会被修改。</p>
<ul>
<li>strcpy函数还有两个有用的属性。第一，strcpy的返回类型是<code>char *</code>，该函数返回的是第1 个参数的值，即一个字符的地址。第二，第1个参数不必指向数组的开始。这个属性可用于拷贝数组的一部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WORDS <span class="meta-string">&quot;beast&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">strcpy_test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * orig = WORDS;</span><br><span class="line">    <span class="keyword">char</span> copy[SIZE] = <span class="string">&quot;Be the best that you can be.&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span> * ps;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(orig);</span><br><span class="line">    <span class="built_in">puts</span>(copy);</span><br><span class="line">    ps = <span class="built_in">strcpy</span>(copy + <span class="number">7</span>, orig);</span><br><span class="line">    <span class="built_in">puts</span>(copy);</span><br><span class="line">    <span class="built_in">puts</span>(ps);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    strcpy_test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beast</span><br><span class="line">Be the best that you can be.</span><br><span class="line">Be the beast</span><br><span class="line">beast</span><br></pre></td></tr></table></figure>
<p>注意：strcpy也会将源字符串的<code>\0</code>拷贝至目标字符串。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127105920179.png" alt="image-20221127105920179"></p>
<h4 id="11-4-6-其他字符串函数"><a href="#11-4-6-其他字符串函数" class="headerlink" title="11.4.6 其他字符串函数"></a>11.4.6 其他字符串函数</h4><ul>
<li>如果s字符串中包含c字符，该函数返回指向c字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strchr</span><span class="params">(cost <span class="keyword">char</span> * s, <span class="keyword">int</span> c)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strrchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * s, intc)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">const</span> * s1, <span class="keyword">const</span> * s2)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="11-5-命令行参数"><a href="#11-5-命令行参数" class="headerlink" title="11.5 命令行参数"></a>11.5 命令行参数</h3><p>假设一个程序的名称为<code>fuss</code>，则在windows命令提示模式下运行该程序的命令为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuss</span><br></pre></td></tr></table></figure>
<p><strong>命令行参数</strong>是同一行的附加项，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuss -r Ginger</span><br></pre></td></tr></table></figure>
<p>这里的<code>-r</code>和<code>Ginger</code>就是命令行参数。</p>
<p>可以通过main函数的参数来读取命令行参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 也可以是</span></span><br><span class="line"><span class="comment">// int main(int argc, char **argv); *argv[]和**argv等价，即argv是指向指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The command line has %d arguments:\n&quot;</span>, argc - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>; count &lt; argc; count++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d: %s\n&quot;</span>, count, argv[count]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127111447625.png" alt="image-20221127111447625"></p>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The command line has 2 arguments:</span><br><span class="line">1: im</span><br><span class="line">2: fine</span><br></pre></td></tr></table></figure>
<p>运行原理：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127111524008.png" alt="image-20221127111524008"></p>
<p>C编译器允许main没有参数或者有两个参数（一些实现允许main有更多参数，属于对标准的扩展）。</p>
<p>main有两个参数时：</p>
<ul>
<li>第1个参数是<strong>命令行中的字符串数量</strong>。过去，这个int类型的参数被称为<code>argc</code> （表示参数计数<code>argument count</code>）。系统用空格表示一个字符串的结束和下一个字符串的开始。因此，上面的 repeat 示例中包括命令名共有3个字符串，其中后2个供 repeat 使用。该程序把命令行字符串储存在内存中，并把每个字符串的地址储存在指针数组中。</li>
<li>指针数组的地址则被储存在main的第2个参数中。按照惯例，这个指向指针的指针称为 <code>argv</code>（表示参数值<code>argument value</code>）。如果系统允许（一些操作系统不允许这样），就把程序本身的名称赋给 <code>argv[0]</code>，然后把随后的第1个字符串赋给 <code>argv[1]</code>，以此类推。</li>
</ul>
<h2 id="12-存储类别和内存管理"><a href="#12-存储类别和内存管理" class="headerlink" title="12 存储类别和内存管理"></a>12 存储类别和内存管理</h2><h3 id="12-1-存储类别"><a href="#12-1-存储类别" class="headerlink" title="12.1 存储类别"></a>12.1 存储类别</h3><p>C提供了多种不同的模型或<strong>存储类别</strong>（storage class）在内存中储存数据。</p>
<p>目前所有编程示例中使用的数据都储存在内存中。</p>
<p>从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为<strong>对象</strong>（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。</p>
<p>从软件方面来看，程序需要一种方法访问对象（内存）。这可以通过<strong>声明变量</strong>来完成∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> entity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>该声明创建了一个名为<code>entity</code>的<strong>标识符</strong>（identiffer）。标识符是一个名称，在这种情况下，标识符可以用来指定特定对象的内容。在该例中，标识符entity即是软件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象中的值<code>3</code>。</p>
<ul>
<li>存储期：可以使用存储期<strong>描述对象</strong>（存储了值的非空闲内存）。存储期指对象在内存中保留了多长时间。</li>
<li>作用域和链接：可以使用这两者描述<strong>标识符</strong>。标识符的作用域和链接表明了程序的哪些部分能够使用它。</li>
<li><strong>不同的存储类别具有不同的存储期、作用域和链接</strong>。标识符可以在源代码的多文件中共享、可用于特定文件的任意函数中、可仅限于特定函数中使用，甚至只在函数中的某部分使用。对象可存在于程序的执行期，也可以仅存在于它所在函数的执行期。对于并发编程，对象可以在特定线程的执行期存在。可以通过函数调用的方式显式分配和释放内存。</li>
<li>C 使用作用域、链接和存储期为变量定义了多种存储方案。这里先介绍5种：自动、寄存器、静态块作用域、静态外部链接、静态内部链接。以下是5种存储类别：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20221109141325620.png" alt="image-20221109141325620"></p>
<h4 id="12-1-1-作用域"><a href="#12-1-1-作用域" class="headerlink" title="12.1.1 作用域"></a>12.1.1 作用域</h4><p>作用域描述程序中<strong>可访问标识符的区域</strong>。</p>
<p>一个C变量的作用域可以是<strong>块作用域、函数作用域、函数原型作用域或文件作用域</strong>。</p>
<p>块是用一对花括号括起来的代码区域。例如，整个函数体是一个块，函数中的任意复合语句也是一个块。定义在块中的变量具有块作用域（block scope），<strong>块作用域变量的可见范围是从定义处到包含该定义的块的末尾</strong>。</p>
<ul>
<li>示例1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">blocky</span><span class="params">(<span class="keyword">double</span> cleo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> patrick = <span class="number">0.0</span>; <span class="comment">// patrick具有块作用域</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> patrick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2：声明在内层块的变量，其作用域仅限于该声明所在的块</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">blocky</span><span class="params">(<span class="keyword">double</span> cleo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> patrick = <span class="number">0.0</span>; <span class="comment">// patrick具有块作用域</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> q = cleo * i; <span class="comment">// q的作用域开始</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        patrick *= q;</span><br><span class="line">    &#125; <span class="comment">// q的作用域结束</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> patrick;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>函数原型作用域用于函数原型中的形参名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mighty</span><span class="params">(<span class="keyword">int</span> mouse, <span class="keyword">double</span> large)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数原型作用域的范围是从形参定义处到原型声明结束。这意味着，编译器在处理函数原型中的形参时<strong>只关心它的类型，而形参名（如果有的话）通常无关紧要</strong>。而且，<strong>即使有形参名，也不必与函数定义中的形参名相匹配</strong>。</p>
<p>只有在变长数组中，形参名才有用∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_a_VLA</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, ar[n][m])</span></span>; <span class="comment">// 形参名n和m不可省略</span></span><br></pre></td></tr></table></figure>
<hr>
<p>变量的定义在函数的外面，具有<strong>文件作用域</strong>（file scope）。具有文件作用域的变量，从它的定义处到该定义所在文件的末尾均可见。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> units = <span class="number">0</span>; <span class="comment">// 该变量具有文件作用域（全局作用域）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critic</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critic</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，变量units具有文件作用域，main和critic函数都可以使用它（更准确地说，units 具有<strong>外部链接文件作用域</strong>）。由于这样的变量可用于多个函数，所以文件作用域变量也称为<strong>全局变量</strong>（global variable）。</p>
<h4 id="12-1-2-链接"><a href="#12-1-2-链接" class="headerlink" title="12.1.2 链接"></a>12.1.2 链接</h4><p>翻译单元：通常在源代码（.c扩展名）中包含一个或多个头文件（.h 扩展名）。头文件会依次包含其他头文件，所以会包含多个单独的<strong>物理文件</strong>。但是，<strong>C预处理</strong>实际上是用包含的头文件内容替换<code>#include</code>指令。<strong>所以，编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（ranslation unit）</strong>，描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。</p>
<p>C 变量有3种链接属性∶<strong>外部链接、内部链接或无链接</strong>。</p>
<ul>
<li><strong>具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量</strong>。这意味着这些变量属于定义它们的块、函数或原型私有。</li>
<li><strong>具有文件作用域的变量可以是外部链接或内部链接</strong>。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。<ul>
<li>外部链接作用域又称为全局作用域或程序作用域</li>
<li>内部链接作用域又称为文件作用域，用存储类别说明符<code>static</code>修饰</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> giants = <span class="number">5</span>; <span class="comment">// 全局作用域，外部</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> dodgers = <span class="number">3</span>; <span class="comment">// 文件作用域，内部</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该文件和同一程序的其他文件都可以使用变量giants。而变量dodgers属文件私有，该文件中的任意函数都可使用它。</p>
<h4 id="12-1-3-存储期"><a href="#12-1-3-存储期" class="headerlink" title="12.1.3 存储期"></a>12.1.3 存储期</h4><p>作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。</p>
<p>C对象有4种存储期∶<strong>静态存储期、线程存储期、自动存储期、动态分配存储期（详见12.3节）</strong>。</p>
<ul>
<li>静态存储期：如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字static表明了其链接属性，而非存储期。以static声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，<strong>所有的文件作用域变量（声明在函数外面）都具有静态存储期</strong>。</li>
<li>线程存储期：线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字<code>_Thread_local</code>声明一个对象时，每个线程都获得该变量的私有备份。</li>
<li>自动存储期：<strong>块作用域的变量通常都具有自动存储期</strong>。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个<strong>可重复使用的工作区或暂存区</strong>。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。</li>
</ul>
<blockquote>
<p>程序示例</p>
</blockquote>
<ul>
<li>自动存储期：<code>number</code>，<code>index</code>在每次调用<code>bore</code>函数时被创建在内存中，离开函数时被销毁。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bore</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; number; index++) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>静态存储期：注意块作用域变量也能具有静态存储期</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">more</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index; <span class="comment">// 自动存储期</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ct = <span class="number">0</span>; <span class="comment">// 静态存储期，但是是块作用域变量</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，变量 <code>ct</code> 储存在静态内存中，它从程序被载入到程序结束期间都存在。但是，它的作用域定义在<code>more</code>函数块中。只有在执行该函数时，程序才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，例如通过指针形参或返回值）。</p>
<h4 id="12-1-4-自动"><a href="#12-1-4-自动" class="headerlink" title="12.1.4 自动"></a>12.1.4 自动</h4><p>属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地表达意图，可以显式使用关键字<code>auto</code>，如下所示∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> plox</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键字 auto是<strong>存储类别说明符</strong>（storage-class specifier）。auto关键字在C++中的用法完全不同，如果编写C/C++兼容的程序，最好不要使用auto作为存储类别说明符。</p>
<p>块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。</p>
<p>块中声明的变量仅限于该块<strong>及其包含的块</strong>使用。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<ul>
<li>在下面的代码中，i仅在内层块中可见。如果在内层块的前面或后面使用i，编译器会报错。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m ; <span class="comment">// m的作用域</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i; <span class="comment">// m，i的作用域</span></span><br><span class="line">        <span class="keyword">for</span> (i = m; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;i is local to a sub-block\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m; <span class="comment">// m的作用域，i已经消失</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果内层块中声明的变量与外层块中的变量同名会怎样？<strong>内层块会隐藏外层块的定义</strong>。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">30</span>; <span class="comment">// 原始的x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x in outer block: %d at %p \n&quot;</span>, x, &amp;x);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">77</span>; <span class="comment">// 新的x，隐藏了原始的x</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x in inner block: %d at %p \n&quot;</span>, x, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x in outer block: %d at %p \n&quot;</span>, x, &amp;x);</span><br><span class="line">    <span class="keyword">while</span> (x++ &lt; <span class="number">33</span>) &#123; <span class="comment">// 原始的x</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">100</span>; <span class="comment">// 新的x，隐藏了原始的x</span></span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x in while loop: %d at %p \n&quot;</span>, x, &amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x in outer block: %d at %p \n&quot;</span>, x, &amp;x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x in outer block: 30 at 006FF934</span><br><span class="line">x in inner block: 77 at 006FF928</span><br><span class="line">x in outer block: 30 at 006FF934</span><br><span class="line">x in while loop: 101 at 006FF91C</span><br><span class="line">x in while loop: 101 at 006FF91C</span><br><span class="line">x in while loop: 101 at 006FF91C</span><br><span class="line">x in outer block: 34 at 006FF934</span><br></pre></td></tr></table></figure>
<h4 id="12-1-5-寄存器"><a href="#12-1-5-寄存器" class="headerlink" title="12.1.5 寄存器"></a>12.1.5 寄存器</h4><p>变量通常储存在计算机内存中。寄存器变量储存在CPU的<strong>寄存器</strong>中，或者概括地说，储存在最快的可用内存中。与普通变量相比，访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器（CPU）而非内存中，所以无法获取寄存器变量的地址。绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是<strong>块作用域、无链接和自动存储期</strong>。使用存储类别说明符<code>register</code>便可声明寄存器变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> quick;</span><br></pre></td></tr></table></figure>
<p>可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double 类型的值。</p>
<h4 id="12-1-6-块作用域的静态变量（静态无链接）"><a href="#12-1-6-块作用域的静态变量（静态无链接）" class="headerlink" title="12.1.6 块作用域的静态变量（静态无链接）"></a>12.1.6 块作用域的静态变量（静态无链接）</h4><p>静态的意思是<strong>该变量在内存中原地不动，并不是说它的值不变</strong>。</p>
<p>具有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。</p>
<p>计算机在多次函数调用之间会记录它们的值。在块中（提供块作用域和无链接）以存储类别说明符<code>static</code>（提供静态存储期）声明这种变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trystat</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">1</span>;  count &lt;= <span class="number">3</span>; count++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Here comes iteration %d:\n&quot;</span>, count);</span><br><span class="line">        trystat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trystat</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fade = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stay = <span class="number">1</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fade = %d and stay = %d\n&quot;</span>, fade++, stay++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Here comes iteration 1:</span><br><span class="line">fade = 1 and stay = 1</span><br><span class="line">Here comes iteration 2:</span><br><span class="line">fade = 1 and stay = 2</span><br><span class="line">Here comes iteration 3:</span><br><span class="line">fade = 1 and stay = 3</span><br></pre></td></tr></table></figure>
<p>静态变量stay保存了它被递增1后的值，但是fade变量每次都是1。这表明了初始化的不同∶每次调用trystat都会初始化fade，但是stay只在编译strstat时被初始化一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fade = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stay = <span class="number">1</span>; <span class="comment">// 静态变量</span></span><br></pre></td></tr></table></figure>
<p>第1条声明确实是trystat函数的一部分，每次调用该函数时都会执行这条声明。这是运行时行为。第2条声明实际上并不是trystat函数的一部分。如果逐步调试该程序会发现，<strong>程序似乎跳过了这条声明</strong>。这是因为静态变量和外部变量在程序被载入内存时已执行完毕。把这条声明放在trystat函数中是为了告诉编译器只有trystat函数才能看到该变量。<strong>这条声明并未在运行时执行</strong>。</p>
<h4 id="12-1-7-外部链接的静态变量（静态外部链接）"><a href="#12-1-7-外部链接的静态变量（静态外部链接）" class="headerlink" title="12.1.7 外部链接的静态变量（静态外部链接）"></a>12.1.7 外部链接的静态变量（静态外部链接）</h4><p>外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。<strong>把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量</strong>。当然，为了指出该函数使用了外部变量，可以在函数中用关键字<code>extern</code>再次声明。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则<strong>必须</strong>用 extern 在该文件中声明该变量。</p>
<ul>
<li>示例1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Errupt; <span class="comment">// 外部定义的变量</span></span><br><span class="line"><span class="keyword">double</span> Up[<span class="number">100</span>]; <span class="comment">// 外部定义的数组</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> Coal; <span class="comment">// 如果Coal声明在另一个文件里，则必须使用extern关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> Errput; <span class="comment">// 明确指出使用了外部变量，可选的重复声明（可以省略）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">double</span> Up[]; <span class="comment">// 数组大小可以省略，因为上面已经指明了数组的大小为100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> Errput; <span class="comment">// 和main中的Errput是同一个变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Hocus;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Hocus; <span class="comment">// 默认是自动变量，属于main私有，将隐藏外部变量Hocus</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> Hocus; <span class="comment">// 显式声明为自动变量，同样属于magic函数私有，将隐藏外部变量Hocus</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例3</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> units = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critic</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> units; <span class="comment">// 可选的重复声明，它明确告诉编译器，main中任何使用units的地方都引用同一个定义在函数外部的变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;How many pounds to a firkin of butter?\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;units);</span><br><span class="line">    <span class="keyword">while</span> (units != <span class="number">56</span>) &#123;</span><br><span class="line">        critic();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You must have looked it up!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">critic</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有使用可选的重复声明</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No luck, my friend. Try again.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;units);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">How many pounds to a firkin of butter?</span><br><span class="line">12</span><br><span class="line">No luck, my friend. Try again.</span><br><span class="line">57</span><br><span class="line">No luck, my friend. Try again.</span><br><span class="line">56</span><br><span class="line">You must have looked it up!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>定义和声明</p>
</blockquote>
<p>注意区分<strong>定义变量</strong>和<strong>声明变量</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tern = <span class="number">1</span>; <span class="comment">// 定义式声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> tern; <span class="comment">// 引用式声明，extern表明该声明不是定义，因为它指示编译器去别处查询该变量的定义声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> tern; <span class="comment">// 编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该声明并不会引起分配存储空间。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>外部变量只能初始化一次，且必须在定义该变量时进行</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_one.c</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file_two.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">2</span>; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h4 id="12-1-8-内部链接的静态变量（静态内部链接）"><a href="#12-1-8-内部链接的静态变量（静态内部链接）" class="headerlink" title="12.1.8 内部链接的静态变量（静态内部链接）"></a>12.1.8 内部链接的静态变量（静态内部链接）</h4><p>该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符<code>static</code>定义的变量具有这种存储类别∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> svil = <span class="number">1</span>; <span class="comment">// 静态变量，内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用存储类别说明符 <code>extern</code>，在函数中重复声明任何具有文件作用域的变量。这样的声明并不会改变其链接属性。考虑下面的代码∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> traveler = <span class="number">1</span>; <span class="comment">// 外部链接</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> stayhome = <span class="number">1</span>; <span class="comment">// 内部链接</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> traveler; <span class="comment">// 引用声明在别处的traveler</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> stayhome; <span class="comment">// 引用声明在别处的stayhome</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于该程序所在的翻译单元，trveler和stayhome都具有文件作用域，但是只有traveler可用于其他翻译单元（因为它具有外部链接）。这两个声明都使用了<code>extern</code>关键字，指明了main中使用的这两个变量的定义都在别处，但是这并未改变stayhome的内部链接属性。</p>
<hr>
<p>只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。</p>
<p>复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C通过在一个文件中进行<strong>定义式声明</strong>，然后在其他文件中进行<strong>引用式声明</strong>来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。</p>
<p>注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用 extern 关键字）。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声明之前不能直接使用它。</p>
<h4 id="12-1-9-存储类别说明符"><a href="#12-1-9-存储类别说明符" class="headerlink" title="12.1.9 存储类别说明符"></a>12.1.9 存储类别说明符</h4><ul>
<li>auto 说明符表明变量是自动存储期，只能用于块作用域的变量声明中。由于在块中声明的变量本身就具有自动存储期，所以使用 auto 主要是为了明确表达要使用与外部变量同名的局部变量的意图（隐藏外部变量）。</li>
<li>register 说明符也只用于块作用域的变量，它把变量归为寄存器存储类别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。</li>
<li>用 static 说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文件。如果 static 用于块作用域声明，作用域则受限于该块。因此，只要程序在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链接。</li>
<li>extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。</li>
</ul>
<h4 id="12-1-10-存储类别和函数"><a href="#12-1-10-存储类别和函数" class="headerlink" title="12.1.10 存储类别和函数"></a>12.1.10 存储类别和函数</h4><p>函数也有存储类别，可以是<strong>外部函数（默认）或静态函数</strong>。外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件。假设一个文件中包含了以下函数原型∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gamma</span><span class="params">(<span class="keyword">double</span>)</span></span>; <span class="comment">// 该函数默认为外部函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">beta</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">double</span> <span class="title">delta</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在同一个程序中，其他文件中的函数可以调用gamma和delta，但是不能调用beta，因为以static 存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。</p>
<p>通常的做法是∶ 用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，否则一般函数声明都默认为extern。</p>
<h3 id="12-2-随机数函数"><a href="#12-2-随机数函数" class="headerlink" title="12.2 随机数函数"></a>12.2 随机数函数</h3><p>ANSI C库提供了<code>rand</code>函数生成随机数。</p>
<p>为了看清楚程序内部的情况，我们使用可移植的 ANSI版本，而不是编译器内置的 rand 函数。可移植版本的方案开始于一个<strong>“种子”数字</strong>。<strong>该函数使用该种子生成新的数，这个新数又成为新的种子。然后，新种子可用于生成更新的种子，以此类推。</strong>该方案要行之有效，随机数函数必须记录它上一次被调用时所使用的种子。这里需要一个静态变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rand0.c ---生成随机数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>; <span class="comment">// 种子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rand0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 默认为外部函数</span></span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>) (next / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// r_drive0.c ---测试rand0函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rand0</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">5</span>; count++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand0());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16838</span><br><span class="line">5758</span><br><span class="line">10113</span><br><span class="line">17515</span><br><span class="line">31051</span><br></pre></td></tr></table></figure>
<p>再次执行，也是同样的结果。因为每次执行，种子开始都是1。</p>
<p>可以引入另一个函数<code>srand1()</code>来重置种子，在<code>rand0.c</code>中新增该函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rand0.c ---生成随机数和重置种子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> next = <span class="number">1</span>; <span class="comment">// 种子</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rand0</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>) (next / <span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">srand1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rand0</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">srand1</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> seed;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Please enter your choice for seed.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;seed) == <span class="number">1</span>) &#123;</span><br><span class="line">        srand1(seed); <span class="comment">// 重置种子</span></span><br><span class="line">        <span class="keyword">for</span> (count = <span class="number">0</span>; count &lt; <span class="number">5</span>; count++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, rand0());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Please enter next seed (q to quit):\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Please enter your choice for seed.</span><br><span class="line">2</span><br><span class="line">908</span><br><span class="line">22817</span><br><span class="line">10239</span><br><span class="line">12914</span><br><span class="line">25837</span><br><span class="line">Please enter next seed (q to quit):</span><br><span class="line">3</span><br><span class="line">17747</span><br><span class="line">7107</span><br><span class="line">10365</span><br><span class="line">8312</span><br><span class="line">20622</span><br><span class="line">Please enter next seed (q to quit):</span><br><span class="line">1</span><br><span class="line">16838</span><br><span class="line">5758</span><br><span class="line">10113</span><br><span class="line">17515</span><br><span class="line">31051</span><br><span class="line">Please enter next seed (q to quit):</span><br><span class="line">q</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>
<p>注意：<code>stdlib</code>为库函数<code>srand</code>提供原型。</p>
<h3 id="12-3-分配内存"><a href="#12-3-分配内存" class="headerlink" title="12.3 分配内存"></a>12.3 分配内存</h3><h4 id="12-3-1-malloc函数"><a href="#12-3-1-malloc函数" class="headerlink" title="12.3.1 malloc函数"></a>12.3.1 malloc函数</h4><p>所有程序都必须预留足够的内存来储存程序使用的数据。这些内存中有些是自动分配的。例如，以下声明∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> x;</span><br><span class="line"><span class="keyword">char</span> place[] = <span class="string">&quot;Dancing Oxen Creek&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>为一个float类型的值和一个字符串预留了足够的内存，或者可以显式指定分配一定数量的内存∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> plates[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>该声明预留了100个内存位置，每个位置都用于储存int类型的值。声明还为内存提供了一个标识符。因此，可以使用<code>x</code>或<code>place</code>识别数据。</p>
<hr>
<p>c可以在程序运行时分配更多的内存。主要的工具是 <code>malloc</code>函数，该函数接受一个参数∶所需的<strong>内存字节数</strong>。malloc函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说，malloc分配内存，但是不会为其赋名。然而，它确实<strong>返回动态分配内存块的首字节地址</strong>。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。</p>
<p>C使用一个新的类型：指向void的指针。该类型相当于一个”通用指针”。malloc函数可用于返回指向数组的指针、指向结构的指针等，<strong>所以通常该函数的返回值会被强制转换为匹配的类型</strong>。在ANSIC中，应该坚持使用强制类型转换，提高代码的可读性。然而，把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。如果 malloc分配内存失败，将返回空指针。</p>
<p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void * malloc(size_t size)</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> * ptd;</span><br><span class="line">ptd = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(<span class="number">30</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>
<p>以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让ptd指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式<code>ptd[0]</code>访问该块的首元素，<code>ptd[1]</code>访问第2个元素，以此类推。</p>
<p>现在可以使用malloc函数来创建<strong>动态数组</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptd = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure>
<p><strong>通常，malloc要与free配套使用</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptd = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">free</span>(ptd); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>
<p>free函数的参数是之前malloc返回的地址，该函数释放之前 malloc分配的内存。因此，<strong>动态分配内存的存储期从调用malloc分配内存到调用free释放内存为止</strong>。设想malloc和free管理着一个内存池。每次调用malloc分配内存给程序使用，每次调用free把内存归还内存池中，这样便可重复使用这些内存。free的参数应该是一个指针，指向由 malloc分配的一块内存。<strong>不能用 free释放通过其他方式（如，声明一个数组）分配的内存</strong>。</p>
<h4 id="12-3-2-free函数"><a href="#12-3-2-free函数" class="headerlink" title="12.3.2 free函数"></a>12.3.2 free函数</h4><p><strong>头文件</strong>：<code>stdlib</code></p>
<p><strong>原型</strong>：<code>void free(void * ptr);</code></p>
<p><strong>参数</strong>：指向要解分配的内存的指针</p>
<p>静态内存的数量在编译时是固定的，在程序运行期间也不会改变。</p>
<p>自动变量使用的内存数量在程序执行期间自动增加或减少。</p>
<p>动态分配的内存数量只会增加，除非用free进行释放。例如，假设有一个创建数组临时副本的函数，其代码框架如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> glad[<span class="number">2000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        gobble(glad, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">(<span class="keyword">double</span> ar[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> * temp = (<span class="keyword">double</span> *) <span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">    <span class="comment">// other code..</span></span><br><span class="line">    <span class="comment">// free(temp); 假设忘记使用free()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1次调用 gobble时，它创建了指针 temp，并调用 malloc分配了16000字节的内存（假设double为8字节）。假设如代码注释所示，遗漏了free。当函数结束时，作为自动变量的指针 temp 也会消失。但是它所指向的16000字节的内存却仍然存在。由于 temp 指针已被销毁，所以无法访问这块内存，它也不能被重复使用，因为代码中没有调用free释放这块内存。</p>
<p>第2次调用 gobble时，它又创建了指针 temp，并调用malloc分配了16000字节的内存。第1次分配的16000字节内存已不可用，所以malloc分配了另外一块16000字节的内存。当函数结束时，该内存块也无法被再访问和再使用。</p>
<p>循环要执行1000次，所以在循环结束时，内存池中有1600万字节被占用。实际上，也许在循环结束之前就已耗尽所有的内存。这类问题被称为<strong>内存泄漏</strong>（memory leak）。在函数末尾处调用free函数可避免这类问题发生。</p>
<h4 id="12-3-3-calloc函数"><a href="#12-3-3-calloc函数" class="headerlink" title="12.3.3 calloc函数"></a>12.3.3 calloc函数</h4><p>分配内存还可以使用<code>calloc()</code>：</p>
<p>函数原型：<code>void* calloc(unsigned int num, unsigned int size);</code>，第一个参数是所需的存储单元数量，第二个参数是存储单元的大小（以字节为单位）</p>
<p>功能：在内存的动态存储区中分配num个长度为size的连续空间，函数返回一个指向分配起始地址的指针；如果分配不成功，返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> * newmem = (<span class="keyword">long</span> *) <span class="built_in">calloc</span>(<span class="number">100</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br></pre></td></tr></table></figure>
<p>free函数也可用于释放calloc分配的内存。</p>
<h3 id="12-4-ANSI-C类型限定符"><a href="#12-4-ANSI-C类型限定符" class="headerlink" title="12.4 ANSI C类型限定符"></a>12.4 ANSI C类型限定符</h3><p>通常用类型和存储类别来描述一个变量。</p>
<p>C90 还新增了两个属性∶恒常性（constancy）和易变性（volatility）。这两个属性可以分别用关键字 <code>const</code> 和 <code>volatile[ˈvɑːlətl]</code> 来声明，以这两个关键字创建的类型是<strong>限定类型</strong>（qualified type）。</p>
<p>C99标准新增了第3个限定符∶<code>restrict</code>，用于提高编译器优化。</p>
<p>C11标准新增了第4个限定符∶<code>_Atomic</code>。C11提供一个可选库，由stdatomic.h管理，以支持并发程序设计，而且 Atomic是可选支持项。</p>
<h4 id="12-4-1-const类型限定符"><a href="#12-4-1-const类型限定符" class="headerlink" title="12.4.1 const类型限定符"></a>12.4.1 const类型限定符</h4><p>以const关键字声明的对象，其值不能通过赋值或递增、递减来修改。在ANSI兼容的编译器中，以下代码∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nochange; <span class="comment">// 不允许修改nochange</span></span><br><span class="line">nochange = <span class="number">12</span>; <span class="comment">// 编译报错</span></span><br></pre></td></tr></table></figure>
<p>但是可以初始化const变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> nochange = <span class="number">12</span>; <span class="comment">// 允许</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 数组不允许被修改</span></span><br></pre></td></tr></table></figure>
<h5 id="①-指针和形参使用const"><a href="#①-指针和形参使用const" class="headerlink" title="① 指针和形参使用const"></a>① 指针和形参使用const</h5><p>指针：要注意区分是限定指针本身，还是限定指针指向的值。</p>
<ul>
<li>示例1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> * ptr = &amp;a; <span class="comment">// ptr指向一个int类型的const值，ptr指向地址的存储的值不能被改变，但ptr的指向可以改变</span></span><br><span class="line">	<span class="comment">// *ptr = 2; // 编译不通过</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    ptr = &amp;b; <span class="comment">// 允许，让ptr指向b的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>示例2</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ptr; <span class="comment">// ptr指向的地址不能改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> prt; <span class="comment">// 两者都不能被改变</span></span><br></pre></td></tr></table></figure>
<p>const 关键字的常见用法是<strong>声明为函数形参的指针</strong>。例如，假设有一个函数要调用 display 显示一个数组的内容。要把数组名作为实际参数传递给该函数，但是数组名是一个地址。该函数可能会更改主调函数中的数据，但是下面的原型保证了数据不会被更改∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * <span class="built_in">array</span>, <span class="keyword">int</span> limit)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="②-全局数据使用const"><a href="#②-全局数据使用const" class="headerlink" title="② 全局数据使用const"></a>② 全局数据使用const</h5><p>前面讲过，使用全局变量是一种冒险的方法，因为这样做暴露了数据，程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的危险，因此用 const 限定符声明全局数据很合理。</p>
<p>然而，在文件间共享const 数据要小心。可以采用两个策略。</p>
<ul>
<li>第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（用extern 关键字）∶</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c 定义了一些外部const变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c 引用这些变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">double</span> PI;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二，把const变量放在一个头文件中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constant.h</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file1.c 使用这些变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;constant.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c 使用这些变量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;constant.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>注意：static使得变量具有内部链接（只在本文件中可见）；多个源文件引用该头文件，相当于在不同源文件中<strong>定义同名static变量</strong>，换句话说，这种方案相当于给每个文件提供了一个单独的数据副本。</p>
<blockquote>
<p>示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C___LEARN_CONSTANT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C___LEARN_CONSTANT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C___LEARN_CONSTANT_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;constant.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_address</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test01: PI address=%p\n&quot;</span>, &amp;PI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;constant.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_address</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    print_address();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test02: PI address=%p&quot;</span>, &amp;PI);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：发现PI的地址并不相同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test01: PI address=00847B30</span><br><span class="line">test02: PI address=00847B58</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充1</p>
</blockquote>
<p>如果将<strong>全局变量</strong>定义在头文件中，然后又在多处include该头文件，会导致全局变量的重复定义，从而无法编译：<code>multiple definition of xxx</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//b.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> B_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_H_</span></span><br><span class="line"><span class="keyword">int</span> c_data = <span class="number">100</span>;    <span class="comment">//在头文件b.h中定义了全局变量c_data</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span>        <span class="comment">//导入b.h导致c_data被定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun_b</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span>        <span class="comment">//导入b.h导致c_data被定义</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	fun_b();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">由于b.cpp和main.cpp都include了头文件b.h，相当于c_data被定义了两遍</span><br><span class="line">因此导致编译器报错：multiple definition of `c_data<span class="number">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这一规则有一个例外：<strong>如果这个全局变量是const型的，那么可以在头文件中对其进行定义，且不会导致重复定义</strong>。</p>
<p>因此，<strong>对于const类型变量，可以不用加static进行修饰</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> C___LEARN_CONSTANT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C___LEARN_CONSTANT_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926</span>; <span class="comment">// 允许</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//C___LEARN_CONSTANT_H</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充2：头文件相关知识</p>
</blockquote>
<ul>
<li>include作用：在include的地方，把头文件里的内容原封不动的复制到引用该头文件的地方。</li>
<li><p>头文件引用有两种形式：<code>#include &lt; stdio.h&gt;</code> 和 <code>include &quot;main.h&quot;</code>。</p>
<ul>
<li>用<code>&lt; &gt;</code>引用的一般是编译器提供的头文件，编译时会在指定的目录中去查找头文件。具体是哪个目录，编译器知道，我们不用关心。</li>
<li>用<code>&quot;&quot;</code>引用的一般是自己写的头文件，编译时，编译器会在项目所在的文件夹中进行查找。</li>
</ul>
</li>
<li><p>头文件内容和格式：一般包括宏定义， 全局变量， 函数原型声明。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 头文件名 	<span class="comment">//头文件名的格式为&quot;_头文件名_&quot;，注意要大写</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 头文件名</span></span><br><span class="line"></span><br><span class="line">头文件内容</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="12-4-2-volatile类型限定符"><a href="#12-4-2-volatile类型限定符" class="headerlink" title="12.4.2 volatile类型限定符"></a>12.4.2 volatile类型限定符</h4><p>volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中<strong>共享数据</strong>。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。或者一个地址用于接受另一台计算机传入的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> locl;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> * ploc;</span><br></pre></td></tr></table></figure>
<p>引入volatile的原因在于它<strong>涉及编译器的优化</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val1 = x;</span><br><span class="line"><span class="comment">// 一些不使用x的代码</span></span><br><span class="line">val2 = x;</span><br></pre></td></tr></table></figure>
<p>编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x 的值临时储存在<strong>寄存器</strong>(CPU)中，然后在val2需要使用x时，才从寄存器中（而不是从原始内存位置上）读取x 的值，以节约时间。这个过程被称为<strong>高速缓存</strong>（caching）。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这样优化了。</p>
<p>如果没有volatile关键字，编译器就不知道这种事情是否会发生（易变或者不易变）。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码（使用高速缓存）。</p>
<p>即volatile的作用是：</p>
<ul>
<li>变量声明为volatile时，不使用高速缓存，因为编译器认为该变量易变</li>
<li>变量不声明为volatile时，编译器认为该变量不会改变，使用高速缓存存储该变量的值。</li>
</ul>
<h2 id="13-文件输入-输出"><a href="#13-文件输入-输出" class="headerlink" title="13 文件输入/输出"></a>13 文件输入/输出</h2><h3 id="13-1-与文件通信"><a href="#13-1-与文件通信" class="headerlink" title="13.1 与文件通信"></a>13.1 与文件通信</h3><h4 id="13-1-1-文件"><a href="#13-1-1-文件" class="headerlink" title="13.1.1 文件"></a>13.1.1 文件</h4><p>文件通常是在磁盘或固态硬盘上的一段已命名的存储区。</p>
<h4 id="13-1-2-文件模式"><a href="#13-1-2-文件模式" class="headerlink" title="13.1.2 文件模式"></a>13.1.2 文件模式</h4><p>C把文件看作是一系列连续的字节，每个字节都能被单独读取。这与UNIX环境中（C的发源地）的文件结构相对应。由于其他环境中可能无法完全对应这个模型，C提供两种文件模式∶文本模式和二进制模式。</p>
<p>所有文件的内容都以<strong>二进制形式</strong>（0或1）储存。</p>
<p>如果文件最初使用二进制编码的字符（例如，ASCII或Unicode）表示文本（就像C字符串那样），该文件就是<strong>文本文件</strong>，其中包含文本内容。</p>
<p>如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于long或double类型的值）或图片或音乐编码，该文件就是<strong>二进制文件</strong>，其中包含二进制内容。</p>
<h4 id="13-1-3-IO的级别"><a href="#13-1-3-IO的级别" class="headerlink" title="13.1.3 IO的级别"></a>13.1.3 IO的级别</h4><p>除了选择文件的模式，大多数情况下，还可以选择I/O的两个级别（即处理文件访问的两个级别）。</p>
<p><strong>底层I/O</strong>（low-levelI/O）使用操作系统提供的基本I/O服务。</p>
<p><strong>标准高级I/O</strong>（standard high-level I/O）使用C库的标准包和stdio.h头文件定义。</p>
<p>因为无法保证所有的操作系统都使用相同的底层I/O模型，C标准只支持标准I/O包。有些实现会提供底层库，但是C标准建立了可移植的I/O模型，我们主要讨论这些I/O。</p>
<h4 id="13-1-4-标准文件"><a href="#13-1-4-标准文件" class="headerlink" title="13.1.4 标准文件"></a>13.1.4 标准文件</h4><p>C程序会自动打开3个文件，它们被称为<strong>标准输入</strong>（standard input）、<strong>标准输出</strong>（standard output）和<strong>标准错误输出</strong>（standard error output）。输入输出的中心是<strong>程序</strong>。</p>
<p>在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。</p>
<p>通常，标准输入为程序提供输入，它是 getchar和 scanf使用的文件。程序通常输出到标准输出，它是 putchar、puts和printf使用的文件。</p>
<h3 id="13-2-标准IO"><a href="#13-2-标准IO" class="headerlink" title="13.2 标准IO"></a>13.2 标准IO</h3><p>一个小程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> <span class="comment">// 提供exit()的原型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch; </span><br><span class="line">    FILE *fp; <span class="comment">// 文件指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s filename\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fopen打开文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从标准输入中获取字符并显示</span></span><br><span class="line">    <span class="keyword">while</span>((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">        putc(ch, <span class="built_in">stdout</span>);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放指针</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File %s has %lu characters.\n&quot;</span>, argv[<span class="number">1</span>], count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!File E:\develop\study\project-study\C++_learn\a.txt has 12 characters.</span><br></pre></td></tr></table></figure>
<h4 id="13-2-1-检查命令行参数"><a href="#13-2-1-检查命令行参数" class="headerlink" title="13.2.1 检查命令行参数"></a>13.2.1 检查命令行参数</h4><p>首先，上述程序检查<code>argc</code>的值，查看是否有命令行参数。如果没有，程序将打印一条消息并退出程序。</p>
<p><code>exit</code>函数关闭所有打开的文件并结束程序。<code>exit</code>的参数被传递给一些操作系统，包括UNIX、Linux、Windows和MS-DOS，以供其他程序使用。</p>
<p>通常的惯例是∶<strong>正常结束的程序传递0，异常结束的程序传递非零值</strong>。C标准要求0或宏<code>EXIT SUCCESS</code>用于表明成功结束程序，宏<code>EXIT FAILURE</code>用于表明结束程序失败。这些宏和exit原型都位于<code>stdlib.h</code>头文件中，如下所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127115316317.png" alt="image-20221127115316317"></p>
<h4 id="13-2-2-fopen"><a href="#13-2-2-fopen" class="headerlink" title="13.2.2 fopen"></a>13.2.2 fopen</h4><p> fopen函数用于打开文件，函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>filename</code>：待打开文件的名称</li>
<li><code>type</code>：指定待打开文件的模式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127115554443.png" alt="image-20221127115554443"></p>
<p>程序成功打开文件后，fopen将返回<strong>文件指针</strong>（file pointer），其他I/O函数可以使用这个指针指定该文件。文件指针（该例中是<code>fp</code>）的类型是指向<code>FILE</code>的指针，FILE是一个定义在<code>stdio.h</code>中的派生类型。</p>
<p>文件指针fp并不指向实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的I/O函数所用的缓冲区信息。因为标准库中的I/O函数使用缓冲区，所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。标准I/O函数根据这些信息在必要时决定再次填充或清空缓冲区。fp指向的数据对象包含了这些信息（该数据对象是一个C结构）。</p>
<h4 id="13-2-3-getc和putc"><a href="#13-2-3-getc和putc" class="headerlink" title="13.2.3 getc和putc"></a>13.2.3 getc和putc</h4><p><code>getc()</code>和<code>putc()</code>函数其实和<code>getchar()</code>与<code>putchar()</code>函数十分相似，所不同的是，要告诉<code>getc()</code>和<code>putc()</code>函数使用哪一个文件。</p>
<p>C 库函数 <code>getc</code> 从指定的流 stream 获取下一个字符（一个无符号字符），并把位置标识符往前移动。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了要在上面执行操作的流。</li>
<li>该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。</li>
</ul>
<p>C 库函数 <code>getchar</code> 从标准输入 <code>stdin</code> 获取一个字符（一个无符号字符）。这等同于 <strong>getc</strong> 带有 <code>stdin</code> 作为参数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getc(<span class="built_in">stdin</span>); <span class="comment">// 等同于getchar();</span></span><br></pre></td></tr></table></figure>
<hr>
<p>C 库函数 <code>putc()</code> 把参数 <strong>char</strong> 指定的字符（一个无符号字符）写入到指定的流 stream 中，并把位置标识符往前移动。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> <span class="keyword">char</span>, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<p>当第二个参数为<code>stdout</code>时，等同于<code>putchar</code>；</p>
<h4 id="13-2-4-文件结尾"><a href="#13-2-4-文件结尾" class="headerlink" title="13.2.4 文件结尾"></a>13.2.4 文件结尾</h4><p>从文件中读取数据的程序在读到文件结尾时要停止。如果 getc函数在读取一个字符时发现是文件结尾，它将返回一个特殊值<code>EOF</code>。所以C程序只有在读到超过文件末尾时才会发现文件的结尾（一些其他语言用一个特殊的函数在读取之前测试文件结尾，C语言不同）。</p>
<p>为了避免读到空文件，应该使用入口条件循环（不是do while循环）进行文件输入。鉴于getc（和其他C输入函数）的设计，程序应该在进入循环体之前先尝试读取。如下面设计所示∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch; <span class="comment">// 存储读取文件得到的字符</span></span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">ch = getc(fp); <span class="comment">// 获取初始输入</span></span><br><span class="line"><span class="keyword">while</span>(ch != EOF) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">// 处理输入</span></span><br><span class="line">    ch = getc(fp); <span class="comment">// 获取下一个输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码可以简化为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch; <span class="comment">// 存储读取文件得到的字符</span></span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>((ch = getc(fp)) != EOF) &#123;</span><br><span class="line">    <span class="built_in">putchar</span>(ch); <span class="comment">// 处理输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-2-5-fclose"><a href="#13-2-5-fclose" class="headerlink" title="13.2.5 fclose"></a>13.2.5 fclose</h4><p><code>fclose(fp)</code>函数关闭fp指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，<code>fclose</code>函数返回0，否则返回<code>EOF</code>∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fclose(fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error in closing file!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="13-2-6-指向标准文件的指针"><a href="#13-2-6-指向标准文件的指针" class="headerlink" title="13.2.6 指向标准文件的指针"></a>13.2.6 指向标准文件的指针</h4><p><code>stdio.h</code>头文件把3个文件指针与3个标准文件相关联，C程序会自动打开这3个标准文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221127181656117.png" alt="image-20221127181656117"></p>
<p>这些文件指针都是指向FILE的指针，所以它们可用作标准I/O函数的参数，如<code>fclose</code>中的fp。</p>
<h3 id="13-3-一个简单的文件压缩程序"><a href="#13-3-一个简单的文件压缩程序" class="headerlink" title="13.3 一个简单的文件压缩程序"></a>13.3 一个简单的文件压缩程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    FILE *in, *out;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    <span class="keyword">char</span> name[LEN];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s filename.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置输入</span></span><br><span class="line">    <span class="keyword">if</span> ((in = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Couldn&#x27;t open the file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置输出</span></span><br><span class="line">    <span class="built_in">strncpy</span>(name, argv[<span class="number">1</span>], LEN - <span class="number">5</span>); <span class="comment">// 拷贝文件名</span></span><br><span class="line">    name[LEN - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(name, <span class="string">&quot;.red&quot;</span>); <span class="comment">// 在文件名后添加.red</span></span><br><span class="line">    <span class="keyword">if</span> ((out = fopen(name, <span class="string">&quot;w&quot;</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Can&#x27;t create output file.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝数据</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = getc(in)) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count++ % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            putc(ch, out); <span class="comment">// 打印3个字符中的第一个字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    <span class="keyword">if</span> (fclose(in) != <span class="number">0</span> || fclose(out) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error in closing files.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-文件IO"><a href="#13-4-文件IO" class="headerlink" title="13.4 文件IO"></a>13.4 文件IO</h3><p>文件I/O函数要用FILE指针指定待处理的文件。与 getc、putc类似，这些函数都要求用指向 FILE 的指针（如，stdout）指定一个文件，或者使用fopen的返回值。</p>
<h4 id="13-4-1-fprintf和fscanf"><a href="#13-4-1-fprintf和fscanf" class="headerlink" title="13.4.1 fprintf和fscanf"></a>13.4.1 fprintf和fscanf</h4><p>文件I/O函数fprintf和fscanf函数的工作方式与printf和scanf类似，区别在于前者需要用第1个参数指定待处理的文件。当第一个参数是<code>stdout/stderr</code>和<code>stdin</code>时，二者对应相同。</p>
<p>C 库函数<code>fprintf</code>发送格式化输出到流 stream 中。函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了流。</li>
<li><strong>format</strong> — 这是 C 字符串，包含了要被写入到流 stream 中的文本。</li>
<li>如果成功，则返回写入的字符总数，否则返回一个负数。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv [])</span> </span>&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %s %s %d&quot;</span>, <span class="string">&quot;We&quot;</span>, <span class="string">&quot;are&quot;</span>, <span class="string">&quot;in&quot;</span>, <span class="number">2022</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这将创建文件 <strong>a.txt</strong>，它的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We are in 2022</span><br></pre></td></tr></table></figure>
<h4 id="13-4-2-fgets和fputs"><a href="#13-4-2-fgets和fputs" class="headerlink" title="13.4.2 fgets和fputs"></a>13.4.2 fgets和fputs</h4><p><code>fgets</code>和<code>fputs</code>的第二个参数为<code>stdin</code>和<code>stdout</code>时，等同于<code>gets</code>和<code>puts</code></p>
<p>C 库函数 <code>fgets</code> 从指定的流 stream 读取一行，并把它存储在 <strong>str</strong> 所指向的字符串内。当读取 <strong>(n-1)</strong> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> n, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>str</strong> — 这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li>
<li><strong>n</strong> — 这是要读取的最大字符数（包括最后的空字符）。通常是使用以 str 传递的数组长度。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了要从中读取字符的流。</li>
<li>如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">60</span>];</span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span> , <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in opening file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( fgets (str, <span class="number">60</span>, fp)!=<span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>C 库函数<code>fputs</code>把字符串写入到指定的流 stream 中，但不包括空字符。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>str</strong> — 这是一个数组，包含了要写入的以空字符终止的字符序列。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流。</li>
<li>该函数返回一个非负值，如果发生错误则返回 EOF。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">60</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开用于读取的文件 */</span></span><br><span class="line">    fp = fopen(<span class="string">&quot;a.txt&quot;</span> , <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Error in opening file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( fgets (str, <span class="number">60</span>, fp)!=<span class="literal">NULL</span> ) &#123;</span><br><span class="line">        <span class="comment">/* 向标准输出 stdout 写入内容 */</span></span><br><span class="line">        <span class="built_in">fputs</span>(str, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-5-标准IO原理"><a href="#13-5-标准IO原理" class="headerlink" title="13.5 标准IO原理"></a>13.5 标准IO原理</h3><p>通常，使用标准I/O的第1步是调用fopen打开文件（C程序会自动打开3种标准文件）。fopen函数不仅打开一个文件，还创建了一个<strong>缓冲区</strong>（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构。另外，fopen返回一个指向该结构的指针，以便其他函数知道如何找到该结构。</p>
<p>假设把该指针赋给一个指针变量fp，我们说fopen函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进制模式打开该文件，就获得一个二进制流。</p>
<p>这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数（统计实际拷贝进缓冲区的字节数）。</p>
<p>通常，使用标准I/O的第2步是调用一个定义在stdio.h中的输入函数，如fscanf、getc或 fgets。一调用这些函数，文件中的数据块就被拷贝缓冲区中。缓冲区的大小因实现而异。最初调用函数，除了填充缓冲区外，还要设置fp所指向的结构中的值。尤其要设置流中的当前位置和拷贝进缓冲区的字节数。通常，当前位置从字节0开始。</p>
<p>在初始化结构和缓冲区后，输入函数按要求从缓冲区中读取数据。在它读取数据时，文件位置指示器被设置为指向刚读取字符的下一个字符。由于stdio.h系列的所有输入函数都使用相同的缓冲区，所以调用任何一个函数都将从上一次函数停止调用的位置开始。</p>
<p>当输入函数发现已读完缓冲区中的所有字符时，会请求把下一个缓冲大小的数据块从文件拷贝到该缓冲区中。以这种方式，输入函数可以读取文件中的所有内容，直到文件结尾。函数在读取缓冲区中的最后一个字符后，把结尾指示器设置为真。于是，下一次被调用的输入函数将返回EOF。</p>
<p>输出函数以类似的方式把数据写入缓冲区。当缓冲区被填满时，数据将被拷贝至文件中。</p>
<h3 id="13-6-其他标准IO函数"><a href="#13-6-其他标准IO函数" class="headerlink" title="13.6 其他标准IO函数"></a>13.6 其他标准IO函数</h3><h4 id="13-6-1-fflush"><a href="#13-6-1-fflush" class="headerlink" title="13.6.1 fflush"></a>13.6.1 fflush</h4><p>刷新流 stream 的输出缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<p>调用fflush函数引起输出缓冲区中所有的未写入数据被发送到fp指定的输出文件。这个过程称为刷新缓冲区。如果fp是空指针，所有输出缓冲区都被刷新。</p>
<h4 id="13-6-2-fread和fwrite"><a href="#13-6-2-fread和fwrite" class="headerlink" title="13.6.2 fread和fwrite"></a>13.6.2 fread和fwrite</h4><p>这是两个<strong>二进制</strong>的标准IO函数。</p>
<p>实际上，所有的数据都是以二进制形式储存的，甚至连字符都以字符码的二进制表示来储存。如果文件中的所有数据都被解释成字符码，则称该文件包含文本数据。如果部分或所有的数据都被解释成二进制形式的数值数据，则称该文件包含二进制数据（另外，用数据表示机器语言指令的文件都是二进制文件）。</p>
<p><code>fread</code>从给定流 <strong>stream</strong> 读取数据到 <strong>ptr</strong> 所指向的数组中。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向带有最小尺寸 <code>size*nmemb</code> 字节的内存块的指针。</li>
<li><strong>size</strong> — 这是要读取的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输入流。</li>
</ul>
<p><code>fwrite</code>把 <strong>ptr</strong> 所指向的数组中的数据写入到给定流 <strong>stream</strong> 中。函数原型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ptr</strong> — 这是指向要被写入的元素数组的指针。</li>
<li><strong>size</strong> — 这是要被写入的每个元素的大小，以字节为单位。</li>
<li><strong>nmemb</strong> — 这是元素的个数，每个元素的大小为 size 字节。</li>
<li><strong>stream</strong> — 这是指向 FILE 对象的指针，该 FILE 对象指定了一个输出流。</li>
</ul>
<h2 id="14-结构和其它数据形式"><a href="#14-结构和其它数据形式" class="headerlink" title="14 结构和其它数据形式"></a>14 结构和其它数据形式</h2><h3 id="14-1-示例：创建图书目录"><a href="#14-1-示例：创建图书目录" class="headerlink" title="14.1 示例：创建图书目录"></a>14.1 示例：创建图书目录</h3><p>字段：书名、作者和价格。</p>
<h3 id="14-2-建立结构声明"><a href="#14-2-建立结构声明" class="headerlink" title="14.2 建立结构声明"></a>14.2 建立结构声明</h3><p>结构声明（structure declaration）描述了一个结构的组织布局。声明类似下面这样∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[MAXTITL];</span><br><span class="line">    <span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct</code>是关键字，<code>book</code>是可选的标记。可以使用该标记引用该结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>
<p>这样把<code>library</code>声明为一个使用book结构布局的结构变量。</p>
<h3 id="14-3-定义结构变量"><a href="#14-3-定义结构变量" class="headerlink" title="14.3 定义结构变量"></a>14.3 定义结构变量</h3><h4 id="14-3-1-概述"><a href="#14-3-1-概述" class="headerlink" title="14.3.1 概述"></a>14.3.1 概述</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>;</span></span><br></pre></td></tr></table></figure>
<p>编译器执行这行代码便创建了一个结构变量library。编译器使用book<strong>模板</strong>为该变量分配空间∶一个内含MAXTITL个元素的char数组、一个内含MAXAUTL个元素的char数组和一个float类型的变量。这些存储空间都与一个名称library结合在一起。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img19/image-20221113075628202.png" alt="image-20221113075628202"></p>
<p>在结构变量的声明中，<code>struct book</code>所起的作用相当于一般声明中的int 或float。例如，可以定义两个struct book类型的变量，或者甚至是指向struct book类型结构的指针∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">doyle</span>, <span class="title">panshin</span>, * <span class="title">ptbook</span>;</span></span><br></pre></td></tr></table></figure>
<p>声明的简化形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[MAXTITL];</span><br><span class="line">    <span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">// 无结构标记</span></span><br><span class="line">    <span class="keyword">char</span> title[MAXTITL];</span><br><span class="line">    <span class="keyword">char</span> author[MAXAUTL];</span><br><span class="line">    <span class="keyword">float</span> value;</span><br><span class="line">&#125; library;</span><br></pre></td></tr></table></figure>
<h4 id="14-3-2-初始化结构"><a href="#14-3-2-初始化结构" class="headerlink" title="14.3.2 初始化结构"></a>14.3.2 初始化结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span> &#123;</span></span><br><span class="line">    <span class="string">&quot;The Pious Pirate and the Devious Damsel&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Renee Vivotte&quot;</span>,</span><br><span class="line">    <span class="number">1.95</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-3-3-访问结构成员"><a href="#14-3-3-访问结构成员" class="headerlink" title="14.3.3 访问结构成员"></a>14.3.3 访问结构成员</h4><p>使用结构成员运算符<code>.</code>来访问结构中的成员。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">library.title;</span><br><span class="line">library.author; <span class="comment">// char数组变量</span></span><br><span class="line">library.value; <span class="comment">// float变量</span></span><br></pre></td></tr></table></figure>
<h4 id="14-3-4-结构的初始化器"><a href="#14-3-4-结构的初始化器" class="headerlink" title="14.3.4 结构的初始化器"></a>14.3.4 结构的初始化器</h4><p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只初始化一个成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">b1</span> =</span> &#123;</span><br><span class="line">    .value = <span class="number">9.9</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以按照任意顺序给成员变量赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">b1</span> =</span> &#123;</span><br><span class="line">    .value = <span class="number">9.9</span>,</span><br><span class="line">    .author = <span class="string">&quot;Mark&quot;</span>,</span><br><span class="line">    .title = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="14-4-结构数组"><a href="#14-4-结构数组" class="headerlink" title="14.4 结构数组"></a>14.4 结构数组</h3><h4 id="14-4-1-声明结构数组"><a href="#14-4-1-声明结构数组" class="headerlink" title="14.4.1 声明结构数组"></a>14.4.1 声明结构数组</h4><p>显然，每本书的基本信息都可以用一个<code>book</code>类型的结构变量来表示。因此，可以创建结构数组来存储这些书籍的信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book</span> <span class="title">library</span>[<span class="title">MAXBKS</span>];</span> <span class="comment">// book类型结构的数组</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img19/image-20221113080807359.png" alt="image-20221113080807359"></p>
<h4 id="14-4-2-标识结构数组的成员"><a href="#14-4-2-标识结构数组的成员" class="headerlink" title="14.4.2 标识结构数组的成员"></a>14.4.2 标识结构数组的成员</h4><p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">library[<span class="number">0</span>].value; <span class="comment">// 第一个数组元素（结构）的value</span></span><br><span class="line">library[<span class="number">0</span>].title[<span class="number">4</span>]; <span class="comment">// 数组中library[0]元素的title成员的一个字符</span></span><br></pre></td></tr></table></figure>
<h3 id="14-5-嵌套结构"><a href="#14-5-嵌套结构" class="headerlink" title="14.5 嵌套结构"></a>14.5 嵌套结构</h3><p>有时，在一个结构中包含另一个结构（嵌套结构）很方便，例如创建一个朋友的信息，结构中需要一个成员表示朋友的名字，而名字可以用一个结构来表示，包含姓和名两个成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span> <span class="comment">// 第一个结构</span></span><br><span class="line">    <span class="keyword">char</span> first[LEN];</span><br><span class="line">    <span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span> <span class="comment">// 第二个结构</span></span><br><span class="line">  	<span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span> <span class="comment">// 嵌套结构</span></span><br><span class="line">    <span class="keyword">char</span> favfood[LEN];</span><br><span class="line">    <span class="keyword">char</span> job[LEN];</span><br><span class="line">    <span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span> =</span> &#123; <span class="comment">// 初始化一个结构变量</span></span><br><span class="line">        &#123;<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;Lincoln&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&quot;potato&quot;</span>,</span><br><span class="line">        <span class="string">&quot;cook&quot;</span>,</span><br><span class="line">        <span class="number">12345678</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-6-指向结构的指针"><a href="#14-6-指向结构的指针" class="headerlink" title="14.6 指向结构的指针"></a>14.6 指向结构的指针</h3><blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span> <span class="comment">// 第一个结构</span></span><br><span class="line">    <span class="keyword">char</span> first[LEN];</span><br><span class="line">    <span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> &#123;</span> <span class="comment">// 第二个结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">handle</span>;</span> <span class="comment">// 嵌套结构</span></span><br><span class="line">    <span class="keyword">char</span> favfood[LEN];</span><br><span class="line">    <span class="keyword">char</span> job[LEN];</span><br><span class="line">    <span class="keyword">float</span> income;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结构数组，并初始化</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> <span class="title">fellow</span>[2] =</span> &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;Lincoln&quot;</span>&#125;,</span><br><span class="line">                    <span class="string">&quot;potato&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;cook&quot;</span>,</span><br><span class="line">                    <span class="number">12345678.00</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                    &#123;<span class="string">&quot;Rodney&quot;</span>, <span class="string">&quot;Villard&quot;</span>&#125;,</span><br><span class="line">                    <span class="string">&quot;tripe&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;coach&quot;</span>,</span><br><span class="line">                    <span class="number">432100.00</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span> <span class="comment">// 指向结构数组的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;address #1: %p #2: %p\n&quot;</span>, &amp;fellow[<span class="number">0</span>], &amp;fellow[<span class="number">1</span>]);</span><br><span class="line">    him = &amp;fellow[<span class="number">0</span>]; <span class="comment">// 指向结构数组的第一个位置（仍然是一个结构）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pointer #1: %p #2: %p\n&quot;</span>, him, him + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;him-&gt;income is %.2f (*him).income is %.2f\n&quot;</span>, him-&gt;income, (*him).income);</span><br><span class="line">    him++; <span class="comment">// 指向下一个结构</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;him-&gt;favfood is %s him-&gt;handle.last is %s\n&quot;</span>, him-&gt;favfood, him-&gt;handle.last);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">address #1: 00BBFB78 #2: 00BBFBCC</span><br><span class="line">pointer #1: 00BBFB78 #2: 00BBFBCC</span><br><span class="line">him-&gt;income is 12345678.00 (*him).income is 12345678.00</span><br><span class="line">him-&gt;favfood is tripe him-&gt;handle.last is Villard</span><br></pre></td></tr></table></figure>
<p>程序解析详见下面。</p>
<h4 id="14-6-1-声明和初始化结构指针"><a href="#14-6-1-声明和初始化结构指针" class="headerlink" title="14.6.1 声明和初始化结构指针"></a>14.6.1 声明和初始化结构指针</h4><p>声明结构指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guy</span> * <span class="title">him</span>;</span></span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;barney; <span class="comment">// 如果barney是一个guy类型的结构</span></span><br></pre></td></tr></table></figure>
<p>注意，和数组名不同，<strong>结构名不是结构的地址</strong>。</p>
<p>在本例中，<code>fellow</code>是一个结构数组，因此<code>fellow[0]</code>仍然是一个结构，所以：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">him = &amp;fellow[<span class="number">0</span>];</span><br><span class="line">him++; <span class="comment">// 指向fellow[1]</span></span><br></pre></td></tr></table></figure>
<p>输出的前两行说明赋值成功。比较这两行发现，<code>him</code>指向<code>fellow[0]</code>，<code>him + 1</code>指<code>向fellow[1]</code>。注意，him加1相当于him指向的地址加84。在十六进制中，<code>874-820=54（十六进制）=84（十进制）</code>，因为每个guy 结构都占用84字节的内存∶names.first 占用20字节，names.last 占用20 字节，favfood占用20字节，job占用20字节，income占用4字节（假设系统中float占用4字节）。</p>
<p>顺带一提，在有些系统中，<strong>一个结构的大小可能大于它各成员大小之和</strong>。这是因为系统对数据进行校准的过程中产生了一些“缝隙”。例如，有些系统必须把每个成员都放在偶数地址上，或 4的倍数的地址上。在这种系统中，结构的内部就存在未使用的”缝隙”。</p>
<h4 id="14-6-2-用指针访问成员"><a href="#14-6-2-用指针访问成员" class="headerlink" title="14.6.2 用指针访问成员"></a>14.6.2 用指针访问成员</h4><p>有两种方法。</p>
<ul>
<li>方法一：使用<code>-&gt;</code>运算符</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果him == &amp;barney，那么him -&gt; income等价于barney.income</span><br><span class="line">如果him == &amp;fellow[0]，那么him -&gt; income等价于fellow[0].income   </span><br></pre></td></tr></table></figure>
<ul>
<li>方法二：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果him == &amp;fellow[0]，那么*him == fellow[0]</span><br><span class="line">所以：fellow[0].income == (*him).income</span><br></pre></td></tr></table></figure>
<p><code>*him</code>对<code>him</code>解引用，就是<code>fellow[0]</code>结构</p>
<h3 id="14-7-向函数传递结构的信息"><a href="#14-7-向函数传递结构的信息" class="headerlink" title="14.7 向函数传递结构的信息"></a>14.7 向函数传递结构的信息</h3><h4 id="14-7-1-传递结构成员"><a href="#14-7-1-传递结构成员" class="headerlink" title="14.7.1 传递结构成员"></a>14.7.1 传递结构成员</h4><p>只要结构成员是一个具有单个值的数据类型（即，int及其相关类型、char、float、double或指针），便可把它作为参数传递给接受该特定类型的函数。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankFund;</span><br><span class="line">    <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> saveFund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> =</span> &#123;</span><br><span class="line">            <span class="string">&quot;ICBC&quot;</span>,</span><br><span class="line">            <span class="number">12345</span>,</span><br><span class="line">            <span class="string">&quot;Mark&quot;</span>,</span><br><span class="line">            <span class="number">123</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of %.2f.\n&quot;</span>,</span><br><span class="line">           sum(stan.bankFund, stan.saveFund));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stan has a total of 12468.00.</span><br></pre></td></tr></table></figure>
<h4 id="14-7-2-传递结构的地址"><a href="#14-7-2-传递结构的地址" class="headerlink" title="14.7.2 传递结构的地址"></a>14.7.2 传递结构的地址</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankFund;</span><br><span class="line">    <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> saveFund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds *)</span></span>; <span class="comment">// 参数是一个指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> =</span> &#123;</span><br><span class="line">            <span class="string">&quot;ICBC&quot;</span>,</span><br><span class="line">            <span class="number">12345</span>,</span><br><span class="line">            <span class="string">&quot;Mark&quot;</span>,</span><br><span class="line">            <span class="number">123</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of %.2f.\n&quot;</span>,</span><br><span class="line">           sum(&amp;stan));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds * money)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> money-&gt;bankFund + money-&gt;bankFund;</span><br><span class="line">    <span class="comment">// 或者 return (*money).bankFund + (*money).saveFund;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-7-3-传递结构"><a href="#14-7-3-传递结构" class="headerlink" title="14.7.3 传递结构"></a>14.7.3 传递结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNDLEN 50</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">funds</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> bank[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankFund;</span><br><span class="line">    <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> saveFund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds)</span></span>; <span class="comment">// 参数是一个结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">funds</span> <span class="title">stan</span> =</span> &#123;</span><br><span class="line">            <span class="string">&quot;ICBC&quot;</span>,</span><br><span class="line">            <span class="number">12345</span>,</span><br><span class="line">            <span class="string">&quot;Mark&quot;</span>,</span><br><span class="line">            <span class="number">123</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stan has a total of %.2f.\n&quot;</span>,</span><br><span class="line">           sum(stan));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(struct funds moolah)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// moolah是stan的副本，而不是stan本身</span></span><br><span class="line">    <span class="keyword">return</span> moolah.bankFund + moolah.saveFund;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用sum时，编译器根据funds模板创建了一个名为moolah的<strong>自动结构变量</strong>。然后，该结构的各成员被初始化为 stan 结构变量相应成员的值的<strong>副本</strong>。因此，程序使用原来结构的副本进行计算。</p>
<h4 id="14-7-4-其他结构特性"><a href="#14-7-4-其他结构特性" class="headerlink" title="14.7.4 其他结构特性"></a>14.7.4 其他结构特性</h4><p>C允许把一个结构赋值给另一个结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">right_field</span> =</span> &#123;<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;George&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">captain</span> =</span> right_field; <span class="comment">// 把结构初始化为另一个结构</span></span><br></pre></td></tr></table></figure>
<h4 id="14-7-5-结构和结构指针的选择"><a href="#14-7-5-结构和结构指针的选择" class="headerlink" title="14.7.5 结构和结构指针的选择"></a>14.7.5 结构和结构指针的选择</h4><p>假设要编写一个与结构相关的函数，是用结构指针作为参数，还是用结构作为参数和返回值？两者各有优缺点。</p>
<ul>
<li>把结构指针作为参数：<strong>执行效率高</strong>，但是无法保护数据，可以使用<code>const</code>限定符来保护主调函数的数据。</li>
<li>把结构作为参数：函数处理的是原始数据的副本，<strong>缺点是占用内存空间</strong></li>
</ul>
<h4 id="14-7-6-结构中的字符数组和字符指针"><a href="#14-7-6-结构中的字符数组和字符指针" class="headerlink" title="14.7.6 结构中的字符数组和字符指针"></a>14.7.6 结构中的字符数组和字符指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> first[LEN];</span><br><span class="line">    <span class="keyword">char</span> last[LEN];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * first;</span><br><span class="line">    <span class="keyword">char</span> * last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">veep</span> =</span> &#123;<span class="string">&quot;Mark&quot;</span>, <span class="string">&quot;Lincoln&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">treas</span> =</span> &#123;<span class="string">&quot;Brad&quot;</span>, <span class="string">&quot;Pitt&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s and %s&quot;</span>, veep.first, treas.first);</span><br></pre></td></tr></table></figure>
<p>对于结构变量<code>veep</code>，总共要分配40个字节来存储字符，而对于结构变量<code>treas</code>，只存储了两个char类型的地址。地址1，是字符串<code>Brad</code>首字母的存储地址，地址2是字符串<code>Pitt</code>首字母的存储地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names</span> <span class="title">accountant</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnames</span> <span class="title">attorney</span>;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter the last name of your accountant:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, accountant.last);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Enter the last name of your attorney:&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, attorney.last); <span class="comment">/* 这里有一个潜在的危险*/</span></span><br></pre></td></tr></table></figure>
<p>对于<code>accountant</code>变量，他的成员<code>last</code>字符数组将被赋值；而对于<code>attorney</code>变量，<code>scanf</code>将接收到的字符串，放置在指针变量<code>last</code>所指向的地址里，但是<code>last</code>并未进行初始化，因此输入的字符会放在内存中的任何一个地方，可能会导致程序崩溃。</p>
<p>建议：如果要用结构存储字符串，建议使用<strong>字符数组</strong>，而不是字符指针。</p>
<h4 id="14-7-7-使用结构数组的函数"><a href="#14-7-7-使用结构数组的函数" class="headerlink" title="14.7.7 使用结构数组的函数"></a>14.7.7 使用结构数组的函数</h4><p>假设一个函数要处理一个<strong>结构数组</strong>。由于数组名就是该数组的地址，所以可以把它传递给函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define FUNDLEN <span class="number">50</span></span><br><span class="line">#define N <span class="number">2</span></span><br><span class="line"></span><br><span class="line">struct funds &#123;</span><br><span class="line">    <span class="keyword">char</span> bank [FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> bankFund;</span><br><span class="line">    <span class="keyword">char</span> save[FUNDLEN];</span><br><span class="line">    <span class="keyword">double</span> saveFund;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money[], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    struct funds jones[N] = &#123; <span class="comment">// 结构数组jones，数组名jones就是地址</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="string">&quot;ICBC&quot;</span>,</span><br><span class="line">                    <span class="number">12345</span>,</span><br><span class="line">                    <span class="string">&quot;Loan&quot;</span>,</span><br><span class="line">                    <span class="number">123</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="string">&quot;ICBC&quot;</span>,</span><br><span class="line">                    <span class="number">12345</span>,</span><br><span class="line">                    <span class="string">&quot;Party Time Savings&quot;</span>,</span><br><span class="line">                    <span class="number">123</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;The Joneses have a total of $%.2f.\n&quot;</span>, sum(jones, N));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> struct funds money[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        total += money[i].bankFund + money[i].saveFund;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (total);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此指针money的初始值相当于通过下面的表达式获得：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">money = &amp;jones[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<h3 id="14-8-联合"><a href="#14-8-联合" class="headerlink" title="14.8 联合"></a>14.8 联合</h3><h4 id="14-8-1-简介"><a href="#14-8-1-简介" class="headerlink" title="14.8.1 简介"></a>14.8.1 简介</h4><p>联合（union）是一种数据类型，它能在同一个内存空间中储存不同的数据类型（<strong>不是同时储存</strong>）。其典型的用法是，设计一种表以储存<strong>既无规律、事先也不知道顺序的混合类型</strong>。使用联合类型的数组，其中的联合都大小相等，每个联合可以储存各种数据类型。</p>
<ul>
<li>定义带标记的联合模板：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> digit;</span><br><span class="line">    <span class="keyword">double</span> bigfl;</span><br><span class="line">    <span class="keyword">char</span> letter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>根据以上形式声明的结构可以储存一个int类型、一个double类型和char类型的值。然而，声明的联合<strong>只能储存</strong>一个int类型的值或一个double类型的值或char类型的值。</p>
<ul>
<li>定义与hold类型相关的变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">fit</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">save</span>[10];</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> * <span class="title">pu</span>;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以初始化联合，但要注意的是，<strong>联合只能存储一个值</strong>，这与结构不同。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valA</span>;</span></span><br><span class="line">valA.letter = <span class="string">&quot;R&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valB</span> =</span> valA; <span class="comment">// 用另一个联合来初始化</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valC</span> =</span> &#123;<span class="number">88</span>&#125;; <span class="comment">// 初始化联合的digit成员</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">hold</span> <span class="title">valD</span> =</span> &#123;.bigfl = <span class="number">118.2</span>&#125;; <span class="comment">// 指定初始化器</span></span><br></pre></td></tr></table></figure>
<h4 id="14-8-2-使用联合"><a href="#14-8-2-使用联合" class="headerlink" title="14.8.2 使用联合"></a>14.8.2 使用联合</h4><p>下面是联合的一些用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fit.digit = <span class="number">23</span>; <span class="comment">// 把23存储在fit，占用2字节</span></span><br><span class="line">fit.bigfl = <span class="number">2.0</span>; <span class="comment">// 清除23，存储2.0，占用8字节</span></span><br><span class="line">fit.letter = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// 清除2.0，存储h，占用1字节</span></span><br></pre></td></tr></table></figure>
<p>和指针访问结构使用<code>-&gt;</code>运算符一样，用指针访问联合时也要使用<code>-&gt;</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pu = &amp;fit;</span><br><span class="line">x = pu -&gt; digit; <span class="comment">// 相当于 x = fit.digit</span></span><br></pre></td></tr></table></figure>
<h3 id="14-9-枚举类型"><a href="#14-9-枚举类型" class="headerlink" title="14.9 枚举类型"></a>14.9 枚举类型</h3><h4 id="14-9-1-简介"><a href="#14-9-1-简介" class="headerlink" title="14.9.1 简介"></a>14.9.1 简介</h4><p>可以用杖举类型（emumerated type）<strong>声明符号名称</strong>来表示<strong>整型常量</strong>。使用<code>enum</code>关键字，可以创建一个新“类型”并指定它可具有的值（实际上，enum常量是int类型，因此，只要能使用int类型的地方就可以使用枚举类型）。</p>
<p>枚举类型的目的是<strong>提高程序的可读性</strong>。它的语法与结构的语法相同。例如，可以这样声明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> &#123;</span>red, orange, yellow, green, blue, violet&#125;; <span class="comment">// 这里的各个符号名称代表了各个整型常量</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">spectrum</span> <span class="title">color</span>;</span></span><br></pre></td></tr></table></figure>
<p>第1个声明创建了<code>spetrum</code>作为<strong>标记名</strong>，允许把<code>enum spetrum</code>作为一个类型名使用。花括号内的标识符枚举了spectrum变量可能有的值。因此，color 可能的值是 red、orange、yellow 等。这些符号常量被称为<strong>枚举符</strong>（emumerator）。</p>
<p>第2个声明使color作为该类型的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">color = blue;</span><br><span class="line"><span class="keyword">if</span> (color == yellow) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (color = red; color &lt;= violet; color++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-9-2-enum常量"><a href="#14-9-2-enum常量" class="headerlink" title="14.9.2 enum常量"></a>14.9.2 enum常量</h4><p>blue 和 red到底是什么?从技术层面看，<strong>它们是int类型的常量</strong>。例如，假定有前面的枚举声明，可以这样写∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;red = %d, orange = %d\n&quot;</span>, red, orange); <span class="comment">// 0 1</span></span><br></pre></td></tr></table></figure>
<p><strong>red 成为一个有名称的常量，代表整数0</strong>。类似地，其他标识符都是有名称的常量，分别代表1～5。只要是能使用整型常量的地方就可以使用枚举常量。例如，在声明数组时，可以用枚举常量表示数组的大小；在switch语句中，可以把枚举常量作为标签。</p>
<h4 id="14-9-3-赋值"><a href="#14-9-3-赋值" class="headerlink" title="14.9.3 赋值"></a>14.9.3 赋值</h4><p>在枚举声明中，可以为枚举常量指定整数值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">levels</span> &#123;</span>low = <span class="number">100</span>, medium = <span class="number">500</span>, high = <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">feline</span> &#123;</span>cat, lynx = <span class="number">10</span>, puma, tiger&#125;; <span class="comment">// cat = 0(默认),puma = 11, tiger = 12</span></span><br></pre></td></tr></table></figure>
<h4 id="14-9-4-共享命名空间"><a href="#14-9-4-共享命名空间" class="headerlink" title="14.9.4 共享命名空间"></a>14.9.4 共享命名空间</h4><p>C语言使用<strong>名称空间</strong>（<code>namespace</code>）标识程序中的各部分，即通过名称来识别。作用域是名称空间概念的一部分∶两个不同作用域的同名变量不冲突；两个相同作用域的同名变量冲突。</p>
<p>名称空间是分类别的。在特定作用域中的<strong>结构标记、联合标记和枚举标记都共享相同的名称空间</strong>，该名称空间与普通变量使用的空间不同。<strong>这意味着在相同作用域中变量和标记的名称可以相同，不会引起冲突，但是不能在相同作用域中声明两个同名标签或同名变量。</strong>例如，在C中，下面的代码不会产生冲突∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rect; <span class="comment">// 在C中不会冲突</span></span><br></pre></td></tr></table></figure>
<p>尽管如此，以两种不同的方式使用相同的标识符会造成混乱。另外，C++不允许这样做，因为它把标记名和变量名放在相同的名称空间中。</p>
<h3 id="14-10-typedef"><a href="#14-10-typedef" class="headerlink" title="14.10 typedef"></a>14.10 <code>typedef</code></h3><p><code>typedef</code>工具是一个高级数据特性，利用typedef可以为某一类型自定义名称。这方面与<code>#define</code>类似，但是两者有3处不同∶</p>
<ul>
<li>与#define 不同，typedef 创建的符号名只受限于类型，不能用于值</li>
<li><strong>typedef由编译器解释</strong>，不是预处理器</li>
<li>在其受限范围内，typedef比#define更灵活</li>
</ul>
<p>假设要用<code>BYTE</code>这样的符号名表示1字节的数组，则：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> BYTE;</span><br><span class="line"></span><br><span class="line">BYTE x, y[<span class="number">10</span>], *z;</span><br></pre></td></tr></table></figure>
<p>该定义的作用域取决于<code>typedef</code>定义所在的位置。如果定义在函数中，就具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。</p>
<p>通常，typedef定义中用<strong>大写字母</strong>表示被定义的名称，以提醒用户这个类型名实际上是一个符号缩写。当然，也可以用小写。</p>
<hr>
<p>为现有类型创建一个名称，看上去真是多此一举，但是它有时的确很有用。使用typedef可以提高程序的可移植性。之前提到的sizeof运算符的返回类型∶<code>size_t</code>类型，以及time函数的返回类型∶<code>time_t</code>类型。C标准规定sizeof和time返回整数类型，但是让实现来决定具体是什么整数类型。其原因是，C标准委员会认为没有哪个类型对于所有的计算机平台都是最优选择。所以，标准委员会决定建立一个新的类型名（如，time_t），并让实现使用<code>typedef</code>来设置它的具体类型。</p>
<p>以这样的方式，C标准提供以下通用原型∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">time_t</span> <span class="title">time</span><span class="params">(<span class="keyword">time_t</span> *)</span></span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>还可以把typedef用于结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">complex</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> real;</span><br><span class="line">    <span class="keyword">float</span> imag;</span><br><span class="line">&#125; COMPLEX;</span><br></pre></td></tr></table></figure>
<p>然后便可使用COMPLEX类型代替complex结构来表示复数。</p>
<p>使用typedef时要记住，<strong>typedef并没有创建任何新类型</strong>，它只是为某个已存在的类型增加了一个方便使用的<strong>标签</strong>。</p>
<p>通过结构、联合和typedef，C提供了有效处理数据的工具和处理可移植数据的工具。</p>
<h3 id="14-11-函数指针"><a href="#14-11-函数指针" class="headerlink" title="14.11 函数指针"></a>14.11 函数指针</h3><p>函数指针：假设有一个指向int类型变量的指针，该指针储存着这个int类型变量储存在内存位置的地址。同样，<strong>函数也有地址</strong>，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。此外，<strong>函数名就是函数的首地址</strong>。</p>
<p>声明一个函数指针时，必须声明指针指向的函数类型，为了指明函数类型，要指明<strong>函数签名</strong>，即函数的返回类型和形参类型。</p>
<ul>
<li>声明和赋值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>; <span class="comment">// 函数原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针的声明：只需把函数原型的名称替换为(* 指针名)即可</span></span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *); <span class="comment">// pf是一个指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值：pf可以指向返回值是void，参数是char *的任何函数</span></span><br><span class="line">pf = ToUpper;</span><br><span class="line"><span class="comment">// pf = ToUpper(); // 无效，ToUpper()不是地址</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>; </span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line">pf = ToUpper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> mis[] = <span class="string">&quot;Nina Metier&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法1</span></span><br><span class="line">(*pf)(mis);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法2</span></span><br><span class="line">pf(mis);</span><br></pre></td></tr></table></figure>
<ul>
<li>使用2：将函数指针作为函数的形参</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (*fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span></span>; <span class="comment">// 一个参数即为函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span> (*fp)(<span class="keyword">char</span> *), <span class="keyword">char</span> * str)</span> </span>&#123;</span><br><span class="line">    (*fp)(str); <span class="comment">// 把传进来的函数指针，作用于str上</span></span><br><span class="line">    <span class="built_in">puts</span>(str); <span class="comment">// 显示结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="15-位操作"><a href="#15-位操作" class="headerlink" title="15 位操作"></a>15 位操作</h2><h3 id="15-1-按位运算符"><a href="#15-1-按位运算符" class="headerlink" title="15.1 按位运算符"></a>15.1 按位运算符</h3><p>C 提供<strong>按位逻辑运算符和移位运算符</strong>。</p>
<h4 id="15-1-1-按位逻辑运算符"><a href="#15-1-1-按位逻辑运算符" class="headerlink" title="15.1.1 按位逻辑运算符"></a>15.1.1 按位逻辑运算符</h4><p>按位逻辑运算符都用于整型数据，包括char。</p>
<ul>
<li>二进制反码或按位取反：<code>~</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~(<span class="number">10011010</span>) <span class="comment">// 表达式</span></span><br><span class="line"><span class="number">01100101</span> <span class="comment">// 结果值</span></span><br></pre></td></tr></table></figure>
<p>假设val的类型是<code>unsigned char</code>，已被赋值为2。在二进制中，<code>00000010</code>表示2。那么，<code>~val</code> 的值是<code>11111101</code>，即253。注意，该运算符不会改变val的值，就像3*va1不会改变val的值一样，val仍然是2。</p>
<ul>
<li>按位与：<code>&amp;</code></li>
<li>按位或：<code>|</code></li>
<li>按位异或：<code>^</code>，两个比较的位，只有一个为1，则结果为1</li>
</ul>
<h5 id="①-掩码"><a href="#①-掩码" class="headerlink" title="① 掩码"></a>① 掩码</h5><p><strong>按位与运算符常用于掩码（mask）</strong>。所谓掩码指的是一些设置为开（1）或关（0）的位组合。要明白称其为掩码的原因，先来看通过<code>&amp;</code>把一个量与掩码结合后发生什么情况。例如，假设定义符号常量<code>MASK</code>为2 （即，二进制形式为00000010），只有1号位是1，其他位都是0。下面的语句∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flags = flags &amp; MASK;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">flags &amp;= MASK;</span><br></pre></td></tr></table></figure>
<p>把flags中除1号位以外的所有位都设置为0，因为使用按位与运算符（&amp;）任何位与0组合都得0。1号位的值不变。这个过程叫作“<strong>使用掩码</strong>”，因为掩码中的0隐藏了flags中相应的位。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img19/image-20221116113056326.png" alt="image-20221116113056326"></p>
<h5 id="②-打开位（设置位）"><a href="#②-打开位（设置位）" class="headerlink" title="② 打开位（设置位）"></a>② 打开位（设置位）</h5><p>有时，需要打开一个值中的特定位，同时保持其他位不变。例如，一台IBM PC通过向端口发送值来控制硬件。例如，为了打开内置扬声器，必须打开1号位（设置为1），<strong>同时保持其他位不变</strong>。这种情况可以使用<strong>按位或运算符</strong>（<code>|</code>）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags |= MASK; <span class="comment">// MASK 00000010</span></span><br></pre></td></tr></table></figure>
<p>将flags的1号位设置为1，其余位不变。</p>
<h5 id="③-关闭位（清空位）"><a href="#③-关闭位（清空位）" class="headerlink" title="③ 关闭位（清空位）"></a>③ 关闭位（清空位）</h5><p>和打开特定的位类似，有时也需要在不影响其他位的情况下关闭指定的位（设置为0）。假设要关闭变量flags中的1号位。同样，MASK只有1号位为1（即，打开）。可以这样做∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flags &amp;= ~MASK; <span class="comment">// MASK=00000010 ~MASK=11111101</span></span><br></pre></td></tr></table></figure>
<h5 id="④-切换位"><a href="#④-切换位" class="headerlink" title="④ 切换位"></a>④ 切换位</h5><p>切换位指的是打开已关闭的位，或关闭已打开的位。可以使用<strong>按位异或运算符</strong>（<code>^</code>）切换位。</p>
<p>假设b是一个位，先看一下b与MASK某一个位做异或操作的结果：</p>
<ul>
<li>如果MASK对应的位是1：b=1，则<code>1^b=0</code>；b=0，则<code>1^b=1</code></li>
<li>如果MASK对应的位是0：b不管为1还是0，异或结果都是b本身</li>
</ul>
<p>因此<strong>要切换flags的某一位，MASK对应的位应该设置为1，反之不切换则设置为0</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flags ^= MASK;</span><br><span class="line"><span class="comment">// flags=0000 1111 MASK=10110110</span></span><br><span class="line"><span class="comment">// res = 1011 1001</span></span><br></pre></td></tr></table></figure>
<h4 id="15-1-2-移位运算符"><a href="#15-1-2-移位运算符" class="headerlink" title="15.1.2 移位运算符"></a>15.1.2 移位运算符</h4><ul>
<li>左移：<code>&lt;&lt;</code>，将其左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，<strong>用0填充空出的位置</strong>。下面的例子中，每一位都向左移动两个位置∶</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10001010</span>)&lt;&lt;<span class="number">2</span>;</span><br><span class="line">(<span class="number">00101000</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> stonk = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> onkoo;</span><br><span class="line">onkoo = stonk &lt;&lt; <span class="number">2</span>;</span><br><span class="line">stonk &lt;&lt;= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>右移：<code>&gt;&gt;</code>，左侧运算对象移出右末端位的值丢。<strong>对于无符号类型，用0填充空出的位置</strong>；对于有符号类型，其<strong>结果取决于机器</strong>。空出的位置可用0填充，或者用符号位（即，最左端的位）的副本填充</li>
</ul>
<h3 id="15-2-位字段"><a href="#15-2-位字段" class="headerlink" title="15.2 位字段"></a>15.2 位字段</h3><p>略</p>
<h2 id="16-C预处理器和C库"><a href="#16-C预处理器和C库" class="headerlink" title="16 C预处理器和C库"></a>16 C预处理器和C库</h2><p>C预处理器在程序执行之前查看程序（故称之为预处理器）。根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并不知道C。基本上它的工作是把一些文本转换成另外一些文本。</p>
<h3 id="16-1-明示常量：-define"><a href="#16-1-明示常量：-define" class="headerlink" title="16.1 明示常量：#define"></a>16.1 明示常量：<code>#define</code></h3><h4 id="16-1-1-简介"><a href="#16-1-1-简介" class="headerlink" title="16.1.1 简介"></a>16.1.1 简介</h4><p>使用#define指令来定义<strong>明示常量</strong>（manifest constam）（也叫做<strong>符号常量</strong>），但是该指令还有许多其他用途。预处理器指令从#开始运行，到后面的第1个换行符为止。也就是说，指令的长度仅限于一行。然而，前面提到过，在预处理开始前，编译器会把多行物理行处理为一行逻辑行。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2 <span class="comment">// 可以使用注释</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OW <span class="meta-string">&quot;Consistency is the last refuge of the unimagina\</span></span></span><br><span class="line"><span class="meta-string"><span class="meta">tive. - Oscar Wilde&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR TWO*TWO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PX printf(<span class="meta-string">&quot;X is %d.\n&quot;</span>, x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FMT <span class="meta-string">&quot;X is %d.\n&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = TWO;</span><br><span class="line">    </span><br><span class="line">    PX;</span><br><span class="line">    x = FOUR;</span><br><span class="line">    <span class="built_in">printf</span>(FMT, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, OW);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TWO: OW\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类对象宏定义组成部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img19/image-20221116123835751.png" alt="image-20221116123835751"></p>
<p>每行#define（逻辑行）都由3部分组成。</p>
<ul>
<li>第1部分是#define指令本身。</li>
<li>第2部分是选定的缩写，也称为<strong>宏</strong>。有些宏代表值（如本例），这些宏被称为<strong>类对象宏</strong>（object-like macro）。C 语言还有<strong>类函数宏</strong>（finction-like macro）。宏的名称中不允许有空格，而且必须遵循C变量的命名规则。</li>
<li>第3部分（指令行的其余部分）称为替换列表或替换体。一旦预处理器在程序中找到宏的示实例后，就会用替换体代替该宏（也有例外，就是<strong>处在双引号中的宏</strong>）。从宏变成最终替换文本的过程称为<strong>宏展开</strong>（macro expansion）。注意，可以在#define行使用标准C注释。如前所述，每条注释都会被一个空格代替。</li>
</ul>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X is 2.</span><br><span class="line">X is 4.</span><br><span class="line">Consistency is the last refuge of the unimaginative. - Oscar Wilde</span><br><span class="line">TWO: OW</span><br></pre></td></tr></table></figure>
<h4 id="16-1-2-记号"><a href="#16-1-2-记号" class="headerlink" title="16.1.2 记号"></a>16.1.2 记号</h4><p>从技术角度来看，可以<strong>把宏的替换体看作是记号</strong>（token）型字符串，而不是字符型字符串。C 预处理器记号是宏定义的替换体中单独的“词”。用空白把这些词分开。例如∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOUR 2*2</span></span><br></pre></td></tr></table></figure>
<p>该宏定义有一个记号：<code>2*2</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIX 4 * 8</span></span><br></pre></td></tr></table></figure>
<p>该宏定义有3个记号：<code>4</code>，<code>*</code>和<code>8</code>。</p>
<p>替换体中有多个空格时，字符型字符串和记号型字符串的处理方式不同。</p>
<p>如果预处理器把该替换体解释为字符型字符串，将用<code>4 * 8</code>替换<code>EIGHT</code>。即，额外的空格是替换体的一部分。如果预处理器把该替换体解释为记号型字符串，则用3个的记号<code>4*8</code>（分别由单个空格分隔）来替换<code>EIGHT</code>。换而言之，<strong>解释为字符型字符串，把空格视为替换体的一部分</strong>；<strong>解释为记号型字符串，把空格视为替换体中各记号的分隔符</strong>。在实际应用中，一些C编译器把宏替换体视为字符串而不是记号。在比这个例子更复杂的情况下，两者的区别才有实际意义。</p>
<h3 id="16-2-在-define中使用参数"><a href="#16-2-在-define中使用参数" class="headerlink" title="16.2 在#define中使用参数"></a>16.2 在<code>#define</code>中使用参数</h3><h4 id="16-2-1-简介"><a href="#16-2-1-简介" class="headerlink" title="16.2.1 简介"></a>16.2.1 简介</h4><p>在#define 中使用参数可以创建外形和作用与函数类似的<strong>类函数宏</strong>。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img19/image-20221116124749550.png" alt="image-20221116124749550"></p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(X) X*X</span></span><br><span class="line"><span class="keyword">int</span> z;</span><br><span class="line">z = SQUARE(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h4 id="16-2-2-用宏参数创建字符串：-运算符"><a href="#16-2-2-用宏参数创建字符串：-运算符" class="headerlink" title="16.2.2 用宏参数创建字符串：#运算符"></a>16.2.2 用宏参数创建字符串：#运算符</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR(X) printf(<span class="meta-string">&quot;The square of X is %d.\n&quot;</span>, ((X) * (X)))</span></span><br><span class="line">PSQR(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The square of X is 64</span><br></pre></td></tr></table></figure>
<p>注意双引号字符串中的X被视为普通文本，而不是一个可以被替换的记号。</p>
<p>C允许在字符串中包含宏参数。在类函数宏的替换体中，<code>#</code>号作为一个预处理运算符，<strong>可以把记号转换成字符串</strong>。例如，如果x是一个宏形参，那么<code>#x</code>就是转换为字符串<code>&quot;x&quot;</code>的形参名。这个过程称为字符串化（stringizing）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PSQR(X) printf(<span class="meta-string">&quot;The square of &quot;</span>#X<span class="meta-string">&quot; is %d.\n&quot;</span>, ((X) * (X)))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y =<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    PSQR(y);</span><br><span class="line">    PSQR(<span class="number">2</span> + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The square of y is 25.</span><br><span class="line">The square of 2 + 4 is 36.</span><br></pre></td></tr></table></figure>
<p>调用第1个宏时，用<code>&quot;y&quot;</code>替换<code>#x</code>。调用第2个宏时，用<code>&quot;2 ＋ 4&quot;</code>替换<code>#x</code>。</p>
<h4 id="16-2-3-预处理器粘合剂：-运算符"><a href="#16-2-3-预处理器粘合剂：-运算符" class="headerlink" title="16.2.3 预处理器粘合剂：##运算符"></a>16.2.3 预处理器粘合剂：##运算符</h4><p>与#运算符类似，<code>##</code>运算符可用于类函数宏的替换部分。而且，##还可用于<strong>对象宏</strong>的替换部分。##运算符把两个记号组合成一个记号。例如，可以这样做∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x ## n</span></span><br></pre></td></tr></table></figure>
<p>然后宏<code>XNAME(4)</code>将展开为<code>x4</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x ## n</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_XN(n) printf(<span class="meta-string">&quot;x&quot;</span> #n <span class="meta-string">&quot; = %d\n&quot;</span>, x ## n)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">14</span>; <span class="comment">// 变成 int x1 = 14;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">2</span>)</span> </span>= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> x3 = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    PRINT_XN(<span class="number">1</span>); <span class="comment">// 变成 printf(&quot;x1 = %d\n&quot;, x1);</span></span><br><span class="line">    PRINT_XN(<span class="number">2</span>);</span><br><span class="line">    PRINT_XN(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x1 = 14</span><br><span class="line">x2 = 20</span><br><span class="line">x3 = 30</span><br></pre></td></tr></table></figure>
<p>PRINT_XN宏用#运算符组合字符串，##运算符把记号组合为一个新的标识符。</p>
<h3 id="16-3-宏和函数的选择"><a href="#16-3-宏和函数的选择" class="headerlink" title="16.3 宏和函数的选择"></a>16.3 宏和函数的选择</h3><p>宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间。</p>
<p>宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。因此，只要能用int或float类型都可以使用<code>SQUARE(x)</code>宏。</p>
<h3 id="16-4-文件包含：-include"><a href="#16-4-文件包含：-include" class="headerlink" title="16.4 文件包含：#include"></a>16.4 文件包含：<code>#include</code></h3><h4 id="16-4-1-简介"><a href="#16-4-1-简介" class="headerlink" title="16.4.1 简介"></a>16.4.1 简介</h4><p>当预处理器发现#include 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的#include指令。<strong>这相当于把被包含文件的全部内容输入到源文件#include指令所在的位置</strong>。</p>
<h1 id="include指令有两种形式∶"><a href="#include指令有两种形式∶" class="headerlink" title="include指令有两种形式∶"></a>include指令有两种形式∶</h1><ul>
<li><code>#include &lt;stdio.h&gt;</code></li>
<li><code>#include &quot;mystuff.h&quot;</code></li>
</ul>
<p>在 UNIX 系统中，尖括号告诉预处理器在标准系统目录中查找该文件。双引号告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录。</p>
<h4 id="16-4-2-头文件的使用"><a href="#16-4-2-头文件的使用" class="headerlink" title="16.4.2 头文件的使用"></a>16.4.2 头文件的使用</h4><p>头文件中最常用的形式如下：</p>
<ul>
<li>明示常量：例如，stdio.h中定义的EOF、NULL和BUFSIZE（标准I/O缓冲区大小）。</li>
<li>宏函数</li>
<li>函数声明：例如，string.h头文件（一些旧的系统中是strings.h）包含字符串函数系列的函数声明。在ANSIC和后面的标准中，函数声明都是函数原型形式。</li>
<li>结构模版定义：标准I/O函数使用FILE 结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE 结构在头文件stdio.h中。</li>
<li>类型定义：标准 I/O 函数使用指向 FILE 的指针作为参数。通常，stdio.h 用#define 或typedef把FILE定义为指向结构的指针。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name_st.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 明示常量</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SLEN 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构模板定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">names_st</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> first[SLEN];</span><br><span class="line">    <span class="keyword">char</span> last[SLEN];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">names_st</span> <span class="title">names</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_names</span><span class="params">(names *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_names</span><span class="params">(<span class="keyword">const</span> names *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// names_st.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;names_st.h&quot;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_names</span><span class="params">(names *)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_names</span><span class="params">(<span class="keyword">const</span> names *)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">s_gets</span><span class="params">(<span class="keyword">char</span> * st, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user_header.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;names_st.h&quot;</span> <span class="comment">// 包含头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#include</code>和<code>define</code>指令时最常用的两个C预处理器特性。</p>
<h3 id="16-5-其他指令"><a href="#16-5-其他指令" class="headerlink" title="16.5 其他指令"></a>16.5 其他指令</h3><h4 id="16-5-1-undef"><a href="#16-5-1-undef" class="headerlink" title="16.5.1 #undef"></a>16.5.1 <code>#undef</code></h4><p>作用：用于取消已定义的#define指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> LIMIT</span></span><br></pre></td></tr></table></figure>
<p>如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用#undef 指令取消该名字的定义。</p>
<h4 id="16-5-2-条件编译"><a href="#16-5-2-条件编译" class="headerlink" title="16.5.2 条件编译"></a>16.5.2 条件编译</h4><h5 id="①-ifdef，-else和-endif"><a href="#①-ifdef，-else和-endif" class="headerlink" title="① #ifdef，#else和#endif"></a>① <code>#ifdef</code>，<code>#else</code>和<code>#endif</code></h5><p>这三条指令很像C的条件判断，但是预处理器不识别用于标记块的花括号。</p>
<blockquote>
<p>程序示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAVIS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.1415</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;test2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E 2.07</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>有些较新的编译器可以支持缩进，否则必须左对齐所有指令。</p>
<h5 id="②-ifndef"><a href="#②-ifndef" class="headerlink" title="② #ifndef"></a>② <code>#ifndef</code></h5><p><code>#ifndef</code>指令判断后面的标识符是否是未定义的，常用于定义之前未定义的常量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10 <span class="comment">// 如果没有定义SIZE，就定义SIZE为100</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>通常，包含多个头文件时，其中的文件可能包含了相同宏定义。<strong>#ifndef指令可以防止相同的宏被重复定义</strong>。在首次定义一个宏的头文件中用#ifndef指令激活定义，随后在其他头文件中的定义都被忽略。</p>
<p>#ifndef指令通常用于防止多次包含一个文件。也就是说，应该像下面这样设置头文件∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H_</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>假设该文件被包含了多次。当预处理器首次发现该文件被包含时，<code>TEST_H_</code>是未定义的，所以定义了<code>TEST_H_</code>，并接着处理该文件的其他部分。当预处理器第2次发现该文件被包含时，<code>TEST_H_</code>是已定义的，所以预处理器跳过了该文件的其他部分。</p>
<p>为何要多次包含一个文件？最常见的原因是，许多被包含的文件中都包含着其他文件，所以显式包含的文件中可能包含着已经包含的其他文件。</p>
<p>但是，这样存在一个问题∶<strong>如何确保待测试的标识符没有在别处定义</strong>。通常，实现的供应商使用这些方法解决这个问题∶用文件名作为标识符、使用大写字母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀（可能使用两条下划线）。例如，查看stdio.h头文件，可以发现许多类似的代码∶</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _STDIO_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _STDIO_H</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>一般来说，自己定义头文件时，<strong>在前面和最后用两个下划线</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __TEST_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __TEST_H__</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h5 id="③-if和elif"><a href="#③-if和elif" class="headerlink" title="③ if和elif"></a>③ <code>if</code>和<code>elif</code></h5><p>略</p>
<h4 id="16-5-3-预定义宏"><a href="#16-5-3-预定义宏" class="headerlink" title="16.5.3 预定义宏"></a>16.5.3 预定义宏</h4><p>C标准规定了一些预定义宏：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221119163413107.png" alt="image-20221119163413107"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">why_me</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The file is %s.\n&quot;</span>, __FILE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The date is %s.\n&quot;</span>, __DATE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The time is %s.\n&quot;</span>, __TIME__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is line %d.\n&quot;</span>, __LINE__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This function is %s\n&quot;</span>, __func__);</span><br><span class="line">    why_me();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">why_me</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This function is %s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is line %d.\n&quot;</span>, __LINE__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The file is E:\develop\study\project-study\C++_learn\predef.c.</span><br><span class="line">The date is Nov <span class="number">19</span> <span class="number">2022.</span></span><br><span class="line">The time is <span class="number">16</span>:<span class="number">39</span>:<span class="number">37.</span></span><br><span class="line">This is line <span class="number">11.</span></span><br><span class="line">This function is main</span><br><span class="line">This function is why_me</span><br><span class="line">This is line <span class="number">19.</span></span><br></pre></td></tr></table></figure>
<h3 id="16-6-C库"><a href="#16-6-C库" class="headerlink" title="16.6 C库"></a>16.6 C库</h3><p>最初，并没有官方的C库。后来，基于UNIX的C实现成为了标准。ANSIC委员会主要以这个标准为基础，开发了一个官方的标准库。在意识到C语言的应用范围不断扩大后，该委员会重新定义了这个库，使之可以应用于其他系统。</p>
<blockquote>
<p>库和头文件的区别</p>
</blockquote>
<ul>
<li>头文件：在编程过程中，程序代码往往被拆成很多部分，每部分放在一个独立的源文件中，而不是将所有的代码放在一个源文件中。考虑一个简单的小例子：程序中有两个函数main()和abc()。main()函数位于main.cpp，abc()函数位于abc.cpp，main()函数中调用abc()函数。在编译阶段，由于编译是对单个文件进行编译，所以编译main.cpp时，编译器不知道是否存在abc()函数以及abc()调用是否正确，因此需要头文件辅助。也就是说，在编译命令：<code>cl.exe /c main.cpp</code>运行时，编译器不知道abc的用法是否正确（因为abc在另一个文件abc.cpp中），只有借助头文件中的函数声明来判断。对main.cpp进行编译时，不会涉及abc.cpp文件，只会涉及main.cpp 和abc.h（因为abc.h被include）文件。<ul>
<li>头文件以<code>.h</code>结尾，可以用文本编辑器查看内容。是<strong>ASCII</strong>的。</li>
</ul>
</li>
<li>库文件：包含一系列的子程序。例如abc.cpp源文件中实现了abc()函数，我们假设abc()函数是包含重要算法的函数，我们需要将abc()函数提供给客户使用，但是<strong>不希望客户看到算法源代码</strong>。为了达到这一目的，我们可以将abc.cpp编译成库文件，<strong>库文件是二进制的</strong>，在库文件中是看不到原始的源代码的。库和可执行文件的区别是，库不是独立程序，他们是向其他程序提供服务的代码。 当然使用库文件的好处不仅仅是对源代码进行保密，使用库文件还可以减少重复编译的时间，增强程序的模块化。<ul>
<li>将库文件链接到程序中，有两种方式，一种是静态连接库<code>.a</code>，另一种是动态连接库<code>.so</code>。库文件是二进制的。<strong>两种库的区别在于静态库被调用时直接加载到内存，而动态库再是在需要的时候加载到内存，不使用的时候再从内存释放。</strong></li>
</ul>
</li>
</ul>
<p>比如，<code>printf</code>函数。使用时应包括<code>stdio.h</code>，打开<code>stdio.h</code>只能看到，printf这个函数的声明，却看不到printf具体是怎么实现的，而<strong>函数的实现在相应的C库中</strong>。而库文件一般是以二进制形式而不是C源文件形式提供给用户使用的。程序中包括了<code>stdio.h</code>这个头文件，链接器就能根据头文件中的信息找到printf这个函数的实现并链接进这个程序代码段里。</p>
<h2 id="17-高级数据表示"><a href="#17-高级数据表示" class="headerlink" title="17 高级数据表示"></a>17 高级数据表示</h2><p>略，参见数据结构</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">C语言学习</a></div><div class="post_share"><div class="social-share" data-image="/img/C.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/06/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="/img/51danpianji.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">51单片机入门</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/09/%E6%97%A5%E6%9C%AC%E9%BA%BB%E5%B0%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/majiang.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">日本麻将学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/20/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux系统编程学习笔记"><img class="cover" src="/img/linux.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-20</div><div class="title">Linux系统编程学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">C语言学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">0 编程环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86C%E8%AF%AD%E8%A8%80"><span class="toc-text">1 初识C语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-C%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-text">2 C语言概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%92%8CC"><span class="toc-text">3 数据和C</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">4 字符串和格式化输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-text">5 运算符、表达式和语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF"><span class="toc-text">6 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%88%86%E6%94%AF%E5%92%8C%E8%B7%B3%E8%BD%AC"><span class="toc-text">7 分支和跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">8 字符输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0"><span class="toc-text">9 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.1 函数示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9F%A5%E6%89%BE%E5%9C%B0%E5%9D%80%EF%BC%9A-amp-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">9.2 查找地址：&amp;运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%8C%87%E9%92%88"><span class="toc-text">9.3 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E9%97%B4%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-text">9.3.1 间接运算符：*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E5%A3%B0%E6%98%8E%E6%8C%87%E9%92%88"><span class="toc-text">9.3.2 声明指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%9C%A8%E5%87%BD%E6%95%B0%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">9.3.3 使用指针在函数间通信</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">10 指针和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E6%95%B0%E7%BB%84"><span class="toc-text">10.1 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">10.1.1 数组的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-text">10.1.2 初始化数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8-C99%E6%A0%87%E5%87%86"><span class="toc-text">10.1.3 指定初始化器 C99标准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-4-%E4%B8%BA%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%B5%8B%E5%80%BC"><span class="toc-text">10.1.4 为数组元素赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-5-%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C"><span class="toc-text">10.1.5 数组边界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-6-%E6%8C%87%E5%AE%9A%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">10.1.6 指定数组的大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">10.2 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">10.3 数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B"><span class="toc-text">10.3.1 指针简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">10.3.2 数组和指针的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="toc-text">10.4 指针与函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%9C%A8%E5%87%BD%E6%95%B0%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">10.4.1 使用指针在函数间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E5%87%BD%E6%95%B0%EF%BC%8C%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">10.4.2 函数，数组和指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-5-%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C"><span class="toc-text">10.5 指针操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-6-%E4%BF%9D%E6%8A%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">10.6 保护数组中的数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-1-%E5%AF%B9%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8const"><span class="toc-text">10.6.1 对形式参数使用const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-2-%E5%85%B3%E9%94%AE%E5%AD%97const%E7%9A%84%E5%85%B6%E5%AE%83%E5%86%85%E5%AE%B9"><span class="toc-text">10.6.2 关键字const的其它内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-7-%E6%8C%87%E9%92%88%E4%B8%8E%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">10.7 指针与多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-1-%E6%8C%87%E5%90%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">10.7.1 指向二维数组的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-2-%E6%8C%87%E9%92%88%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">10.7.2 指针的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-7-3-%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">10.7.3 函数和多维数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-8-%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84VLA"><span class="toc-text">10.8 变长数组VLA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-9-%E5%A4%8D%E5%90%88%E5%AD%97%E9%9D%A2%E9%87%8F-C99"><span class="toc-text">10.9 复合字面量 C99</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">11 字符串和字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%80%E4%BB%8B"><span class="toc-text">11.1 字符串简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-char%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E5%92%8Cnull%E5%AD%97%E7%AC%A6"><span class="toc-text">11.1.1 char类型数组和null字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-strlen-%E5%87%BD%E6%95%B0"><span class="toc-text">11.1.2 strlen()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%A1%A8%E7%A4%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2IO"><span class="toc-text">11.2 表示字符串和字符串IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%AE%9A%E4%B9%89%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">11.2.1 在程序中定义字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%EF%BC%89"><span class="toc-text">① 字符串字面量（字符串常量）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">② 字符数组和初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">③ 数组和指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">④ 数组和指针的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84"><span class="toc-text">⑤ 字符串数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">11.2.2 指针和字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%85%A5"><span class="toc-text">11.3 字符串输入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-gets-%E5%87%BD%E6%95%B0"><span class="toc-text">11.3.1 gets()函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-fgets-%E5%87%BD%E6%95%B0"><span class="toc-text">11.3.2 fgets()函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">11.4 字符串函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1-strlen"><span class="toc-text">11.4.1 strlen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2-strcat"><span class="toc-text">11.4.2 strcat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-3-strncat"><span class="toc-text">11.4.3 strncat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-4-strcmp"><span class="toc-text">11.4.4 strcmp</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-5-strcpy"><span class="toc-text">11.4.5 strcpy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-6-%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="toc-text">11.4.6 其他字符串函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">11.5 命令行参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">12 存储类别和内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB"><span class="toc-text">12.1 存储类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1-%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">12.1.1 作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2-%E9%93%BE%E6%8E%A5"><span class="toc-text">12.1.2 链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3-%E5%AD%98%E5%82%A8%E6%9C%9F"><span class="toc-text">12.1.3 存储期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-4-%E8%87%AA%E5%8A%A8"><span class="toc-text">12.1.4 自动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-5-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-text">12.1.5 寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-6-%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E6%97%A0%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-text">12.1.6 块作用域的静态变量（静态无链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-7-%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-text">12.1.7 外部链接的静态变量（静态外部链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-8-%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%E7%9A%84%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%EF%BC%89"><span class="toc-text">12.1.8 内部链接的静态变量（静态内部链接）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-9-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="toc-text">12.1.9 存储类别说明符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-10-%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">12.1.10 存储类别和函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-text">12.2 随机数函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">12.3 分配内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-malloc%E5%87%BD%E6%95%B0"><span class="toc-text">12.3.1 malloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2-free%E5%87%BD%E6%95%B0"><span class="toc-text">12.3.2 free函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3-calloc%E5%87%BD%E6%95%B0"><span class="toc-text">12.3.3 calloc函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-ANSI-C%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">12.4 ANSI C类型限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-const%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">12.4.1 const类型限定符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%8C%87%E9%92%88%E5%92%8C%E5%BD%A2%E5%8F%82%E4%BD%BF%E7%94%A8const"><span class="toc-text">① 指针和形参使用const</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%85%A8%E5%B1%80%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8const"><span class="toc-text">② 全局数据使用const</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-volatile%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-text">12.4.2 volatile类型限定符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-text">13 文件输入&#x2F;输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E4%B8%8E%E6%96%87%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-text">13.1 与文件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-%E6%96%87%E4%BB%B6"><span class="toc-text">13.1.1 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">13.1.2 文件模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-3-IO%E7%9A%84%E7%BA%A7%E5%88%AB"><span class="toc-text">13.1.3 IO的级别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-4-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6"><span class="toc-text">13.1.4 标准文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E6%A0%87%E5%87%86IO"><span class="toc-text">13.2 标准IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-%E6%A3%80%E6%9F%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-text">13.2.1 检查命令行参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-fopen"><span class="toc-text">13.2.2 fopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-3-getc%E5%92%8Cputc"><span class="toc-text">13.2.3 getc和putc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-4-%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="toc-text">13.2.4 文件结尾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-5-fclose"><span class="toc-text">13.2.5 fclose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-6-%E6%8C%87%E5%90%91%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">13.2.6 指向标准文件的指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E7%A8%8B%E5%BA%8F"><span class="toc-text">13.3 一个简单的文件压缩程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-%E6%96%87%E4%BB%B6IO"><span class="toc-text">13.4 文件IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-1-fprintf%E5%92%8Cfscanf"><span class="toc-text">13.4.1 fprintf和fscanf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-2-fgets%E5%92%8Cfputs"><span class="toc-text">13.4.2 fgets和fputs</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-%E6%A0%87%E5%87%86IO%E5%8E%9F%E7%90%86"><span class="toc-text">13.5 标准IO原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-%E5%85%B6%E4%BB%96%E6%A0%87%E5%87%86IO%E5%87%BD%E6%95%B0"><span class="toc-text">13.6 其他标准IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-1-fflush"><span class="toc-text">13.6.1 fflush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-2-fread%E5%92%8Cfwrite"><span class="toc-text">13.6.2 fread和fwrite</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E7%BB%93%E6%9E%84%E5%92%8C%E5%85%B6%E5%AE%83%E6%95%B0%E6%8D%AE%E5%BD%A2%E5%BC%8F"><span class="toc-text">14 结构和其它数据形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%9B%E5%BB%BA%E5%9B%BE%E4%B9%A6%E7%9B%AE%E5%BD%95"><span class="toc-text">14.1 示例：创建图书目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%E5%BB%BA%E7%AB%8B%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="toc-text">14.2 建立结构声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F"><span class="toc-text">14.3 定义结构变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">14.3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84"><span class="toc-text">14.3.2 初始化结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-3-%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-text">14.3.3 访问结构成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-4-%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8"><span class="toc-text">14.3.4 结构的初始化器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-text">14.4 结构数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1-%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84"><span class="toc-text">14.4.1 声明结构数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-%E6%A0%87%E8%AF%86%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-text">14.4.2 标识结构数组的成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-text">14.5 嵌套结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">14.6 指向结构的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-1-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88"><span class="toc-text">14.6.1 声明和初始化结构指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-2-%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98"><span class="toc-text">14.6.2 用指针访问成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">14.7 向函数传递结构的信息</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-1-%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="toc-text">14.7.1 传递结构成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-2-%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-text">14.7.2 传递结构的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-3-%E4%BC%A0%E9%80%92%E7%BB%93%E6%9E%84"><span class="toc-text">14.7.3 传递结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-4-%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E7%89%B9%E6%80%A7"><span class="toc-text">14.7.4 其他结构特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-5-%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%93%E6%9E%84%E6%8C%87%E9%92%88%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">14.7.5 结构和结构指针的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-6-%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88"><span class="toc-text">14.7.6 结构中的字符数组和字符指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-7-%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">14.7.7 使用结构数组的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-8-%E8%81%94%E5%90%88"><span class="toc-text">14.8 联合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">14.8.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-2-%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88"><span class="toc-text">14.8.2 使用联合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-9-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">14.9 枚举类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-9-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">14.9.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-9-2-enum%E5%B8%B8%E9%87%8F"><span class="toc-text">14.9.2 enum常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-9-3-%E8%B5%8B%E5%80%BC"><span class="toc-text">14.9.3 赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-9-4-%E5%85%B1%E4%BA%AB%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">14.9.4 共享命名空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-10-typedef"><span class="toc-text">14.10 typedef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-11-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">14.11 函数指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-text">15 位操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">15.1 按位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-1-%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">15.1.1 按位逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%8E%A9%E7%A0%81"><span class="toc-text">① 掩码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%89%93%E5%BC%80%E4%BD%8D%EF%BC%88%E8%AE%BE%E7%BD%AE%E4%BD%8D%EF%BC%89"><span class="toc-text">② 打开位（设置位）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%85%B3%E9%97%AD%E4%BD%8D%EF%BC%88%E6%B8%85%E7%A9%BA%E4%BD%8D%EF%BC%89"><span class="toc-text">③ 关闭位（清空位）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E5%88%87%E6%8D%A2%E4%BD%8D"><span class="toc-text">④ 切换位</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-2-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">15.1.2 移位运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%E4%BD%8D%E5%AD%97%E6%AE%B5"><span class="toc-text">15.2 位字段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E5%92%8CC%E5%BA%93"><span class="toc-text">16 C预处理器和C库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%E6%98%8E%E7%A4%BA%E5%B8%B8%E9%87%8F%EF%BC%9A-define"><span class="toc-text">16.1 明示常量：#define</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">16.1.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-2-%E8%AE%B0%E5%8F%B7"><span class="toc-text">16.1.2 记号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%E5%9C%A8-define%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="toc-text">16.2 在#define中使用参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">16.2.1 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-2-%E7%94%A8%E5%AE%8F%E5%8F%82%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%9A-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">16.2.2 用宏参数创建字符串：#运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-3-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%B2%98%E5%90%88%E5%89%82%EF%BC%9A-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">16.2.3 预处理器粘合剂：##运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-text">16.3 宏和函数的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-4-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%EF%BC%9A-include"><span class="toc-text">16.4 文件包含：#include</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">16.4.1 简介</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include%E6%8C%87%E4%BB%A4%E6%9C%89%E4%B8%A4%E7%A7%8D%E5%BD%A2%E5%BC%8F%E2%88%B6"><span class="toc-text">include指令有两种形式∶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-2-%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">16.4.2 头文件的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-%E5%85%B6%E4%BB%96%E6%8C%87%E4%BB%A4"><span class="toc-text">16.5 其他指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-1-undef"><span class="toc-text">16.5.1 #undef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-2-%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-text">16.5.2 条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-ifdef%EF%BC%8C-else%E5%92%8C-endif"><span class="toc-text">① #ifdef，#else和#endif</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-ifndef"><span class="toc-text">② #ifndef</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-if%E5%92%8Celif"><span class="toc-text">③ if和elif</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-3-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">16.5.3 预定义宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-6-C%E5%BA%93"><span class="toc-text">16.6 C库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA"><span class="toc-text">17 高级数据表示</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>