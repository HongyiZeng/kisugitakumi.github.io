<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java高级学习笔记 | Kisugi Takumi</title><meta name="keywords" content="Java"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一次编译，四处运行。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java高级学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2022/03/23/Java%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="一次编译，四处运行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/java.png">
<meta property="article:published_time" content="2022-03-23T06:46:25.000Z">
<meta property="article:modified_time" content="2022-04-12T03:33:22.983Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/java.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2022/03/23/Java%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java高级学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-12 11:33:22'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java高级学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-23T06:46:25.000Z" title="发表于 2022-03-23 14:46:25">2022-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-12T03:33:22.983Z" title="更新于 2022-04-12 11:33:22">2022-04-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">开发基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>128分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java高级学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Java高级学习笔记"><a href="#Java高级学习笔记" class="headerlink" title="Java高级学习笔记"></a>Java高级学习笔记</h1><p>学习来源：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kb411W75N">尚硅谷</a></p>
<p>学习时间：2022年3月23日</p>
<h2 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1 多线程"></a>1 多线程</h2><p>略，详见Java并发编程学习笔记</p>
<h2 id="2-常用类"><a href="#2-常用类" class="headerlink" title="2 常用类"></a>2 常用类</h2><h3 id="2-1-字符串相关的类"><a href="#2-1-字符串相关的类" class="headerlink" title="2.1 字符串相关的类"></a>2.1 字符串相关的类</h3><h4 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h4><ul>
<li><p>String类：代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p>
<ul>
<li>String是一个final类，代表<strong>不可变的字符序列</strong>。</li>
<li>字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。</li>
<li>String实现了<code>Serializable</code>接口，表示字符串是支持序列化的；实现了<code>Comparable</code>接口，表示字符串可以比较大小</li>
<li>String对象的字符内容是存储在一个字符数组<code>value[]</code>中的。</li>
<li><p>String类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value; <span class="comment">// final修饰，代表不可变</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-String的不可变性"><a href="#2-1-2-String的不可变性" class="headerlink" title="2.1.2 String的不可变性"></a>2.1.2 String的不可变性</h4><p>通过字面量的方式（区别于<code>new</code>）给一个字符串赋值，此时的字符串值声明在<strong>字符串常量池</strong>中。</p>
<p>字符串常量池中不会存储相同内容的字符串。</p>
<ul>
<li>不可变性<ul>
<li>当对字符串重新赋值时，需要新开辟内存区域进行赋值，不能改变原有的内存区域存储的值</li>
<li>当对现有的字符串进行连接操作时，也需要新开辟内存区域进行赋值</li>
<li>当调用String的方法修改指定的字符或字符串时，也需要新开辟内存区域进行赋值</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例和图演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">// 字面量定义字符串</span></span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323150736689.png" alt="image-20220323150736689"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323151016238.png" alt="image-20220323151016238"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s2 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">System.out.println(s1); <span class="comment">// abc</span></span><br><span class="line">System.out.println(s2); <span class="comment">// abcdef</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323151523400.png" alt="image-20220323151523400"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = s1.replace(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;m&quot;</span>);</span><br><span class="line">System.out.println(s1); <span class="comment">// abc</span></span><br><span class="line">System.out.println(s2); <span class="comment">// mbc</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323151800606.png" alt="image-20220323151800606"></p>
<h4 id="2-1-3-String对象的创建"><a href="#2-1-3-String对象的创建" class="headerlink" title="2.1.3 String对象的创建"></a>2.1.3 String对象的创建</h4><h5 id="①-概述和使用"><a href="#①-概述和使用" class="headerlink" title="① 概述和使用"></a>① 概述和使用</h5><p>可以通过字面量或者<code>new + 构造器</code>的方式来创建String对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line">String s1 = <span class="keyword">new</span> String(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a); </span><br><span class="line"></span><br><span class="line">String s4 = <span class="keyword">new</span> String(<span class="keyword">char</span>[] a,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> count);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>字面量和new的区别</p>
<ul>
<li><p>字符串常量存储在<strong>字符串常量池</strong>，目的是共享</p>
</li>
<li><p>字符串非常量对象存储在<strong>堆</strong>中。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时s1和s2地址对应的数据都在字符串常量池中</span></span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时s3和s4地址对应的数据都在堆空间中</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	<span class="comment">// 注意，==比较的是变量的地址值</span></span><br><span class="line">    <span class="comment">// equals比较的是内容</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s1 == s3); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(s1.equals(s3)); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3.equals(s4)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323153148874.png" alt="image-20220323153148874"></p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">System.out.println(p1.name == p2.name); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323154107647.png" alt="image-20220323154107647"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">p1.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">System.out.println(p2.name); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220323154225800.png" alt="image-20220323154225800"></p>
<blockquote>
<p>问答题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>问：在内存中创建了几个对象？</p>
<p>答：两个，一个是堆空间中的String对象，一个是String对象中char[]属性对应的常量池中的数据。</p>
<h5 id="②-不同拼接操作的对比"><a href="#②-不同拼接操作的对比" class="headerlink" title="② 不同拼接操作的对比"></a>② 不同拼接操作的对比</h5><ul>
<li>常量与常量的拼接结果在常量池，且<strong>常量池中不会存在相同内容的常量</strong></li>
<li>只要拼接内容中有一个是变量，结果就在<strong>堆</strong>中，相当于new了一个字符串</li>
<li>如果拼接的结果调用<code>intern()</code>方法，<strong>返回值就在常量池中</strong></li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">    String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">// false</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    String s8 = s5.intern();</span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220325171940461.png" alt="image-20220325171940461"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> String s2 = <span class="string">&quot;javaEE&quot;</span>; <span class="comment">// s2是常量</span></span><br><span class="line">    String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s3); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：由<code>final</code>修饰的是常量，即s2是常量，不是变量。因此第五句代码本质上是常量与常量的拼接。</p>
<blockquote>
<p>面试题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringTest ex = <span class="keyword">new</span> StringTest();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.print(ex.str + <span class="string">&quot; and &quot;</span>);</span><br><span class="line">        System.out.println(ex.ch);</span><br><span class="line">        <span class="comment">// 打印结果：</span></span><br><span class="line">        <span class="comment">// good and best</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：关于值传递：</p>
<ul>
<li>基本数据类型传递的是数据本身</li>
<li>引用数据类型传递的是地址值</li>
</ul>
<h4 id="2-1-4-常用方法"><a href="#2-1-4-常用方法" class="headerlink" title="2.1.4 常用方法"></a>2.1.4 常用方法</h4><ul>
<li><code>int length()</code>：返回字符串的长度</li>
<li><code>char charAt(int index)</code>：返回某索引处的字符</li>
<li><code>isEmpty()</code>：判断是否是空字符串</li>
<li><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所有字符转换为小写</li>
<li><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所有字符转换为大写</li>
<li><code>String trim()</code>：返回字符串的副本，忽略<strong>前导空白和尾部空白</strong></li>
<li><code>boolean equals(Object obj)</code>：比较字符串的<strong>内容</strong>是否相同</li>
<li><code>boolean equalsIgnoreCase(String anotherString)</code>：与equals方法类似，忽略大小写</li>
<li><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾，等价于用“+”  </li>
<li><code>int compareTo(String anotherString)</code>：比较两个字符串的大小，返回差值</li>
<li><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。  </li>
<li><code>String substring(int beginIndex, int endIndex)</code>：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(<strong>不包含</strong>)的一个子字符串（<strong>左闭右开</strong>）。</li>
<li><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束</li>
<li><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始</li>
<li><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>
<li><code>boolean contains(CharSequence s)</code>：当且仅当此字符串包含指定的 char 值序列时，返回 true</li>
<li><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引，<strong>找不到返回-1</strong></li>
<li><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</li>
<li><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</li>
<li><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的</li>
<li><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</li>
<li><code>String replaceAll(String regex, String replacement)</code> ： 使 用 给 定 的replacement 替换此字符串所有匹配给定的正则表达式的子字符串</li>
<li><code>String replaceFirst(String regex, String replacement)</code> ： 使 用 给 定 的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串</li>
<li><code>boolean matches(String regex)</code>：告知此字符串是否匹配给定的正则表达式</li>
<li><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串</li>
<li><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;HelloWorld&quot;</span>;</span><br><span class="line">    System.out.println(s1.length()); <span class="comment">// 10</span></span><br><span class="line">    System.out.println(s1.charAt(<span class="number">1</span>)); <span class="comment">// e</span></span><br><span class="line">    System.out.println(s1.isEmpty()); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    String s2 = s1.toUpperCase(Locale.ROOT);</span><br><span class="line">    System.out.println(s1); <span class="comment">// HelloWorld</span></span><br><span class="line">    System.out.println(s2); <span class="comment">// HELLOWORLD</span></span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;  hello world     &quot;</span>;</span><br><span class="line">    String s4 = s3.trim();</span><br><span class="line">    System.out.println(s3); <span class="comment">// 不变</span></span><br><span class="line">    System.out.println(s4); <span class="comment">// hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s2 = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">    String s3 = s1.concat(s2);</span><br><span class="line">    System.out.println(s3); <span class="comment">// abcdef</span></span><br><span class="line"></span><br><span class="line">    String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    String s5 = <span class="keyword">new</span> String(<span class="string">&quot;abz&quot;</span>);</span><br><span class="line">    String s6 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(s4.compareTo(s5)); <span class="comment">// -23</span></span><br><span class="line">    System.out.println(s4.compareTo(s6)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    String s7 = <span class="string">&quot;Hongyi&quot;</span>;</span><br><span class="line">    String s8 = s7.substring(<span class="number">1</span>);</span><br><span class="line">    String s9 = s7.substring(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    System.out.println(s8); <span class="comment">// ongyi</span></span><br><span class="line">    System.out.println(s9); <span class="comment">// on</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例3</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span> b1 = s1.endsWith(<span class="string">&quot;rld&quot;</span>);</span><br><span class="line">    <span class="keyword">boolean</span> b2 = s1.startsWith(<span class="string">&quot;ll&quot;</span>);</span><br><span class="line">    System.out.println(b1); <span class="comment">// true</span></span><br><span class="line">    System.out.println(b2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b3 = s1.contains(<span class="string">&quot;llo&quot;</span>);</span><br><span class="line">    System.out.println(b3); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i1 = s1.indexOf(<span class="string">&quot;lo&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i2 = s1.indexOf(<span class="string">&quot;m&quot;</span>);</span><br><span class="line">    System.out.println(i1); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(i2); <span class="comment">// -1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例4</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">    String s2 = s1.replace(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    System.out.println(s1); <span class="comment">// helloworld</span></span><br><span class="line">    System.out.println(s2); <span class="comment">// aelloworld</span></span><br><span class="line"></span><br><span class="line">    String s3 = s1.replace(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hongyi&quot;</span>);</span><br><span class="line">    System.out.println(s3); <span class="comment">// hongyiworld</span></span><br><span class="line"></span><br><span class="line">    String s4 = <span class="string">&quot;12hello34world4&quot;</span>;</span><br><span class="line">    <span class="comment">// 把字符串中的数字替换成逗号 , 如果结果中开头和结尾有 , 的话则去掉</span></span><br><span class="line">    String s5 = s4.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(s5); <span class="comment">// hello,world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例5</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">    String[] s2 = s1.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : s2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">// hello</span></span><br><span class="line">        <span class="comment">// world</span></span><br><span class="line">        <span class="comment">// java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-数据转换"><a href="#2-1-5-数据转换" class="headerlink" title="2.1.5 数据转换"></a>2.1.5 数据转换</h4><h5 id="①-基本数据类型"><a href="#①-基本数据类型" class="headerlink" title="① 基本数据类型"></a>① 基本数据类型</h5><ul>
<li>字符串 —&gt; 基本数据类型、包装类<ul>
<li>Integer包装类的<code>public static int parseInt(String s)</code>：可以将由<strong>“数字”字符组成的字符串</strong>转换为整型。</li>
<li>类似地，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = Integer.parseInt(s1);</span><br><span class="line">    System.out.println(num);</span><br><span class="line"></span><br><span class="line">    String s2 = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = Boolean.parseBoolean(s2);</span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">    String s3 = <span class="string">&quot;123.123&quot;</span>;</span><br><span class="line">    <span class="keyword">double</span> num1 = Double.parseDouble(s3);</span><br><span class="line">    System.out.println(num1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基本数据类型、包装类 —&gt; 字符串<ul>
<li>调用String类的<code>public String valueOf(int n)</code>可将int型转换为字符串</li>
<li>相应的重载方法：valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可由参数的相应类型到字符串的转换</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">123</span>;</span><br><span class="line">    String s = String.valueOf(num);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-char数组"><a href="#②-char数组" class="headerlink" title="② char数组"></a>② char数组</h5><ul>
<li>字符数组 —&gt; 字符串<ul>
<li>String 类的构造器：<code>String(char[]) 和 String(char[], int offset, int length)</code> 分别用字符数组中的全部字符和部分字符创建字符串对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="comment">// 利用构造器创建字符串</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(arr);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串 —&gt;字符数组 <ul>
<li><code>public char[] toCharArray()</code>：将字符串中的全部字符存放在一个字符数组中的方法。</li>
<li><code>public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</code>：提供了将指定索引范围内的字符串存放到数组中的方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;123abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : charArray)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-byte数组"><a href="#③-byte数组" class="headerlink" title="③ byte数组"></a>③ byte数组</h5><ul>
<li>字节数组 —&gt; 字符串<ul>
<li><code>String(byte[])</code>：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。</li>
<li><code>String(byte[], int offset, int length)</code> ：用指定的字节数组的一部分，即从数组起始位置offset开始取length个字节构造一个字符串对象。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s1.getBytes();</span><br><span class="line">    <span class="comment">// 采用默认字符集解码</span></span><br><span class="line">    String s = <span class="keyword">new</span> String(bytes);</span><br><span class="line">    System.out.println(s); <span class="comment">// abc123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串 —&gt; 字节数组<ul>
<li><code>public byte[] getBytes()</code> ：使用平台的默认字符集将此 String 编码为byte 序列，并将结果存储到一个新的 byte 数组中。</li>
<li><code>public byte[] getBytes(String charsetName)</code> ：使用指定的字符集将 此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line">    <span class="comment">// 采用默认字符集编码</span></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s1.getBytes();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">byte</span> b : bytes) &#123;</span><br><span class="line">        System.out.println(b); <span class="comment">// 97,98,99,49,50,51</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-6-StringBuffer和StringBuilder类"><a href="#2-1-6-StringBuffer和StringBuilder类" class="headerlink" title="2.1.6 StringBuffer和StringBuilder类"></a>2.1.6 StringBuffer和StringBuilder类</h4><h5 id="①-介绍"><a href="#①-介绍" class="headerlink" title="① 介绍"></a>① 介绍</h5><p><code>java.lang.StringBuffer</code>代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。很多方法与String相同。作为参数传递时，方法内部可以改变值。</p>
<p>StringBuilder 和 StringBuffer 非常类似，<strong>均代表可变的字符序列</strong>，而且提供相关功能的方法也一样</p>
<ul>
<li><p>String、StringBuffer、StringBuilder三者异同</p>
<ul>
<li><code>String</code>（JDK1.0）：不可变字符序列，底层使用<code>char[]</code>存储字符</li>
<li><p><code>StringBuffer</code>（JDK1.5）：可变字符序列、效率低、<strong>线程安全</strong>，底层使用<code>char[]</code>存储字符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="comment">// 该方法没有返回值，修改的就是sb1本身的值</span></span><br><span class="line">    sb1.setCharAt(<span class="number">0</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">    System.out.println(sb1); <span class="comment">// mbc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuilder</code>（JDK5.0）：可变字符序列、效率高、<strong>线程不安全</strong>，底层使用<code>char[]</code>存储字符</p>
</li>
<li>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220326155311108.png" alt="image-20220326155311108"></p>
<h5 id="②-StringBuffer类"><a href="#②-StringBuffer类" class="headerlink" title="② StringBuffer类"></a>② StringBuffer类</h5><blockquote>
<p>StringBuffer源码</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220326152959933.png" alt="image-20220326152959933"></p>
<blockquote>
<p>源码分析</p>
</blockquote>
<ul>
<li>对于String</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">// 实质： char[] value = new char[0];</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 实质：char[] value = new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于StringBuffer</p>
<ul>
<li><p>构造器和有效长度：StringBuffer类不同于String，其<strong>对象必须使用构造器生成</strong>。有三个构造器：</p>
<ul>
<li><code>StringBuffer()</code>：初始容量为16的字符串缓冲区</li>
<li><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</li>
<li><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(); <span class="comment">// char[] value = new char[16];底层创建了一个长度是16的char数组value</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// value[1] = &#x27;b&#x27;;</span></span><br><span class="line">System.out.println(sb1.length()); <span class="comment">// 返回count（有效字符的个数）为2</span></span><br><span class="line"></span><br><span class="line">StringBuffer sb2 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>); <span class="comment">// char[] value = new char[&quot;abc&quot;.length() + 16];创建后额外加16个空间</span></span><br><span class="line">System.out.println(sb2.length()); <span class="comment">// 返回count（有效字符的个数）为3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>扩容：如果要添加的数据对底层数组盛不下了，那就需要扩容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与扩容相关的源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    putStringAt(count, str);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - oldCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value, newCapacity(minimumCapacity) &lt;&lt; coder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = value.length &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> SAFE_BOUND = MAX_ARRAY_SIZE &gt;&gt; coder;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || SAFE_BOUND - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：默认情况下，扩容为原来容量的<code>2倍+2</code>，同时将原有数组的元素复制到这个扩容后的数组当中。</p>
<p>指导意义：建议使用<strong>带参数的构造器</strong><code>StringBuffer(int capacity)</code>和<code>StringBuilder(int capacity)</code>，然后再考虑线程安全的问题</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<ul>
<li><code>StringBuffer append(xxx)</code>：提供了很多重载的append()方法，用于进行字符串拼接</li>
<li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容，左闭右开</li>
<li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str</li>
<li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx</li>
<li><code>StringBuffer reverse()</code> ：把当前字符序列逆转</li>
<li><code>public int indexOf(String str)</code></li>
<li><code>public String substring(int start,int end)</code></li>
<li><code>public int length()</code></li>
<li><code>public char charAt(int n )</code></li>
<li><code>public void setCharAt(int n ,char ch)</code></li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">    s1.append(<span class="number">1</span>);</span><br><span class="line">    System.out.println(s1); <span class="comment">// abc11</span></span><br><span class="line"></span><br><span class="line">    s1.delete(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(s1); <span class="comment">// bc11</span></span><br><span class="line"></span><br><span class="line">    s1.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;ab&quot;</span>);</span><br><span class="line">    System.out.println(s1); <span class="comment">// abc11</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s1.reverse()); <span class="comment">// 11cba</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上方法支持方法链</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">s1.append(<span class="string">&quot;d&quot;</span>).append(<span class="string">&quot;e&quot;</span>).reverse();</span><br><span class="line">System.out.println(s1); <span class="comment">// edcba</span></span><br></pre></td></tr></table></figure>
<h5 id="③-StringBuilder类"><a href="#③-StringBuilder类" class="headerlink" title="③ StringBuilder类"></a>③ StringBuilder类</h5><p>StringBuilder和StringBuffer底层实现基本一致，方法与StringBuffer也一致，故略。</p>
<blockquote>
<p>三者效率对比</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">    String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的执行时间：4</span><br><span class="line">StringBuilder的执行时间：2</span><br><span class="line">String的执行时间：188</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(str);</span><br><span class="line"></span><br><span class="line">    System.out.println(sb.length()); <span class="comment">// 4</span></span><br><span class="line">    System.out.println(sb); <span class="comment">// &quot;null&quot;</span></span><br><span class="line"></span><br><span class="line">    StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(str); <span class="comment">// 报错java.lang.NullPointerException</span></span><br><span class="line">    System.out.println(sb1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<ul>
<li><code>append()</code>方法在添加<code>null</code>时，调用<code>appendNull()</code>：该方法会把null看作是字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(count + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">byte</span>[] val = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (isLatin1()) &#123;</span><br><span class="line">        val[count++] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">        val[count++] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">        val[count++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">        val[count++] = <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count = StringUTF16.putCharsAt(val, count, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用构造器，将null传入进去：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// null.length报错，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-日期时间相关的类"><a href="#2-2-日期时间相关的类" class="headerlink" title="2.2 日期时间相关的类"></a>2.2 日期时间相关的类</h3><h4 id="2-2-1-JDK8之前的API"><a href="#2-2-1-JDK8之前的API" class="headerlink" title="2.2.1 JDK8之前的API"></a>2.2.1 JDK8之前的API</h4><h5 id="①-System类"><a href="#①-System类" class="headerlink" title="①  System类"></a>①  System类</h5><p>System类提供的<code>public static long currentTimeMillis()</code>用来返回当前时间与1970年1月1日0时0分0秒之间以<strong>毫秒</strong>为单位的时间差。此方法适于计算时间差。</p>
<p>计算世界时间的主要标准有：</p>
<ol>
<li><code>UTC(Coordinated Universal Time)</code></li>
<li><code>GMT(Greenwich Mean Time)</code></li>
<li><code>CST(Central Standard Time)</code></li>
</ol>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    System.out.println(time); <span class="comment">// 1648282222985</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-Date类"><a href="#②-Date类" class="headerlink" title="② Date类"></a>② Date类</h5><p>表示特定的瞬间，精确到<strong>毫秒</strong>。</p>
<ul>
<li><p>构造器</p>
<ul>
<li><code>Date()</code>：使用无参构造器创建的对象可以获取<strong>本地当前时间</strong>。</li>
<li><code>Date(long date)</code>：其他参数的构造器已被弃用</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li><code>getTime()</code>:返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的<strong>毫秒数</strong>。</li>
<li><code>toString()</code>:把此 Date 对象转换为以下形式的 String：<code>dow mon dd hh:mm:ss zzz yyyy</code> 其中：dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。 </li>
<li>其它很多方法都过时了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空参构造器</span></span><br><span class="line">    Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">// 默认调用date的toString方法</span></span><br><span class="line">    System.out.println(date1); <span class="comment">// Sat Mar 26 16:14:53 CST 2022</span></span><br><span class="line">    System.out.println(date1.getTime()); <span class="comment">// 1648282572968</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参构造器</span></span><br><span class="line">    Date date2 = <span class="keyword">new</span> Date(<span class="number">1648282572968L</span>);</span><br><span class="line">    System.out.println(date2); <span class="comment">// Sat Mar 26 16:16:12 CST 2022</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意</p>
</blockquote>
<ul>
<li><code>java.sql.Date</code>继承了<code>java.util.Date</code>，对应着数据库中的日期类型的变量。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.sql.Date date = <span class="keyword">new</span> java.sql.Date(<span class="number">1648282572968L</span>);</span><br><span class="line">    System.out.println(date); <span class="comment">// 2022-03-26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>java.util.Date</code> —&gt; <code>java.util.Date</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：强制转换</span></span><br><span class="line">    Date date1 = <span class="keyword">new</span> java.sql.Date();</span><br><span class="line">    java.sql.Date date2 = (java.sql.Date) date1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Date date3 = <span class="keyword">new</span> Date();</span><br><span class="line">    java.sql.Date date4 = <span class="keyword">new</span> java.sql.Date(date3.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-SimpleDateFormat类"><a href="#③-SimpleDateFormat类" class="headerlink" title="③ SimpleDateFormat类"></a>③ SimpleDateFormat类</h5><p>Date类的API不易于国际化，大部分被废弃了，<code>java.text.SimpleDateFormat</code>类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p>
<p>它允许进行格式化：日期 —&gt; 文本、解析：文本 —&gt; 日期</p>
<blockquote>
<p>格式化</p>
</blockquote>
<ul>
<li><code>SimpleDateFormat()</code> ：默认的模式和语言环境创建对象</li>
<li><code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用。其中pattern格式：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220328141608526.png" alt="image-20220328141608526"></p>
<ul>
<li><code>public String format(Date date)</code>：方法格式化时间对象date</li>
</ul>
<blockquote>
<p>解析</p>
</blockquote>
<ul>
<li><code>public Date parse(String source)</code>：从给定字符串的开始解析文本，以生成一个日期。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化SimpleDateFormat，使用默认的构造器</span></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">    <span class="comment">// 格式化日期</span></span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    <span class="comment">// System.out.println(date);</span></span><br><span class="line">    String format = sdf.format(date);</span><br><span class="line">    System.out.println(format); <span class="comment">// 2022/3/28 下午2:11</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析</span></span><br><span class="line">    String str = <span class="string">&quot;22/3/28 上午11:43&quot;</span>;</span><br><span class="line">    Date date1 = sdf.parse(str);</span><br><span class="line">    System.out.println(date1); <span class="comment">// Mon Mar 28 11:43:00 CST 2022</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------------------------</span></span><br><span class="line">    <span class="comment">// 按照指定的方式格式化和解析</span></span><br><span class="line">    SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    String format1 = sdf1.format(date);</span><br><span class="line">    System.out.println(format1); <span class="comment">// 2022-03-28 14:18:45</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析：要求符合sdf识别的格式</span></span><br><span class="line">    Date date2 = sdf1.parse(<span class="string">&quot;2020-01-01 00:00:00&quot;</span>);</span><br><span class="line">    System.out.println(date2); <span class="comment">// Wed Jan 01 00:00:00 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="④-Calendar类"><a href="#④-Calendar类" class="headerlink" title="④ Calendar类"></a>④ Calendar类</h5><p>略</p>
<h4 id="2-2-2-JDK8中新的日期时间API"><a href="#2-2-2-JDK8中新的日期时间API" class="headerlink" title="2.2.2 JDK8中新的日期时间API"></a>2.2.2 JDK8中新的日期时间API</h4><h5 id="①-新API的引入"><a href="#①-新API的引入" class="headerlink" title="① 新API的引入"></a>① 新API的引入</h5><p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</li>
<li>格式化：格式化只对Date有用，Calendar则不行。</li>
<li>此外，它们也不是线程安全的；不能处理闰秒等。</li>
</ul>
<p>第三次引入的API是成功的，并且Java 8中引入的<code>java.time</code> API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。</p>
<blockquote>
<p>新日期时间API</p>
</blockquote>
<ul>
<li><code>java.time</code> – 包含值对象的基础包</li>
<li><code>java.time.chrono</code> – 提供对不同的日历系统的访问</li>
<li><code>java.time.format</code> – 格式化和解析时间和日期</li>
<li><code>java.time.temporal</code> – 包括底层框架和扩展特性</li>
<li><code>java.time.zone</code> – 包含时区支持的类</li>
</ul>
<p>说明：大多数开发者只会用到<strong>基础包和format包</strong>，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</p>
<h5 id="②-LocalDate类"><a href="#②-LocalDate类" class="headerlink" title="② LocalDate类"></a>② LocalDate类</h5><p><code>LocalDate</code>、<code>LocalTime</code>、<code>LocalDateTime</code> 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li><code>LocalDate</code>代表IOS格式（yyyy-MM-dd）的日期，可以存储 生日、纪念日等日期。</li>
<li><code>LocalTime</code>表示一个时间，而不是日期。 </li>
<li><code>LocalDateTime</code>是用来表示日期和时间的，这是一个最常用的类之一。</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220328143438694.png" alt="image-20220328143438694"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前日期、时间、日期+时间</span></span><br><span class="line">    LocalDate localDate = LocalDate.now();</span><br><span class="line">    LocalTime localTime = LocalTime.now();</span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate); <span class="comment">// 2022-03-28</span></span><br><span class="line">    System.out.println(localTime); <span class="comment">// 14:36:49.369528800</span></span><br><span class="line">    System.out.println(localDateTime); <span class="comment">// 2022-03-28T14:36:49.369528800</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// of()</span></span><br><span class="line">    <span class="comment">// 设置指定的年、月、日、时、分、秒，没有偏移量</span></span><br><span class="line">    LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2020</span>, <span class="number">10</span>,<span class="number">6</span>, <span class="number">13</span>, <span class="number">23</span>, <span class="number">59</span>);</span><br><span class="line">    System.out.println(localDateTime1); <span class="comment">// 2020-10-06T13:23:59</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXXX():</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth()); <span class="comment">// 28</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek()); <span class="comment">// MONDAY</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-Instant类"><a href="#③-Instant类" class="headerlink" title="③ Instant类"></a>③ Instant类</h5><p>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。</p>
<p>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以<strong>毫秒</strong>为单位。</p>
<p><code>java.time</code>包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。<strong>Instant表示时间线上的一点，而不需要任何上下文信息</strong>，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度<strong>可以达到纳秒级</strong>。</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220328144434887.png" alt="image-20220328144434887"></p>
<p><strong>时间戳</strong>是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的<strong>总秒数</strong>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取UTC时区（本初子午线）的Instant类的对象</span></span><br><span class="line">    Instant instant = Instant.now();</span><br><span class="line">    System.out.println(instant); <span class="comment">// 2022-03-28T06:46:17.166469400Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加8个小时</span></span><br><span class="line">    OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime); <span class="comment">// 2022-03-28T14:49:04.847567700+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得时间戳</span></span><br><span class="line">    <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli); <span class="comment">// 1648450257945</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过时间戳创建Instant对象</span></span><br><span class="line">    Instant instant1 = Instant.ofEpochMilli(<span class="number">1648450257945L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">// 2022-03-28T06:50:57.945Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="④-DateTimeFormatter类"><a href="#④-DateTimeFormatter类" class="headerlink" title="④ DateTimeFormatter类"></a>④ DateTimeFormatter类</h5><p><code>java.time.format.DateTimeFormatter</code> 类：该类提供了三种格式化方法：</p>
<ul>
<li>预定义的标准格式。如：<code>ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</code></li>
<li>本地化相关的格式。如：<code>ofLocalizedDateTime(FormatStyle.LONG)</code></li>
<li>自定义的格式。如：<code>ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)</code></li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<ul>
<li><code>ofPattern(String pattern)</code> 静态方法 ， 返 回 一 个 指 定 字 符 串 格 式 <code>DateTimeFormatter</code></li>
<li><code>format(TemporalAccessor t)</code> 格式化一个日期、时间，返回字符串</li>
<li><code>parse(CharSequence text)</code> 将指定格式的字符序列解析为一个日期、时间</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方式一：预定义的标准格式</span></span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">// 格式化：日期 --&gt; 字符串</span></span><br><span class="line">    LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">    String str1 = formatter.format(localDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;格式化之前: &quot;</span> + localDateTime); <span class="comment">// 2022-03-28T14:58:27.893263500</span></span><br><span class="line">    System.out.println(<span class="string">&quot;格式化之后: &quot;</span> + str1); <span class="comment">// 2022-03-28T14:58:27.8932635</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析</span></span><br><span class="line">    TemporalAccessor parse = formatter.parse(<span class="string">&quot;2022-03-28T14:58:27.8932635&quot;</span>);</span><br><span class="line">    System.out.println(parse); <span class="comment">// &#123;&#125;,ISO resolved to 2022-03-28T14:58:27.893263500</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：本地相关的格式</span></span><br><span class="line">    DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);</span><br><span class="line">    <span class="comment">// 格式化</span></span><br><span class="line">    String str2 = formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2); <span class="comment">// 2022/3/28 下午3:01</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式三：自定义格式，重点</span></span><br><span class="line">    DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 格式化</span></span><br><span class="line">    String str3 = formatter2.format(localDateTime);</span><br><span class="line">    System.out.println(str3); <span class="comment">// 2022-03-28 15:04:37</span></span><br><span class="line">    <span class="comment">// 解析</span></span><br><span class="line">    TemporalAccessor parse1 = formatter2.parse(<span class="string">&quot;2021-01-01 13:00:01&quot;</span>);</span><br><span class="line">    System.out.println(parse1); <span class="comment">// &#123;&#125;,ISO resolved to 2021-01-01T13:00:01</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="⑤-其他API"><a href="#⑤-其他API" class="headerlink" title="⑤ 其他API"></a>⑤ 其他API</h5><p>略</p>
<h3 id="2-3-比较器"><a href="#2-3-比较器" class="headerlink" title="2.3 比较器"></a>2.3 比较器</h3><p>在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间的比较问题。</p>
<p>Java实现对象排序的方式有两种：</p>
<ol>
<li>自然排序：<code>java.lang.Comparable</code></li>
<li>定制排序：<code>java.util.Comparator</code></li>
</ol>
<h4 id="2-3-1-自然排序"><a href="#2-3-1-自然排序" class="headerlink" title="2.3.1 自然排序"></a>2.3.1 自然排序</h4><h5 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h5><p><code>Comparable</code>接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。</p>
<p>实现 Comparable 的类<strong>必须实现</strong> <code>compareTo(Object obj)</code> 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零。</p>
<p>实现Comparable接口的对象列表（和数组）可以通过 <code>Collections.sort</code> 或<code>Arrays.sort</code>进行<strong>自动排序</strong>。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。</p>
<blockquote>
<p>Comparable 的典型实现：<strong>(默认都是从小到大排列的)</strong></p>
</blockquote>
<ul>
<li>String：按照字符串中字符的Unicode值进行比较</li>
<li>Character：按照字符的Unicode值来进行比较</li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值大小进行比较</li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例</li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
<h5 id="②-实例及使用"><a href="#②-实例及使用" class="headerlink" title="② 实例及使用"></a>② 实例及使用</h5><ul>
<li>像String，包装类等实现了<code>Comparable</code>接口，重写了<code>compareTo()</code>方法，给出了比较两个对象大小的方式。</li>
<li>重写<code>compareTo()</code>的规则：<ul>
<li>如果当前对象this大于形参对象obj，则返回<strong>正整数</strong></li>
<li>如果当前对象this小于形参对象obj，则返回<strong>负整数</strong></li>
<li>如果当前对象this等于形参对象obj，则返回<strong>零</strong>。</li>
</ul>
</li>
<li>对于自定义类来说，如果需要排序，可以让自定义类重写Comparable接口，重写compareTo方法来指明如何排序。</li>
</ul>
<blockquote>
<p>String重写的<code>compareTo()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> v1[] = value;</span><br><span class="line">    <span class="keyword">byte</span> v2[] = anotherString.value;</span><br><span class="line">    <span class="keyword">if</span> (coder() == anotherString.coder()) &#123;</span><br><span class="line">        <span class="keyword">return</span> isLatin1() ? StringLatin1.compareTo(v1, v2)</span><br><span class="line">                          : StringUTF16.compareTo(v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isLatin1() ? StringLatin1.compareToUTF16(v1, v2)</span><br><span class="line">                      : StringUTF16.compareToLatin1(v1, v2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——String实现自然排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;JJ&quot;</span>, <span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(Arrays.toString(arr)); <span class="comment">// [AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——自定义类实现自然排序</p>
</blockquote>
<ul>
<li>要排序的商品类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先按照价格从低到高进行排序</span></span><br><span class="line">    <span class="comment">// 再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="keyword">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 方式二：</span></span><br><span class="line">            <span class="comment">// return Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">    goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">43</span>);</span><br><span class="line">    goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huawei&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    goods[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoft&quot;</span>, <span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(goods);</span><br><span class="line">    System.out.println(Arrays.toString(goods));</span><br><span class="line">    <span class="comment">//[Goods(name=xiaomi, price=12.0),</span></span><br><span class="line">    <span class="comment">// Goods(name=lenovo, price=34.0),</span></span><br><span class="line">    <span class="comment">// Goods(name=microsoft, price=43.0),</span></span><br><span class="line">    <span class="comment">// Goods(name=dell, price=43.0),</span></span><br><span class="line">    <span class="comment">// Goods(name=huawei, price=65.0)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-定制排序"><a href="#2-3-2-定制排序" class="headerlink" title="2.3.2 定制排序"></a>2.3.2 定制排序</h4><h5 id="①-概述-1"><a href="#①-概述-1" class="headerlink" title="① 概述"></a>① 概述</h5><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了<code>java.lang.Comparable</code>接口的排序规则不适合当前的操作，那么可以考虑使用 <code>Comparator</code> 的对象来排序，强行对多个对象进行整体排序的比较。</p>
<ul>
<li>重写<code>compare(Object o1,Object o2)</code>方法：<ul>
<li>比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2</li>
<li>如果返回0，表示相等</li>
<li>返回负整数，表示o1小于o2。</li>
</ul>
</li>
</ul>
<p><strong>可以将 Comparator 传递给 sort 方法</strong>（如 <code>Collections.sort</code> 或 <code>Arrays.sort</code>），从而允许在排序顺序上实现精确控制。</p>
<p>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的顺序，或者为那些没有自然顺序的对象 collection 提供排序。</p>
<h5 id="②-实例及使用-1"><a href="#②-实例及使用-1" class="headerlink" title="② 实例及使用"></a>② 实例及使用</h5><blockquote>
<p>代码示例——String类实现Comparator接口</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;CC&quot;</span>, <span class="string">&quot;KK&quot;</span>, <span class="string">&quot;MM&quot;</span>, <span class="string">&quot;GG&quot;</span>, <span class="string">&quot;JJ&quot;</span>, <span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 从大到小排序</span></span><br><span class="line">            <span class="keyword">return</span> -o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">    <span class="comment">// [MM, KK, JJ, GG, DD, CC, AA]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例——自定义类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line">    goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">34</span>);</span><br><span class="line">    goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dell&quot;</span>, <span class="number">43</span>);</span><br><span class="line">    goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomi&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huawei&quot;</span>, <span class="number">65</span>);</span><br><span class="line">    goods[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoft&quot;</span>, <span class="number">43</span>);</span><br><span class="line">    goods[<span class="number">5</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoft&quot;</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    Arrays.sort(goods, <span class="keyword">new</span> Comparator&lt;Goods&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods o1, Goods o2)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 先照产品名称从低到高排序</span></span><br><span class="line">            <span class="comment">// 再按照价格从高到低进行排序</span></span><br><span class="line">            <span class="keyword">if</span> (o1.getName().equals(o2.getName()))&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(o1.getPrice(), o2.getPrice());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(goods));</span><br><span class="line">    <span class="comment">// [Goods(name=dell, price=43.0), </span></span><br><span class="line">    <span class="comment">// Goods(name=huawei, price=65.0), </span></span><br><span class="line">    <span class="comment">// Goods(name=lenovo, price=34.0), </span></span><br><span class="line">    <span class="comment">// Goods(name=microsoft, price=43.0), </span></span><br><span class="line">    <span class="comment">// Goods(name=microsoft, price=12.0), </span></span><br><span class="line">    <span class="comment">// Goods(name=xiaomi, price=12.0)]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-二者对比"><a href="#③-二者对比" class="headerlink" title="③ 二者对比"></a>③ 二者对比</h5><ul>
<li><code>Comparable</code>一旦指定，能够保证实现类的对象能在任何位置都可以比较大小</li>
<li><code>Comparator</code>属于临时性的比较</li>
</ul>
<h3 id="2-4-System类"><a href="#2-4-System类" class="headerlink" title="2.4 System类"></a>2.4 System类</h3><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。 </p>
<p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
<blockquote>
<p>成员变量</p>
</blockquote>
<p>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个<strong>成员变量</strong>，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 </p>
<blockquote>
<p>成员方法</p>
</blockquote>
<ul>
<li><code>native long currentTimeMillis()</code>： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li>
<li><code>void exit(int status)</code>： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li>
<li><code>void gc()</code>： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
<li><code>String getProperty(String key)</code>： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220328195543331.png" alt="image-20220328195543331"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String javaVersion = System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line">    String javaHome = System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line">    String osName = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line">    String osVersion = System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line">    String userName = System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line">    String userHome = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line">    String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line">    <span class="comment">// java的version:11.0.10</span></span><br><span class="line">    <span class="comment">// java的home:C:\Users\Hongyi\.jdks\corretto-11.0.10</span></span><br><span class="line">    <span class="comment">// os的name:Windows 10</span></span><br><span class="line">    <span class="comment">// os的version:10.0</span></span><br><span class="line">    <span class="comment">// user的name:Hongyi</span></span><br><span class="line">    <span class="comment">// user的home:C:\Users\Hongyi</span></span><br><span class="line">    <span class="comment">// user的dir:E:\develop\study\backend_study\javase</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-枚举类和注解"><a href="#3-枚举类和注解" class="headerlink" title="3 枚举类和注解"></a>3 枚举类和注解</h2><h3 id="3-1-枚举类的使用"><a href="#3-1-枚举类的使用" class="headerlink" title="3.1 枚举类的使用"></a>3.1 枚举类的使用</h3><h4 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1 概述"></a>3.1.1 概述</h4><p>类的对象只有有限个，确定的。举例如下：</p>
<ul>
<li>星期：Monday(星期一)、……、Sunday(星期天) </li>
<li>性别：Man(男)、Woman(女) </li>
<li>季节：Spring(春节)……Winter(冬天) </li>
<li>支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银<br>  行卡)、CreditCard(信用卡) </li>
<li>就职状态：Busy、Free、Vocation、Dimission</li>
<li>订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、Return（退货）、Checked（已确认）Fulfilled（已配货）</li>
<li>线程状态：创建、就绪、运行、阻塞、死亡</li>
</ul>
<p>当需要定义一组常量时，强烈建议使用枚举类。</p>
<blockquote>
<p>枚举类的实现</p>
</blockquote>
<ul>
<li><p>JDK1.5之前需要自定义枚举类</p>
</li>
<li><p>JDK1.5新增的 <code>enum</code> 关键字用于定义枚举类</p>
</li>
</ul>
<p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</p>
<blockquote>
<p>枚举类的属性</p>
</blockquote>
<ul>
<li><p>枚举类对象的属性不应允许被改动，所以应该使用 <code>private final</code> 修饰</p>
</li>
<li><p>枚举类的使用 <code>private final</code> 修饰的属性应该在构造器中为其赋值</p>
</li>
<li><p>若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</p>
</li>
</ul>
<h4 id="3-1-2-自定义枚举类"><a href="#3-1-2-自定义枚举类" class="headerlink" title="3.1.2 自定义枚举类"></a>3.1.2 自定义枚举类</h4><p>JDK1.5之前需要自定义枚举类</p>
<ul>
<li>私有化类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例，声明为：<code>public static final</code></li>
<li>对象如果有实例变量，应该声明为<code>private final</code>，并在构造器中初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Season.AUTUMN); <span class="comment">// Season&#123;seasonName=&#x27;秋天&#x27;, seasonDesc=&#x27;秋高气爽&#x27;&#125;</span></span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.提供当前枚举类的多个对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;烈日当空&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.toString</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-使用Enum定义枚举类"><a href="#3-1-3-使用Enum定义枚举类" class="headerlink" title="3.1.3 使用Enum定义枚举类"></a>3.1.3 使用Enum定义枚举类</h4><h5 id="①-使用说明"><a href="#①-使用说明" class="headerlink" title="① 使用说明"></a>① 使用说明</h5><ul>
<li>使用 <code>enum</code> 定义的枚举类默认继承了 <code>java.lang.Enum</code>类，因此不能再继承其他类</li>
<li>枚举类的构造器只能使用 <code>private</code> 权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出(<code>,</code>分隔 <code>;</code>结尾)。列出的实例系统会<strong>自动</strong>添加 <code>public static final</code> 修饰</li>
<li>必须在枚举类的<strong>第一行</strong>声明枚举类对象</li>
</ul>
<p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式，case 子句可以直接使用枚举值的名字，无需添加枚举类作为限定。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(Season.SPRING); <span class="comment">// SPRING</span></span><br><span class="line">        System.out.println(Season.class.getSuperclass()); <span class="comment">// class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象</span></span><br><span class="line">    <span class="comment">// 多个对象之间用 , 隔开，最后一个用 ;</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;烈日当空&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-Enum类的主要方法"><a href="#②-Enum类的主要方法" class="headerlink" title="② Enum类的主要方法"></a>② Enum类的主要方法</h5><ul>
<li><code>values()</code>：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</li>
<li><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：<code>IllegalArgumentException</code></li>
<li><code>toString()</code>：返回当前枚举类对象常量的名称</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Season summer = Season.SUMMER;</span><br><span class="line">    <span class="comment">// 枚举类对象的toString方法</span></span><br><span class="line">    <span class="comment">// 输出枚举类对象的名称</span></span><br><span class="line">    System.out.println(summer.toString()); <span class="comment">// SUMMER</span></span><br><span class="line">    <span class="comment">// values()返回枚举类型的对象数组</span></span><br><span class="line">    Season[] seasons = Season.values();</span><br><span class="line">    <span class="keyword">for</span>(Season season:seasons)&#123;</span><br><span class="line">        System.out.println(season);</span><br><span class="line">        <span class="comment">// SPRING</span></span><br><span class="line">        <span class="comment">// SUMMER</span></span><br><span class="line">        <span class="comment">// AUTUMN</span></span><br><span class="line">        <span class="comment">// WINTER</span></span><br><span class="line">    &#125;</span><br><span class="line">    Thread.State[] states = Thread.State.values();</span><br><span class="line">    <span class="keyword">for</span>(Thread.State state:states)&#123;</span><br><span class="line">        System.out.println(state);</span><br><span class="line">        <span class="comment">// NEW</span></span><br><span class="line">        <span class="comment">// RUNNABLE</span></span><br><span class="line">        <span class="comment">// BLOCKED</span></span><br><span class="line">        <span class="comment">// WAITING</span></span><br><span class="line">        <span class="comment">// TIMED_WAITING</span></span><br><span class="line">        <span class="comment">// TERMINATED</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------------------------------------</span></span><br><span class="line">    Season winter = Season.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">    System.out.println(winter); <span class="comment">// WINTER</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-实现接口的枚举类"><a href="#③-实现接口的枚举类" class="headerlink" title="③ 实现接口的枚举类"></a>③ 实现接口的枚举类</h5><ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>情况一：若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Season autumn = Season.AUTUMN;</span><br><span class="line">        autumn.show(); <span class="comment">// 这是一个季节</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象</span></span><br><span class="line">    <span class="comment">// 多个对象之间用 , 隔开，最后一个用 ;</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;烈日当空&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个季节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>情况二：若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Season autumn = Season.AUTUMN;</span><br><span class="line">        autumn.show(); <span class="comment">// 这是秋天</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.提供当前枚举类的对象</span></span><br><span class="line">    <span class="comment">// 多个对象之间用 , 隔开，最后一个用 ;</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是春天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;烈日当空&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是夏天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是秋天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是冬天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.声明Season对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.私有化类的构造器，并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-注解的使用"><a href="#3-2-注解的使用" class="headerlink" title="3.2 注解的使用"></a>3.2 注解的使用</h3><h4 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h4><p>从 <code>JDK 5.0</code> 开始，Java 增加了对元数据(MetaData) 的支持，也就是Annotation(注解) 。</p>
<p>Annotation 其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p>
<p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法,、成员变量、参数、局部变量的声明，这些信息被保存在 Annotation 的 <code>name=value</code> 对中。</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。 </p>
<p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：==框架 = 注解 + 反射 + 设计模式==。</p>
<h4 id="3-2-2-常见的Annotation示例"><a href="#3-2-2-常见的Annotation示例" class="headerlink" title="3.2.2 常见的Annotation示例"></a>3.2.2 常见的Annotation示例</h4><p>使用 Annotation 时要在其前面增加 <code>@</code> 符号，，并把该 Annotation 当成一个修饰符使用，用于修饰它支持的程序元素。</p>
<blockquote>
<p>示例1——生成文档相关的注解</p>
</blockquote>
<ul>
<li><code>@author</code> 标明开发该类模块的作者，多个作者之间使用,分割</li>
<li><code>@version</code> 标明该类模块的版本</li>
<li><code>@see</code> 参考转向，也就是相关主题</li>
<li><code>@since</code> 从哪个版本开始增加的</li>
<li><code>@param</code> 对方法中某参数的说明，如果没有参数就不能写</li>
<li><code>@return</code> 对方法返回值的说明，如果方法的返回值类型是void就不能写</li>
<li><code>@exception</code> 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写</li>
</ul>
<blockquote>
<p>示例2——在编译时进行格式检查(JDK内置的三个基本注解)</p>
</blockquote>
<ul>
<li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法</li>
<li><code>@Deprecated</code>: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。</li>
<li><code>@SuppressWarnings</code>: 抑制编译器警告</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Hongyi&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        p.eat();</span><br><span class="line">        <span class="comment">// 抑制编译器警告：因为a没被使用</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;walk...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 过时的方法</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Infor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Infor</span></span>&#123;</span><br><span class="line">    <span class="comment">// 重写方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student walks...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;student shows...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>示例3——跟踪代码依赖性，实现替代配置文件功能</p>
</blockquote>
<ul>
<li>Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。</li>
<li>spring框架中关于“事务”的管理</li>
</ul>
<h4 id="3-2-3-自定义注解"><a href="#3-2-3-自定义注解" class="headerlink" title="3.2.3 自定义注解"></a>3.2.3 自定义注解</h4><h5 id="①-基本使用"><a href="#①-基本使用" class="headerlink" title="① 基本使用"></a>① 基本使用</h5><ul>
<li>定义新的 Annotation 类型使用 <code>@interface</code> 关键字</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>
<li>Annotation 的成员变量在 Annotation 定义中以<strong>无参数方法</strong>的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为<strong>配置参数</strong>。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组。 </li>
<li>可以在定义 Annotation 的成员变量时为其指定初始值，指定成员变量的初始值可使用 <code>default</code> 关键字</li>
<li>如果只有一个参数成员，建议使用参数名为value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略“value=” </li>
<li>没有成员定义的 Annotation 称为<strong>标记</strong>（例如<code>@Override</code>），包含成员变量的 Annotation 称为<strong>元数据</strong>Annotation</li>
<li>注意：自定义注解必须配上注解的信息处理流程（使用反射）才有意义。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>自定义注解类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;world&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;hello&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-基本元注解"><a href="#②-基本元注解" class="headerlink" title="② 基本元注解"></a>② 基本元注解</h5><p>JDK 的元 Annotation 用于修饰其他 Annotation 定义，对现有的注解进行说明的注解。</p>
<p>JDK5.0提供了4个标准的meta-annotation类型，分别是：</p>
<ol>
<li><code>Retention</code></li>
<li><code>Target</code></li>
<li><code>Documented</code></li>
<li><code>Inherited</code></li>
</ol>
<blockquote>
<p><code>@Retention</code></p>
</blockquote>
<ul>
<li>只能用于修饰一个 Annotation 定义，用于指定该 Annotation 的<strong>生命周期</strong>，@Rentention 包含一个 <code>RetentionPolicy</code> 类型的成员变量，使用@Rentention 时必须为该 value 成员变量指定值<ul>
<li><code>RetentionPolicy.SOURCE</code>:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释。</li>
<li><code>RetentionPolicy.CLASS</code>:在class文件中有效（即class保留），当运行 Java 程序时，JVM 不会保留注解。 这是<strong>默认值</strong>。</li>
<li><code>RetentionPolicy.RUNTIME</code>:在运行时有效（即运行时保留），当运行 Java 程序时，JVM 会保留注释。程序可以通过<strong>反射</strong>获取该注释。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220330133458366.png" alt="image-20220330133458366"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>@Target</code></p>
</blockquote>
<p>用于修饰 Annotation 定义，用于指定被修饰的 Annotation <strong>能用于修饰哪些程序元素</strong>。 @Target 也包含一个名为 value 的成员变量。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">取值（ElementType）</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>CONSTRUCTOR</code></td>
<td style="text-align:center">构造器</td>
</tr>
<tr>
<td style="text-align:center"><code>FIELD</code></td>
<td style="text-align:center">域</td>
</tr>
<tr>
<td style="text-align:center"><code>LOCAL_VIRIABLE</code></td>
<td style="text-align:center">局部变量</td>
</tr>
<tr>
<td style="text-align:center"><code>METHOD</code></td>
<td style="text-align:center">方法</td>
</tr>
<tr>
<td style="text-align:center"><code>PACKAGE</code></td>
<td style="text-align:center">包</td>
</tr>
<tr>
<td style="text-align:center"><code>PARAMETER</code></td>
<td style="text-align:center">参数</td>
</tr>
<tr>
<td style="text-align:center"><code>TYPE</code></td>
<td style="text-align:center">类、接口、enum</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><code>@Documented</code></p>
</blockquote>
<p>用于指定被该元 Annotation 修饰的 Annotation 类将被 javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 </p>
<p>定义为Documented的注解必须设置Retention值为RUNTIME</p>
<blockquote>
<p><code>@Inherited</code></p>
</blockquote>
<p>被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation，则其子类将自动具有该注解。使用很少。</p>
<h2 id="4-集合"><a href="#4-集合" class="headerlink" title="4 集合"></a>4 集合</h2><h3 id="4-1-集合框架概述"><a href="#4-1-集合框架概述" class="headerlink" title="4.1 集合框架概述"></a>4.1 集合框架概述</h3><p>集合，数组都是对多个数据进行存储的结构，简称Java容器。说明：此时的存储是内存层面的存储，不涉及持久化的存储。</p>
<p>java集合可分为Collection和Map两种体系。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220330134625224.png" alt="image-20220330134625224"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220330134642074.png" alt="image-20220330134642074"></p>
<ol>
<li>Collection接口：单列数据，定义了存取一组对象的方法和集合。</li>
</ol>
<ul>
<li>List：元素有序，可重复的集合</li>
<li>Set：元素无序，不可重复的集合</li>
</ul>
<ol>
<li>Map接口：双列数据，保存具有映射关系Key-Value对的集合。</li>
</ol>
<h4 id="4-1-1-数组的特点"><a href="#4-1-1-数组的特点" class="headerlink" title="4.1.1 数组的特点"></a>4.1.1 数组的特点</h4><blockquote>
<p>数组在存储多个数据方面的特点</p>
</blockquote>
<ol>
<li><p>一旦初始化以后，其长度就确定了</p>
</li>
<li><p>数组一旦定义好，其元素的类型也就确定了，例如String[] arr；Object[] arr等</p>
</li>
</ol>
<blockquote>
<p>数组在存储多个数据方面的缺点</p>
</blockquote>
<ol>
<li><p>一旦初始化后，其长度就无法修改</p>
</li>
<li><p>数组中提供的方法非常有限，对于添加，删除，插入数据等操作非常不便，同时效率不高。</p>
</li>
<li><p>对于获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</p>
</li>
<li><p>数组存储数据的特点：有序，可重复。对于无序，不可重复的需求，数组不能满足。</p>
</li>
</ol>
<h4 id="4-1-2-集合框架"><a href="#4-1-2-集合框架" class="headerlink" title="4.1.2 集合框架"></a>4.1.2 集合框架</h4><p>|——Collection接口：<strong>单列集合</strong>，用来存储一个一个的对象</p>
<p>​        |——List接口：存储有序的，可重复的数据。“动态数组”</p>
<p>​                |——ArrayList，LinkedList，Vector</p>
<p>​        |——Set接口：存储无序的，不可重复的数据。高中讲的“集合”</p>
<p>​                |——HashSet，LinkedHashSet，TreeSet</p>
<p>|——Map接口：<strong>双列集合</strong>，用来存储一对一对的数据。 高中讲的“函数”：y = f(x)</p>
<p>​        |——HashMap，LinkedHashMap，TreeMap，Hashtable，Properties</p>
<h3 id="4-2-Collection接口"><a href="#4-2-Collection接口" class="headerlink" title="4.2 Collection接口"></a>4.2 Collection接口</h3><h4 id="4-2-1-Collection接口中的常用方法"><a href="#4-2-1-Collection接口中的常用方法" class="headerlink" title="4.2.1 Collection接口中的常用方法"></a>4.2.1 Collection接口中的常用方法</h4><blockquote>
<p><code>add()</code>，<code>addAll()</code>，<code>clear()</code>，<code>size()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 以实现类ArrayList中的方法为例</span></span><br><span class="line">  Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="comment">// add(Object e):将元素e添加到集合coll中</span></span><br><span class="line">  coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">  coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">  coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size():获取添加的元素的个数</span></span><br><span class="line">  System.out.println(coll.size());<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// addAll(Collection coll1):将coll1中的元素添加到当前的集合中</span></span><br><span class="line">  Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  coll1.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">  coll1.add(<span class="keyword">new</span> Date());</span><br><span class="line">  coll.addAll(coll1);</span><br><span class="line">  System.out.println(coll.size());<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear():清空集合中的元素</span></span><br><span class="line">  <span class="comment">// coll.clear();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty():判断当前集合是否为空</span></span><br><span class="line">  System.out.println(coll.isEmpty());<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>contains()</code>，<code>containsAll()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">// contains在判断时会调用obj对象所在类的equals方法。通常自定义的类都要重写equals方法。</span></span><br><span class="line">    <span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">    System.out.println(contains);<span class="comment">// true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>)));<span class="comment">// true 判断的是内容，调用的是equals，而不是==</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>)));<span class="comment">// false 如果重写Person类的equals则为true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在与当前集合中</span></span><br><span class="line">    Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>类中重写的<code>equals</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idea自动生成的重写Object类里的equals方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是同一个对象，则为真</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 比较对象为空，则为假</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 强转为Person</span></span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    <span class="comment">// 先比较age字段</span></span><br><span class="line">    <span class="keyword">if</span> (age != person.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 再比较name字段</span></span><br><span class="line">    <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>remove()</code>，<code>removeAll()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove(Object obj):移除集合中的指定元素，移除成功返回true，不成功为false</span></span><br><span class="line">    System.out.println(coll.remove(<span class="number">123</span>));<span class="comment">// true 表明已移除</span></span><br><span class="line">    System.out.println(coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeAll():差集：从当前集合中移除coll1中的所有的元素</span></span><br><span class="line">    Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">    coll.removeAll(coll1);</span><br><span class="line">    System.out.println(coll);<span class="comment">// [Tom, false]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>retainAll()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.retainAll(coll1);<span class="comment">// 获取coll和coll1的交集，并返回给coll</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>equals()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 注意ArrayList是有序的，比较时就要判断顺序</span></span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll1.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll1.add(<span class="number">456</span>);</span><br><span class="line">    coll1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll1.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals(Collection coll1):比较当前集合和coll1中的内容和对应顺序是否都一样</span></span><br><span class="line">    System.out.println(coll.equals(coll1));<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hashCode()</code>，<code>toArray()</code>，<code>Arrays.asList()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashCode():返回当前对象的hash值</span></span><br><span class="line">    System.out.println(coll.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转换为数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组转换为集合:调用Arrays的静态方法asList()</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>&#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-集合元素的遍历"><a href="#4-2-2-集合元素的遍历" class="headerlink" title="4.2.2 集合元素的遍历"></a>4.2.2 集合元素的遍历</h4><p>集合元素的遍历操作，需要使用<code>Iterator</code>接口。</p>
<ul>
<li>设计模式给迭代器模式的定义为：提供一种方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</li>
<li>Collection接口继承了<code>java.lang.Iterable</code>接口，该接口有一个<code>iterator()</code>方法，那么所有实现了Collection接口的集合类都有一个iterator方法，用以返回一个实现了Iterator接口的对象。</li>
<li>Iterator仅用于遍历集合，其本身不具有提供承载对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</li>
<li>==集合对象每次调用iterator方法都得到一个全新的迭代器对象==，默认游标都在集合的<strong>第一个元素之前</strong>。</li>
</ul>
<blockquote>
<p>遍历代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line">    <span class="comment">// 获取集合对象的迭代器</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// 集合遍历：</span></span><br><span class="line">    <span class="comment">// 方法1：不推荐</span></span><br><span class="line">    <span class="comment">// next():获取游标的下一个元素，游标的初始位置在集合首个元素之前一个位置</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    <span class="comment">// 报异常：NoSuchElementException</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：不推荐</span></span><br><span class="line">    Iterator iterator1 = coll.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coll.size();i++)&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：推荐 hasNext()和next()搭配使用</span></span><br><span class="line">    Iterator iterator2 = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next():1.指针下移 2.将下移以后的位置上的元素返回</span></span><br><span class="line">        System.out.println(iterator2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代器原理</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224454538.png" alt="image-20211215224454538"></p>
<blockquote>
<p>用迭代器遍历的错误写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>((iterator.next()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;<span class="comment">// 导致间隔输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(coll.iterator().hasNext())&#123;<span class="comment">// 每次循环都会产生新的迭代器</span></span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;<span class="comment">// 死循环，且只输出第一个元素</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代器的<code>remove()</code></p>
</blockquote>
<p>可以在遍历的时候删除集合中的元素。此方法不同于集合直接调用<code>remove</code>方法</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除集合中&quot;Tom&quot;字符串</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果还未调用next就调用remove，或者调用一次remove后再次调用remove，会报<code>IllegalStateException</code>异常。</p>
<h4 id="4-2-3-foreach循环遍历"><a href="#4-2-3-foreach循环遍历" class="headerlink" title="4.2.3 foreach循环遍历"></a>4.2.3 <code>foreach</code>循环遍历</h4><p><code>jdk5.0</code>新增特性，用于遍历数组和集合。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(集合中元素的类型 局部变量:集合对象)&#123; ... &#125;</span></span><br><span class="line">    <span class="comment">// 内部仍然调用了迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// foreach遍历数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: arr) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个练习题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String arr[] = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：普通for赋值，此时能够改变原始数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i] = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：增强for循环，此时只能改变局部变量s的值，原始数组不变</span></span><br><span class="line">    <span class="keyword">for</span> (String s : arr)&#123;</span><br><span class="line">        s = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-List接口及其实现类"><a href="#4-3-List接口及其实现类" class="headerlink" title="4.3 List接口及其实现类"></a>4.3 List接口及其实现类</h3><h4 id="4-3-1-List概述"><a href="#4-3-1-List概述" class="headerlink" title="4.3.1 List概述"></a>4.3.1 List概述</h4><ul>
<li>List接口是Collection的子接口，通常使用List来替代数组。</li>
<li>List集合中的元素有序且可重复，每个元素都有对应的索引顺序，可根据整型序号来对元素进行存取。</li>
<li>List接口的常用实现类有<code>ArrayList</code>，<code>LinkedList</code>和<code>Vector</code></li>
</ul>
<blockquote>
<p>面试题：实现类三者的异同？</p>
</blockquote>
<p>同：都是List接口的实现类，存储的都是有序可重复的数据。</p>
<p>异：</p>
<p>|——Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​        |——List接口：存储有序的，可重复的数据。“动态数组”</p>
<p>​                |——ArrayList：<code>JDK1.2</code>，作为List接口的主要实现类，线程不安全的，效率高；底层采用<code>Object[] elementData</code>存储（<code>顺序表</code>）</p>
<p>​                |——LinkedList：<code>JDK1.2</code>，底层采用的<code>双向链表</code>存储，对于频繁的插入和删除操作的效率比上者高。</p>
<p>​                |——Vector：<code>JDK1.0</code>，是List接口的古老实现类，线程安全的，效率低</p>
<h4 id="4-3-2-ArrayList源码分析"><a href="#4-3-2-ArrayList源码分析" class="headerlink" title="4.3.2 ArrayList源码分析"></a>4.3.2 ArrayList源码分析</h4><blockquote>
<p><code>JDK7</code>版本——饿汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">// 底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment">//...一系列添加操作</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 如果此次的添加导致elementData容量不够，则扩容，默认扩容为原来容量的1.5倍（新造一个数组），同时需要将原有的数据复制到新的数组中</span></span><br></pre></td></tr></table></figure>
<p>结论：实际开发中使用带参的构造器，指定出大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>JDK8</code>版本——懒汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">// 底层Object[] elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 第一次调用add()时，底层才创建长度为10的数组，并将数据添加进去</span></span><br><span class="line"><span class="comment">// 后续的添加和扩容操作与jdk7无异</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小结</p>
</blockquote>
<p>jdk7的ArrayList对象的创建类似于单例的饿汉式，jdk8类似于单例的懒汉式，延迟了数组的创建，节省内存。</p>
<h4 id="4-3-3-LinkedList源码分析"><a href="#4-3-3-LinkedList源码分析" class="headerlink" title="4.3.3 LinkedList源码分析"></a>4.3.3 LinkedList源码分析</h4><blockquote>
<p><code>JDK8</code>版本</p>
</blockquote>
<ul>
<li>结点结构：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为LinkedList类的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    LinkedList.Node&lt;E&gt; next;</span><br><span class="line">    LinkedList.Node&lt;E&gt; prev;<span class="comment">// 体现了双向链表</span></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">    Node(LinkedList.Node&lt;E&gt; prev, E element, LinkedList.Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加元素（连接在链表尾部）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    LinkedList.Node&lt;E&gt; l = <span class="keyword">this</span>.last;</span><br><span class="line">    LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> LinkedList.Node(l, e, (LinkedList.Node)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;<span class="comment">// 链表为空</span></span><br><span class="line">        <span class="keyword">this</span>.first = newNode;<span class="comment">// 作为第一个结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 链表不空</span></span><br><span class="line">        l.next = newNode;<span class="comment">// 连接在尾部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++<span class="keyword">this</span>.size;</span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();<span class="comment">// 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 将123封装到Node对象</span></span><br><span class="line"><span class="comment">// 不涉及扩容</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-List接口的常用方法"><a href="#4-3-4-List接口的常用方法" class="headerlink" title="4.3.4 List接口的常用方法"></a>4.3.4 List接口的常用方法</h4><p>List接口除了有从Collection接口继承的方法外，还添加了一些根据索引来操作集合元素的方法。</p>
<blockquote>
<p>代码演示说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    list.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void add(int index,Object ele):在index位置上插入ele</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, BB, 456, Tom, false, Person&#123;name=&#x27;Jerry&#x27;, age=20&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean addAll(int index,Collection eles):从index位置开始将eles的所有元素添加到list中</span></span><br><span class="line">    List list1 = Arrays.asList(<span class="string">&quot;hongyi&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">    list.addAll(<span class="number">1</span>,list1);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, hongyi, true, BB, 456, Tom, false, Person&#123;name=&#x27;Jerry&#x27;, age=20&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object get(int index):获取index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">// hongyi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int indexOf(Object obj):返回obj在集合中首次出现的索引</span></span><br><span class="line">    <span class="comment">// 没有返回-1</span></span><br><span class="line">    System.out.println(list.indexOf(<span class="string">&quot;BB&quot;</span>));<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int lastIndexOf(Object obj):返回obj在集合中最后出现的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object remove(int index):移除index位置上的元素，并返回此元素</span></span><br><span class="line">    <span class="comment">// 注意这个方法重载了Collection的remove方法</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">0</span>));<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object set(int index,Object obj):将index位置上的元素更改为obj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List subList(int fromIndex,int toIndex):返回从fromIndex到toIndex位置上的子集合</span></span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    List list2 = list.subList(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(list2);<span class="comment">//[true, BB, 456]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结常用方法</p>
</blockquote>
<ul>
<li><p>增：<code>add(Object obj)</code></p>
</li>
<li><p>删：<code>remove(int index)</code>/<code>remove(Object obj)</code></p>
</li>
<li><p>改：<code>set()</code></p>
</li>
<li><p>查：<code>get()</code></p>
</li>
<li><p>插：<code>add()</code></p>
</li>
<li><p>长度：<code>size()</code></p>
</li>
<li><p>遍历：1.Iterator迭代器 2.增强for循环 3.普通循环</p>
</li>
</ul>
<h4 id="4-3-5-List集合的遍历"><a href="#4-3-5-List集合的遍历" class="headerlink" title="4.3.5 List集合的遍历"></a>4.3.5 List集合的遍历</h4><blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    list.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：迭代器</span></span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：增强for循环</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：普通for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一道笔试题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);<span class="comment">// [1, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意区分List中的<code>remove</code>方法</p>
<h3 id="4-4-Set接口及其实现类"><a href="#4-4-Set接口及其实现类" class="headerlink" title="4.4 Set接口及其实现类"></a>4.4 Set接口及其实现类</h3><h4 id="4-4-1-Set概述"><a href="#4-4-1-Set概述" class="headerlink" title="4.4.1 Set概述"></a>4.4.1 Set概述</h4><p>Set接口中没有额外定义新的方法，使用的都是Collection接口定义的方法</p>
<blockquote>
<p>框架</p>
</blockquote>
<p>|——Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​        |——Set接口：存储==无序的，不可重复==的数据。高中讲的“集合”</p>
<p>​                |——HashSet：作为Set的主要实现类；线程不安全，可以存储null值</p>
<p>​                        |——LinkedHashSet：作为HashSet的子类；遍历其内部数据时可以按照添加的顺序去遍历</p>
<p>​                |——TreeSet：可以按照添加的对象的指定属性进行排序，底层采用==红黑树==</p>
<blockquote>
<p>无序和无可重复的理解</p>
</blockquote>
<ul>
<li>无序性：不等于随机性。以HashSet为例，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值添加。</li>
<li>不可重复性：保证添加的元素按照<code>equal</code>方法判断时不能返回<code>true</code>，即相同的元素只能添加一个。</li>
</ul>
<h4 id="4-4-2-HashSet添加元素的过程"><a href="#4-4-2-HashSet添加元素的过程" class="headerlink" title="4.4.2 HashSet添加元素的过程"></a>4.4.2 HashSet添加元素的过程</h4><p>向HashSet中添加元素a，首先，调用a的所在类的hashCode方法，计算出a元素的哈希值，此哈希值接着通过某种算法（例如除留余数法）计算出a在HashSet底层数组中的存放位置，即为索引位置。判断数组此位置上是否已经含有元素：</p>
<p>|—-如果此位置上没有其他元素，则a添加成功；—-&gt;情况1</p>
<p>|—-如果此位置上有其他元素b（或以链表形式存在的多个元素），首先比较a和b的哈希值：</p>
<p>​        |—-如果哈希值不相同，则a添加成功；—-&gt;情况2</p>
<p>​        |—-如果哈希值相同，则需要调用a所在类的equals方法，与链表上的元素逐一相比:</p>
<p>​                |—-如果一旦返回true，则添加失败;</p>
<p>​                |—-如果比较到最后返回false，则a添加成功；—-&gt;情况3</p>
<p>对于添加成功的情况2和情况3，元素a与已经存在指定索引位置上的数据以链表方式进行存储。在JDK7中，元素a放在数组中，指向原来的元素链；在JDK8中，原来的链尾元素指向新添加进来的元素a。（==7上8下==）</p>
<p>HashSet的底层为：==数组+链表==，实质上还是new了一个HashMap</p>
<h4 id="4-4-3-关于equals-和hashCode-方法的重写"><a href="#4-4-3-关于equals-和hashCode-方法的重写" class="headerlink" title="4.4.3 关于equals()和hashCode()方法的重写"></a>4.4.3 关于<code>equals()</code>和<code>hashCode()</code>方法的重写</h4><blockquote>
<p>idea中自动生成的重写方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    User user = (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(user.name) : user.name == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择31作为乘数的原因：选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）。并且31只占用5bits，相乘造成数据溢出的概率较小。31可以由<code>i*31== (i&lt;&lt;5)-1</code>来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）。31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</p>
<blockquote>
<p>重写原则</p>
</blockquote>
<ul>
<li><p>向set添加的元素所在的类必须重写hashCode和equals方法。</p>
</li>
<li><p>重写的两个方法要保持一致性：相等的对象必须有相等的哈希值</p>
</li>
</ul>
<blockquote>
<p>重写hashCode方法的原则</p>
</blockquote>
<ul>
<li><p>在程序运行时，同一个对象多次调用 <code>hashCode()</code> 方法应该返回相同的值。</p>
</li>
<li><p>当两个对象的 <code>equals()</code> 方法比较返回 true 时，这两个对象的 <code>hashCode()</code> 方法的返回值也应相等。</p>
</li>
<li><p>对象中用作 <code>equals()</code> 方法比较的属性，都应该用来计算 hashCode 值。</p>
</li>
</ul>
<blockquote>
<p>重写equals方法的原则</p>
</blockquote>
<p>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</p>
<p>因此，违反了“相等的对象必须具有相等的散列码”。</p>
<p>结论：==复写equals方法的时候一般都需要同时复写hashCode方法==。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</p>
<h4 id="4-4-4-LinkedHashSet的使用"><a href="#4-4-4-LinkedHashSet的使用" class="headerlink" title="4.4.4 LinkedHashSet的使用"></a>4.4.4 LinkedHashSet的使用</h4><p>LinkedHashSet是作为HashSet的子类，在添加数据的同时，还维护了每个数据的添加的先后顺序。即每个结点有前后两个指针域，指示上一个和下一个元素的位置。对于频繁的遍历操作，效率比HashSet高。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashSet的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));<span class="comment">// 重复元素不会被添加进集合</span></span><br><span class="line">    set.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224525688.png" alt="image-20211215224525688"></p>
<blockquote>
<p>原理示意图</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224534048.png" alt="image-20211215224534048"></p>
<h4 id="4-4-5-TreeSet的使用"><a href="#4-4-5-TreeSet的使用" class="headerlink" title="4.4.5 TreeSet的使用"></a>4.4.5 TreeSet的使用</h4><ol>
<li>向TreeSet中添加的数据，要求是==相同类的对象==</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);<span class="comment">// 此处就会报错，不能添加不同类的对象</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));<span class="comment">// 这里也会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以按照排序后输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="number">13</span>);</span><br><span class="line">    set.add(<span class="number">6</span>);</span><br><span class="line">    set.add(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224543201.png" alt="image-20211215224543201"></p>
<ol>
<li>TreeSet的底层是==红黑树==</li>
</ol>
<blockquote>
<p>TreeSet的自然排序（要求比较对象所在类实现Comparable接口）</p>
</blockquote>
<p>在TreeSet自然排序中，比较两个对象是否相同的标准为：<code>compareTo()</code>返回值为0,不再是用<code>equals()</code>判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">53</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照姓名，年龄从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)o;</span><br><span class="line">            <span class="keyword">int</span> compare = <span class="keyword">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span>(compare != <span class="number">0</span>)&#123;<span class="comment">// 先按照姓名排序</span></span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 再按照年龄排序</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age,user.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224551930.png" alt="image-20211215224551930"></p>
<blockquote>
<p>TreeSet的定制排序（要求TreeSet的构造器参数为实现Comparator接口的对象）</p>
</blockquote>
<p>在TreeSet定制排序中，比较两个对象是否相同的标准为：<code>compare()</code>返回值为0,不再是用<code>equals()</code>判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o, Object t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User &amp;&amp; t1 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                User u1 = (User)o;</span><br><span class="line">                User u2 = (User)t1;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet(com);<span class="comment">// 定制排序</span></span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">53</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mary&quot;</span>,<span class="number">53</span>));<span class="comment">// 添加不进去，因为按照age定制排序且age相同</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224559647.png" alt="image-20211215224559647"></p>
<h3 id="4-5-Map接口及其实现类"><a href="#4-5-Map接口及其实现类" class="headerlink" title="4.5 Map接口及其实现类"></a>4.5 Map接口及其实现类</h3><h4 id="4-5-1-Map框架概述"><a href="#4-5-1-Map框架概述" class="headerlink" title="4.5.1 Map框架概述"></a>4.5.1 Map框架概述</h4><p>|——Map接口：双列集合，用来存储一对一对的数据。 高中讲的“函数”：y = f(x)</p>
<p>​        |——HashMap：作为Map的主要实现类。线程不安全，效率高。可以存储<code>null</code>的key和value。</p>
<p>​                |——LinkedHashMap：保证在遍历Map元素时是按照添加的顺序实现遍历。在原有的HashMap的底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类的执行效率要高于HashMap。</p>
<p>​        |——TreeMap：保证按照添加的键值对进行排序，实现排序遍历。此时考虑key的自然或定制排序。底层是<code>红黑树</code></p>
<p>​        |——Hashtable：注意t小写。Map的古老实现类。线程安全，效率低。不能存储<code>null</code>的key和value</p>
<p>​                |——Properties：常用来处理配置文件。key和value都是String类型。</p>
<blockquote>
<p>HashMap底层</p>
</blockquote>
<ul>
<li><p><code>jdk7</code>数组+链表</p>
</li>
<li><p><code>jdk8</code>数组+链表+==红黑树==</p>
</li>
</ul>
<blockquote>
<p>典型面试题</p>
</blockquote>
<ol>
<li><p>HashMap的底层实现原理</p>
</li>
<li><p>HashMap和Hashtable的异同</p>
</li>
</ol>
<h4 id="4-5-2-Map结构的理解：key和value的特点"><a href="#4-5-2-Map结构的理解：key和value的特点" class="headerlink" title="4.5.2 Map结构的理解：key和value的特点"></a>4.5.2 Map结构的理解：key和value的特点</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224608289.png" alt="image-20211215224608289"></p>
<ul>
<li><p>Map中的key：无序不可重复，使用Set存储所有的key；要求key所在类重写equals和hashCode方法。</p>
</li>
<li><p>Map中的value：无序可重复，使用Collection存储所有的value；要求key所在类重写equals方法。</p>
</li>
<li><p>一个键值对构成了一个Entry对象</p>
</li>
<li>Map中的Entry：无序不可重复，使用Set存储所有的entry</li>
</ul>
<h4 id="4-5-3-HashMap的底层实现原理"><a href="#4-5-3-HashMap的底层实现原理" class="headerlink" title="4.5.3 HashMap的底层实现原理"></a>4.5.3 HashMap的底层实现原理</h4><blockquote>
<p><code>JDK7</code>版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<p>在实例化以后，底层创建了长度是==16==的一维数组<code>Entry[] table</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能已经执行过多次put操作</span></span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure>
<p>首先，调用key1所在类的hashCode方法计算key1的哈希值，此哈希值经过某种算法后（例如取余），得到在Entry数组中的存放位置。</p>
<p>​        |——如果此位置上为空，则entry对象添加成功；情况1</p>
<p>​        |——如果此位置上不为空，意味着此位置上存在一个或多个数据（以链表形式存在），则比较key1和已经存在的数据的哈希值：</p>
<p>​                |——如果都不相同，则添加成功；情况2</p>
<p>​                |——如果与某一个数据的哈希值相同，则调用key1所在类的equals方法进行比较：</p>
<p>​                        |——如果返回false，则添加成功；情况3</p>
<p>​                        |——如果返回true，使用value1==替换==相同key的value值。</p>
<ul>
<li>对于情况2和情况3：同HashSet一样七上八下。</li>
<li>扩容：默认的扩容方式为扩容为原来容量的==2倍==（即新开辟一个原来容量2倍的数组空间），并将原有数据复制到该新数组中。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224618828.png" alt="image-20211215224618828"></p>
<blockquote>
<p><code>JDK8</code>版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<ul>
<li>底层没有创建一个长度为16的数组，并且该数组类型不是Entry了，而是Node；</li>
<li>首次调用put方法时，才创建数组。</li>
<li>底层结构新增了==红黑树==。当数组的某一个索引位置上的元素以链表形式存在的==个数大于8且当前数组的长度大于64时==，此索引位置上的所有数据改为使用红黑树存储。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224628060.png" alt="image-20211215224628060"></p>
<h4 id="4-5-4-HashMap源码分析"><a href="#4-5-4-HashMap源码分析" class="headerlink" title="4.5.4 HashMap源码分析"></a>4.5.4 HashMap源码分析</h4><blockquote>
<p><code>JDK7</code>版本</p>
</blockquote>
<p>暂略</p>
<h4 id="4-5-5-LinkedHashMap原理及使用"><a href="#4-5-5-LinkedHashMap原理及使用" class="headerlink" title="4.5.5 LinkedHashMap原理及使用"></a>4.5.5 LinkedHashMap原理及使用</h4><h4 id="4-5-6-Hashtable原理及使用"><a href="#4-5-6-Hashtable原理及使用" class="headerlink" title="4.5.6 Hashtable原理及使用"></a>4.5.6 Hashtable原理及使用</h4><h4 id="4-5-7-Properties原理及使用"><a href="#4-5-7-Properties原理及使用" class="headerlink" title="4.5.7 Properties原理及使用"></a>4.5.7 Properties原理及使用</h4><h3 id="4-6-Collections工具类"><a href="#4-6-Collections工具类" class="headerlink" title="4.6 Collections工具类"></a>4.6 Collections工具类</h3><h4 id="4-6-1-介绍"><a href="#4-6-1-介绍" class="headerlink" title="4.6.1 介绍"></a>4.6.1 介绍</h4><p>Collections 是一个操作 Set、List 和 Map 等集合的工具类。</p>
<p>Collections 中提供了一系列<strong>静态的方法</strong>对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<h4 id="4-6-2-常用方法"><a href="#4-6-2-常用方法" class="headerlink" title="4.6.2 常用方法"></a>4.6.2 常用方法</h4><h5 id="①-排序"><a href="#①-排序" class="headerlink" title="① 排序"></a>① 排序</h5><ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List, Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List, int i, int j)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    System.out.println(list); <span class="comment">// [123, 43, 0, -97, 765]</span></span><br><span class="line">    <span class="comment">// 倒序处理</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    System.out.println(list); <span class="comment">// [765, -97, 0, 43, 123]</span></span><br><span class="line">    <span class="comment">// 升序排序</span></span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list); <span class="comment">// [-97, 0, 43, 123, 765]</span></span><br><span class="line">    <span class="comment">// 定制排序</span></span><br><span class="line">    Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="comment">// 按照降序排序</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -Integer.compare(o1, o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(list); <span class="comment">// [765, 123, 43, 0, -97]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-查找和替换"><a href="#②-查找和替换" class="headerlink" title="② 查找和替换"></a>② 查找和替换</h5><ul>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection, Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection, Comparator)</code></li>
<li><code>int frequency(Collection, Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest, List src)</code>：将src中的内容复制到dest中 </li>
<li><code>boolean replaceAll(List list, Object oldVal, Object newVal)</code>：使用新值替换List 对象的所有旧值</li>
</ul>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    <span class="comment">// 错误的写法：Source does not fit in dest</span></span><br><span class="line">    <span class="comment">// List&lt;Integer&gt; dest = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// Collections.copy(dest, list);</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; dest = Arrays.asList(<span class="keyword">new</span> Integer[list.size()]);</span><br><span class="line">    System.out.println(dest.size()); <span class="comment">// 5</span></span><br><span class="line">    Collections.copy(dest, list);</span><br><span class="line">    System.out.println(dest); <span class="comment">// [123, 43, 0, -97, 765]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="③-同步控制"><a href="#③-同步控制" class="headerlink" title="③ 同步控制"></a>③ 同步控制</h5><p>Collections 类中提供了多个 <code>synchronizedXxx()</code> 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    <span class="comment">// 返回一个线程安全的list1</span></span><br><span class="line">    List&lt;Integer&gt; list1 = Collections.synchronizedList(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-泛型"><a href="#5-泛型" class="headerlink" title="5 泛型"></a>5 泛型</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1 概念"></a>5.1 概念</h3><h4 id="5-1-1-泛型的设计背景"><a href="#5-1-1-泛型的设计背景" class="headerlink" title="5.1.1 泛型的设计背景"></a>5.1.1 泛型的设计背景</h4><p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候<strong>除了元素的类型不缺定</strong>，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。<code>Collection&lt;E&gt;</code>，<code>List&lt;E&gt;</code>，<code>ArrayList&lt;E&gt;</code> 这个`<E>就是类型参数，即泛型。</p>
<h4 id="5-1-2-泛型的概念"><a href="#5-1-2-泛型的概念" class="headerlink" title="5.1.2 泛型的概念"></a>5.1.2 泛型的概念</h4><ul>
<li>泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li>
<li>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：<code>List&lt;String&gt;</code>，这表明该List只能保存字符串类型的对象。</li>
<li>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</li>
</ul>
<h4 id="5-1-3-需要泛型的理由"><a href="#5-1-3-需要泛型的理由" class="headerlink" title="5.1.3 需要泛型的理由"></a>5.1.3 需要泛型的理由</h4><ul>
<li>为什么要有泛型呢，直接Object不是也可以存储数据吗？<ul>
<li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li>
<li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220331163204003.png" alt="image-20220331163204003"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220331163213755.png" alt="image-20220331163213755"></p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生<code>ClassCastException</code>异常。同时，代码更加简洁、健壮。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 集合中使用泛型之前的情况</span></span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="comment">// 存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">12</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    list.add(<span class="number">100</span>);</span><br><span class="line">    list.add(<span class="number">56</span>);</span><br><span class="line">    <span class="comment">// 问题1: 类型不安全</span></span><br><span class="line">    list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object score:list)&#123;</span><br><span class="line">        <span class="comment">// 问题2: 强制转换时，可能出现ClassCastException</span></span><br><span class="line">        <span class="keyword">int</span> stuScore = (<span class="keyword">int</span>) score;</span><br><span class="line">        System.out.println(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-集合中使用泛型"><a href="#5-2-集合中使用泛型" class="headerlink" title="5.2 集合中使用泛型"></a>5.2 集合中使用泛型</h3><p>以ArrayList和HashMap为例</p>
<h4 id="5-2-1-ArrayList"><a href="#5-2-1-ArrayList" class="headerlink" title="5.2.1 ArrayList"></a>5.2.1 ArrayList</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在集合中使用泛型</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">// 存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">12</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    list.add(<span class="number">100</span>);</span><br><span class="line">    list.add(<span class="number">56</span>);</span><br><span class="line">    <span class="comment">// 编译时就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式一：增强for</span></span><br><span class="line">    <span class="keyword">for</span>(Integer score:list)&#123;</span><br><span class="line">        <span class="comment">// 避免了强转操作</span></span><br><span class="line">        <span class="keyword">int</span> stuScore = score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式二：迭代器</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-HashMap"><a href="#5-2-2-HashMap" class="headerlink" title="5.2.2 HashMap"></a>5.2.2 HashMap</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>, <span class="number">97</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>, <span class="number">100</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Hongyi&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="comment">// map.put(12, 12);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        Integer value = entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">        <span class="comment">// Tom----97</span></span><br><span class="line">        <span class="comment">// Jack----100</span></span><br><span class="line">        <span class="comment">// Hongyi----100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-3-总结"><a href="#5-2-3-总结" class="headerlink" title="5.2.3 总结"></a>5.2.3 总结</h4><ul>
<li><p>集合接口和集合类在<code>jdk5.0</code>时都修改为带泛型的结构</p>
</li>
<li><p>在实例化集合类时，可以指定具体的泛型类型</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（例如方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型</p>
<ul>
<li>例如<code>add(E e)</code> —&gt;实例化以后： <code>add(Integer e)</code></li>
</ul>
</li>
<li><p>注意：泛型的类型必须是<strong>类</strong>，不能是基本数据类型</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;<span class="keyword">int</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 错误！</span></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 正确！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果实例化时没有指定泛型，默认类型为<code>Object</code>类型</p>
</li>
</ul>
<h3 id="5-3-自定义泛型结构"><a href="#5-3-自定义泛型结构" class="headerlink" title="5.3 自定义泛型结构"></a>5.3 自定义泛型结构</h3><h4 id="5-3-1-自定义泛型类和接口"><a href="#5-3-1-自定义泛型类和接口" class="headerlink" title="5.3.1 自定义泛型类和接口"></a>5.3.1 自定义泛型类和接口</h4><ul>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：<code>&lt;E1,E2,E3&gt;</code></p>
<ul>
<li><p>例如Map的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>泛型类的构造器如下：<code>public GenericClass()&#123;&#125;</code>。而下面是错误的：<code>public GenericClass&lt;E&gt;()&#123;&#125;</code></p>
</li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p>
</li>
<li><p>泛型不同的引用不能相互赋值。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的做法是错误的</span></span><br><span class="line">ArrayList&lt;String&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">list1 = list2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。<strong>经验：泛型要使用一路都用。要不用，一路都不要用。</strong></p>
</li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p>
</li>
<li><p>jdk1.7，泛型的简化操作：<code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</code>（类型推断）</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用<strong>包装类</strong>替换。</p>
</li>
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在<strong>静态方法中不能使用类的泛型</strong>。</p>
</li>
<li><p>异常类不能是泛型的。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型:</p>
<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
<li>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>自定义泛型类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOrderT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderT</span><span class="params">(T orderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型，</span></span><br><span class="line">    <span class="comment">// 因为静态方法的使用早于实例对象的创建</span></span><br><span class="line">    <span class="comment">// 而此时泛型还尚未确定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 报错</span></span><br><span class="line">        <span class="comment">// System.out.println(orderT);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个子类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder</span> <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">Integer</span>&gt;</span>&#123; <span class="comment">// 不再是一个泛型类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubOrder1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt;</span>&#123; <span class="comment">// 仍然是一个泛型类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果定义了泛型类，实例化没有指定类的泛型，则认为泛型类型为Object</span></span><br><span class="line">    <span class="comment">// 要求：如果定义了类是带泛型的，建议在实例化时要指明类的泛型</span></span><br><span class="line">    <span class="comment">// 下面的做法不建议</span></span><br><span class="line">    Order order = <span class="keyword">new</span> Order();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    order.setOrderT(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 建议使用泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> Order&lt;&gt;(<span class="string">&quot;phone&quot;</span>, <span class="number">1001</span>, <span class="string">&quot;这是一部手机&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;又被修改了&quot;</span>);</span><br><span class="line">    System.out.println(order1); <span class="comment">// Order&#123;orderName=&#x27;phone&#x27;, orderId=1001, orderT=又被修改了&#125;</span></span><br><span class="line"></span><br><span class="line">    SubOrder sub1 = <span class="keyword">new</span> SubOrder();</span><br><span class="line">    sub1.setOrderT(<span class="number">123</span>);</span><br><span class="line">    System.out.println(sub1); <span class="comment">// Order&#123;orderName=&#x27;null&#x27;, orderId=0, orderT=123&#125;</span></span><br><span class="line"></span><br><span class="line">    SubOrder1&lt;String&gt; sub2 = <span class="keyword">new</span> SubOrder1&lt;&gt;();</span><br><span class="line">    sub2.setOrderT(<span class="string">&quot;Sub2...&quot;</span>);</span><br><span class="line">    System.out.println(sub2); <span class="comment">// Order&#123;orderName=&#x27;null&#x27;, orderId=0, orderT=Sub2...&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-3-2-自定义泛型方法"><a href="#5-3-2-自定义泛型方法" class="headerlink" title="5.3.2 自定义泛型方法"></a>5.3.2 自定义泛型方法</h4><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">泛型方法的格式：</span><br><span class="line">[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T orderT;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 泛型方法：在方法中出现了泛型的结构，泛型的参数与类的参数没有任何关系</span></span><br><span class="line">    <span class="comment">// 泛型方法所属的类是否是泛型类都没有关系</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(E e : arr) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">    System.out.println(list); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-泛型在继承上的体现"><a href="#5-4-泛型在继承上的体现" class="headerlink" title="5.4 泛型在继承上的体现"></a>5.4 泛型在继承上的体现</h3><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，<code>G&lt;B&gt;</code>并不是<code>G&lt;A&gt;</code>的子类型！</p>
<p>比如：String是Object的子类，但是<code>List&lt;String&gt;</code>并不是<code>List&lt;Object&gt;</code>的子类。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="keyword">null</span>;</span><br><span class="line">    String[] arr2 = <span class="keyword">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 编译错误，list1和list2的类型不具有子父类关系</span></span><br><span class="line">    <span class="comment">// list1 = list2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-5-通配符"><a href="#5-5-通配符" class="headerlink" title="5.5 通配符"></a>5.5 通配符</h3><ul>
<li>使用类型通配符：<code>?</code><ul>
<li>比如：<code>List&lt;?&gt;</code> ，<code>Map&lt;?,?&gt;</code>，<code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、<code>List&lt;Object&gt;</code>等各种泛型List的<strong>父类</strong>。</li>
</ul>
</li>
<li>读取<code>List&lt;?&gt;</code>的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object。</li>
<li>写入list中的元素时，不行。因为我们不知道<code>?</code>的元素类型，我们不能向其中添加对象。唯一的例外是null，它是所有类型的成员。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list1.add(<span class="string">&quot;ABC&quot;</span>);</span><br><span class="line">    list1.add(<span class="number">123</span>);</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时list可看作是所有List泛型实现类的父类</span></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line"></span><br><span class="line">    print(list1);</span><br><span class="line">    <span class="comment">// ABC</span></span><br><span class="line">    <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">// 此时不能向list中添加数据</span></span><br><span class="line">    <span class="comment">// 除了null</span></span><br><span class="line">    <span class="comment">// list.add(&quot;DD&quot;);</span></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">    Object o = list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o); <span class="comment">// AA</span></span><br><span class="line">    System.out.println(list); <span class="comment">// [AA, BB, CC, null]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Object next = iterator.next();</span><br><span class="line">        System.out.println(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-IO流"><a href="#6-IO流" class="headerlink" title="6 IO流"></a>6 IO流</h2><h3 id="6-1-File类"><a href="#6-1-File类" class="headerlink" title="6.1 File类"></a>6.1 File类</h3><h4 id="6-1-1-介绍"><a href="#6-1-1-介绍" class="headerlink" title="6.1.1 介绍"></a>6.1.1 介绍</h4><ul>
<li><code>java.io.File</code>类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<h4 id="6-1-2-常用构造器"><a href="#6-1-2-常用构造器" class="headerlink" title="6.1.2 常用构造器"></a>6.1.2 常用构造器</h4><ul>
<li><code>public File(String pathname)</code>：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性<code>user.dir</code>中存储。</li>
<li><code>public File(String parent, String child)</code>：以parent为父路径，child为子路径创建File对象。</li>
<li><code>public File(File parent, String child)</code>：根据一个父File对象和子文件路径创建File对象</li>
</ul>
<blockquote>
<p>路径分隔符</p>
</blockquote>
<ul>
<li><p>路径中的每级目录之间用一个路径分隔符隔开。</p>
</li>
<li><p>路径分隔符和系统有关：</p>
<ul>
<li>windows和DOS系统默认使用<code>\</code>来表示</li>
<li>UNIX和URL使用<code>/</code>来表示</li>
</ul>
</li>
<li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。</p>
</li>
<li><p>为了解决这个隐患，File类提供了一个常量：<code>public static final String separator</code>。根据操作系统，动态的提供分隔符。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\atguigu\\info.txt&quot;</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;atguigu&quot;</span> + File.separator + <span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(<span class="string">&quot;d:/atguigu&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;./hello.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\develop\\study\\&quot;</span> +</span><br><span class="line">            <span class="string">&quot;backend_study\\javase\\src\\main\\resource\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1); <span class="comment">// .\hello.txt</span></span><br><span class="line">    System.out.println(file2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-3-常用方法"><a href="#6-1-3-常用方法" class="headerlink" title="6.1.3 常用方法"></a>6.1.3 常用方法</h4><h5 id="①-获取功能"><a href="#①-获取功能" class="headerlink" title="① 获取功能"></a>① 获取功能</h5><ul>
<li><code>public String getAbsolutePath()</code>：获取绝对路径</li>
<li><code>public String getPath()</code> ：获取路径</li>
<li><code>public String getName()</code> ：获取名称</li>
<li><code>public String getParent()</code>：获取上层文件目录路径。若无，返回null</li>
<li><code>public long length()</code> ：获取文件长度（即：字节数）。不能获取目录的长度。 </li>
<li><code>public long lastModified()</code> ：获取最后一次的修改时间，毫秒值</li>
<li><code>public String[] list()</code> ：获取指定目录下的所有文件或者文件目录的<strong>名称数组</strong></li>
<li><code>public File[] listFiles()</code> ：获取指定目录下的所有文件或者文件目录的<strong>File数组</strong></li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\develop\\study\\&quot;</span> +</span><br><span class="line">            <span class="string">&quot;backend_study\\javase\\src\\main\\resources\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1.getAbsolutePath()); <span class="comment">// E:\develop\study\backend_study\javase\hello.txt</span></span><br><span class="line">    System.out.println(file1.getPath()); <span class="comment">// hello.txt</span></span><br><span class="line">    System.out.println(file1.getName()); <span class="comment">// hello.txt</span></span><br><span class="line">    System.out.println(file1.getParent()); <span class="comment">// null</span></span><br><span class="line">    System.out.println(file1.length()); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(file1.lastModified()); <span class="comment">// 1648980340094</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;E:\\develop\\study\\backend_study\\javase&quot;</span>);</span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span>(String l : list) &#123;</span><br><span class="line">        System.out.println(l);</span><br><span class="line">        <span class="comment">// .idea</span></span><br><span class="line">        <span class="comment">// hello.txt</span></span><br><span class="line">        <span class="comment">// pom.xml</span></span><br><span class="line">        <span class="comment">// src</span></span><br><span class="line">        <span class="comment">// target</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f : files) &#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// E:\develop\study\backend_study\javase\.idea</span></span><br><span class="line">        <span class="comment">// E:\develop\study\backend_study\javase\hello.txt</span></span><br><span class="line">        <span class="comment">// E:\develop\study\backend_study\javase\pom.xml</span></span><br><span class="line">        <span class="comment">// E:\develop\study\backend_study\javase\src</span></span><br><span class="line">        <span class="comment">// E:\develop\study\backend_study\javase\target</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="②-重命名功能"><a href="#②-重命名功能" class="headerlink" title="② 重命名功能"></a>② 重命名功能</h5><ul>
<li><code>public boolean renameTo(File dest)</code>:把文件重命名为指定的文件路径</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要file1在硬盘中存在，且file2不能在硬盘中存在</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">&quot;E:\\develop\\study\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> b = file1.renameTo(file2);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后，当前路径的<code>hello.txt</code>已经转移至<code>E:\develop\study\</code>，且重命名为<code>hi.txt</code></p>
<h5 id="③-判断功能"><a href="#③-判断功能" class="headerlink" title="③ 判断功能"></a>③ 判断功能</h5><ul>
<li><code>public boolean isDirectory()</code>：判断是否是文件目录</li>
<li><code>public boolean isFile()</code> ：判断是否是文件</li>
<li><code>public boolean exists()</code> ：判断是否存在</li>
<li><code>public boolean canRead()</code> ：判断是否可读</li>
<li><code>public boolean canWrite()</code> ：判断是否可写</li>
<li><code>public boolean isHidden()</code> ：判断是否隐藏</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1.isDirectory());</span><br><span class="line">    System.out.println(file1.isFile());</span><br><span class="line">    System.out.println(file1.exists());</span><br><span class="line">    System.out.println(file1.canRead());</span><br><span class="line">    System.out.println(file1.canWrite());</span><br><span class="line">    System.out.println(file1.isHidden());</span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// true</span></span><br><span class="line">    <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="④-创建功能"><a href="#④-创建功能" class="headerlink" title="④ 创建功能"></a>④ 创建功能</h5><ul>
<li><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false</li>
<li><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li>
<li><code>public boolean mkdirs()</code> ：创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
<h5 id="⑤-删除功能"><a href="#⑤-删除功能" class="headerlink" title="⑤ 删除功能"></a>⑤ 删除功能</h5><ul>
<li><code>public boolean delete()</code>：删除文件或者文件夹<ul>
<li>删除注意事项：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</li>
</ul>
</li>
</ul>
<h3 id="6-2-IO流原理及流的分类"><a href="#6-2-IO流原理及流的分类" class="headerlink" title="6.2 IO流原理及流的分类"></a>6.2 IO流原理及流的分类</h3><h4 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h4><p>I/O是Input/Output的缩写， I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等。</p>
<p>Java程序中，对于数据的输入/输出操作以“流(stream)” 的方式进行。</p>
<p><code>java.io</code>包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</p>
<ul>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。硬盘 —&gt; 内存</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。 内存 —&gt; 硬盘</li>
</ul>
<p>应该在<strong>程序（内存）的角度看IO流的方向</strong>。</p>
<h4 id="6-2-2-流的分类"><a href="#6-2-2-流的分类" class="headerlink" title="6.2.2 流的分类"></a>6.2.2 流的分类</h4><ul>
<li>按操作数据单位不同分为：字节流(<strong>8 bit</strong>)，字符流(<strong>16 bit</strong>)</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流（包在节点流外层）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>抽象基类</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody>
<tr>
<td>输入流</td>
<td><code>InputStream</code></td>
<td><code>Reader</code></td>
</tr>
<tr>
<td>输出流</td>
<td><code>OutputStream</code></td>
<td><code>Writer</code></td>
</tr>
</tbody>
</table>
</div>
<p>Java的IO流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的。</p>
<p>由这四个类派生出来的子类名称都是以其父类名作为子类名<strong>后缀</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220404145113587.png" alt="image-20220404145113587"></p>
<h4 id="6-2-3-流的体系"><a href="#6-2-3-流的体系" class="headerlink" title="6.2.3 流的体系"></a>6.2.3 流的体系</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220404145208175.png" alt="image-20220404145208175"></p>
<p>表格中第二行为节点流（或称为文件流），剩余的都为处理流。</p>
<h4 id="6-2-4-节点流和处理流"><a href="#6-2-4-节点流和处理流" class="headerlink" title="6.2.4 节点流和处理流"></a>6.2.4 节点流和处理流</h4><ul>
<li>节点流：直接从数据源或目的地读写数据，或称为文件流</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220404145632710.png" alt="image-20220404145632710"></p>
<ul>
<li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220404145642301.png" alt="image-20220404145642301"></p>
<h4 id="6-2-5-InputStream-amp-Reader"><a href="#6-2-5-InputStream-amp-Reader" class="headerlink" title="6.2.5 InputStream &amp; Reader"></a>6.2.5 InputStream &amp; Reader</h4><p>InputStream（典型实现：FileInputStream） 和 Reader（典型实现：FileReader） 是所有输入流的基类。</p>
<p>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该<strong>显式关闭文件 IO 资源</strong>。</p>
<h4 id="6-2-6-OutputStream-amp-Writer"><a href="#6-2-6-OutputStream-amp-Writer" class="headerlink" title="6.2.6 OutputStream &amp; Writer"></a>6.2.6 OutputStream &amp; Writer</h4><p>OutputStream 和 Writer 也非常相似。</p>
<p>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数。</p>
<p>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputStream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter。</p>
<h3 id="6-3-节点流（文件流）"><a href="#6-3-节点流（文件流）" class="headerlink" title="6.3 节点流（文件流）"></a>6.3 节点流（文件流）</h3><h4 id="6-3-1-字符流读取文件"><a href="#6-3-1-字符流读取文件" class="headerlink" title="6.3.1 字符流读取文件"></a>6.3.1 字符流读取文件</h4><ul>
<li><p>Reader：输入字符流</p>
<ul>
<li><p><code>int read()</code>：读取<strong>单个字符</strong>。作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2个字节的Unicode码），如果已到达流的末尾，则返回 -1 </p>
</li>
<li><p><code>int read(char[] cbuf)</code>：将字符读入数组。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 </p>
</li>
<li><p><code>int read(char[] cbuf,int off,int len)</code>：将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回 -1。否则返回本次读取的字符数。 </p>
</li>
<li><p><code>public void close() throws IOException</code>：关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：在项目下创建一个文件<code>hello.txt</code>，文件内容为<code>hello world</code>，以字符流<code>FileReader</code>读取该文件到内存中并输出到控制台中显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            <span class="comment">// 2.提供具体的流</span></span><br><span class="line">            fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">            <span class="comment">// 3.数据的读入</span></span><br><span class="line">            <span class="comment">// 方式一：</span></span><br><span class="line"><span class="comment">//        int data = fr.read();</span></span><br><span class="line"><span class="comment">//        while (data != -1) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.print((char) data);</span></span><br><span class="line"><span class="comment">//            // 再次读取下一个字符</span></span><br><span class="line"><span class="comment">//            data = fr.read();</span></span><br><span class="line"><span class="comment">//        &#125; // hello world</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式二：语法上的修改</span></span><br><span class="line">            <span class="keyword">int</span> data;</span><br><span class="line">            <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 4.关闭流</span></span><br><span class="line">                    fr.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>为了保证流资源一定可以被释放掉，需要使用tcf处理</li>
<li>读入的文件一定要存在，否则会报<code>FileNotFoundException</code></li>
</ul>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对read()操作升级，使用read的重载方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1.File类的实例化</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">// 3.读入的操作</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 方式一：</span></span><br><span class="line">            <span class="comment">// 注意这里边界值是len</span></span><br><span class="line"><span class="comment">//          for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//          	System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方式二：</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4.关闭流</span></span><br><span class="line">                fr.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-3-2-字符流写入文件"><a href="#6-3-2-字符流写入文件" class="headerlink" title="6.3.2 字符流写入文件"></a>6.3.2 字符流写入文件</h4><ul>
<li><p>Writer：输出字符流</p>
<ul>
<li><p><code>void write(int c)</code>：写入单个字符。要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入0 到 65535 之间的Unicode码。 </p>
</li>
<li><p><code>void write(char[] cbuf)</code>：写入字符数组。 </p>
</li>
<li><p><code>void write(char[] cbuf,int off,int len)</code>：写入字符数组的某一部分。从off开始，写入len个字符</p>
</li>
<li><p><code>void write(String str)</code>：写入字符串。 </p>
</li>
<li><p><code>void write(String str,int off,int len)</code>：写入字符串的某一部分。 </p>
</li>
<li><p><code>void flush()</code>：刷新该流的缓冲，则立即将它们写入预期目标。</p>
</li>
<li><p><code>public void close() throws IOException</code>：关闭此输出流并释放与该流关联的所有系统资源</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：从内存中写出数据到硬盘里的文件里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.写出操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;You need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4.关闭流</span></span><br><span class="line">                fw.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>输出的文件对应的file可以不存在<ul>
<li>不存在的话会自动创建文件。</li>
<li>如果存在，且流使用的构造器是：<code>FileWriter(file, false)</code>或<code>FileWriter(file)</code>，则对原有文件进行覆盖</li>
<li>如果存在，且流使用的构造器是：<code>FileWriter(file, true)</code>，则对原有文件进行内容追加</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>需求：读取<code>hello.txt</code>的内容，并写入到<code>hello1.txt</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileReader fr = <span class="keyword">null</span>;</span><br><span class="line">    FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File src = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        File dest = <span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fr = <span class="keyword">new</span> FileReader(src);</span><br><span class="line">        fw = <span class="keyword">new</span> FileWriter(dest);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">// 记录每次读入到数组中的数据个数</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次写入len个字符</span></span><br><span class="line">            fw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fw != <span class="keyword">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fr != <span class="keyword">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点</p>
</blockquote>
<p>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt，.java，.c，.cpp 等语言的源代码。尤其注意.doc，excel，ppt这些不是文本文件。</p>
<h4 id="6-3-3-字节流读取和写入文件"><a href="#6-3-3-字节流读取和写入文件" class="headerlink" title="6.3.3 字节流读取和写入文件"></a>6.3.3 字节流读取和写入文件</h4><ul>
<li><p>InputStream：输入字节流</p>
<ul>
<li><p><code>int read()</code>：从输入流中读取数据的下一个字节。返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。</p>
</li>
<li><p><code>int read(byte[] b)</code>：从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数。</p>
</li>
<li><p><code>int read(byte[] b, int off, int len)</code>：将输入流中最多 len 个数据字节读入 byte 数组。尝试读取 len 个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值 -1。</p>
</li>
<li><p><code>public void close() throws IOException</code>：关闭此输入流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
</li>
<li><p>OutputStream：输出字节流</p>
<ul>
<li><p><code>void write(int b)</code>：将指定的字节写入此输出流。write 的常规协定是：向输出流写入一个字节。要写入的字节是参数 b 的八个低位。b 的 24 个高位将被忽略。 即写入0~255范围的。</p>
</li>
<li><p><code>void write(byte[] b)</code>：将 b.length 个字节从指定的 byte 数组写入此输出流。write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同。 </p>
</li>
<li><p><code>void write(byte[] b,int off,int len)</code>：将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。 </p>
</li>
<li><p><code>public void flush()throws IOException</code>：刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p>
</li>
<li><p><code>public void close() throws IOException</code>：关闭此输出流并释放与该流关联的所有系统资源。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：实现对图片的复制操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;test.png&quot;</span>);</span><br><span class="line">        File destFile = <span class="keyword">new</span> File(<span class="string">&quot;hello.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制的过程</span></span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-4-处理流"><a href="#6-4-处理流" class="headerlink" title="6.4 处理流"></a>6.4 处理流</h3><h4 id="6-4-1-缓冲流"><a href="#6-4-1-缓冲流" class="headerlink" title="6.4.1 缓冲流"></a>6.4.1 缓冲流</h4><h5 id="①-概述-2"><a href="#①-概述-2" class="headerlink" title="① 概述"></a>① 概述</h5><p>为了<strong>提高数据读写的速度</strong>，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个<strong>内部缓冲区数组</strong>，缺省使用8192个字节(8Kb)的缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓冲流要“套接”在相应的<strong>节点流</strong>之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li><code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>，处理字节</li>
<li><code>BufferedReader</code> 和 <code>BufferedWriter</code>，处理字符</li>
</ul>
<blockquote>
<p>注意点</p>
</blockquote>
<ul>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</li>
<li>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。 </li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流。</li>
<li>关闭流的顺序和打开流的顺序相反。<strong>只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</strong>。</li>
<li>flush()方法的使用：手动将buffer中内容写入文件。</li>
<li>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220408131609373.png" alt="image-20220408131609373"></p>
<h5 id="②-代码示例"><a href="#②-代码示例" class="headerlink" title="② 代码示例"></a>② 代码示例</h5><blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：利用缓冲流实现非文本文件的复制操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 实现非文本文件的复制</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;test.png&quot;</span>);</span><br><span class="line">            File destFile = <span class="keyword">new</span> File(<span class="string">&quot;test1.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 造流</span></span><br><span class="line">            <span class="comment">// 造节点流</span></span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">            FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(destFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 造缓冲流</span></span><br><span class="line">            bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">            bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 复制的过程</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            <span class="comment">// 要求：先关闭外层流，再关闭内层流</span></span><br><span class="line">            <span class="keyword">if</span> (bos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明：外层流关闭时，内层流也会自动关闭，因此可以省略下面两行</span></span><br><span class="line"><span class="comment">//        fos.close();</span></span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>需求：对一个大文件进行复制操作，实现缓冲流和节点流的读写速度对比</p>
<p>略</p>
<blockquote>
<p>代码示例3</p>
</blockquote>
<p>需求：利用缓冲流实现文本文件的复制操作</p>
<p>注意简写操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>)));</span><br><span class="line">        <span class="comment">// 复制过程</span></span><br><span class="line">        <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bw.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-转换流"><a href="#6-4-2-转换流" class="headerlink" title="6.4.2 转换流"></a>6.4.2 转换流</h4><h5 id="①-概述-3"><a href="#①-概述-3" class="headerlink" title="① 概述"></a>① 概述</h5><p>转换流提供了在字节流和字符流之间的转换。</p>
<p>Java API提供了两个转换流，两者都属于字符流：</p>
<ol>
<li><code>InputStreamReader</code>：将InputStream转换为Reader</li>
<li><code>OutputStreamWriter</code>：将Writer转换为OutputStream</li>
</ol>
<p>字节流中的数据都是字符时，转成字符流操作更高效。 很多时候我们使用转换流来处理文乱码问题。</p>
<p>实现编码和解码（字节/字节数组 —&gt; 字符数组/字符串）的功能。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220408142716586.png" alt="image-20220408142716586"></p>
<ul>
<li><p><code>InputStreamReader</code>：字符输入流</p>
<ul>
<li>实现将字节的输入流按指定字符集转换为字符的输入流。</li>
<li>需要和InputStream“套接”。</li>
<li>构造器：<ul>
<li><code>public InputStreamReader(InputStream in)</code></li>
<li><code>public InputSreamReader(InputStream in, String charsetName)</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>OutputStreamWriter</code>：字符输出流</p>
<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流。</li>
<li>需要和OutputStream“套接”。</li>
<li>构造器：<ul>
<li><code>public OutputStreamWriter(OutputStream out)</code></li>
<li><code>public OutputSreamWriter(OutputStream out, String charsetName)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="②-字符集"><a href="#②-字符集" class="headerlink" title="② 字符集"></a>② 字符集</h5><ul>
<li>编码表的由来：计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</li>
<li>常见的编码表：<ul>
<li><code>ASCII</code>：美国标准信息交换码。用一个字节的7位可以表示。</li>
<li><code>ISO8859-1</code>：拉丁码表。欧洲码表用一个字节的8位表示。</li>
<li><code>GB2312</code>：中国的中文编码表。最多两个字节编码所有字符</li>
<li><code>GBK</code>：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</li>
<li><code>Unicode</code>：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li><code>UTF-8</code>：变长的编码方式，可用1-4个字节来表示一个字符。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img12/image-20220408144654011.png" alt="image-20220408144654011"></p>
<p>面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF- 8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</p>
<p>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</p>
<ul>
<li>ANSI编码，通常指的是平台的默认编码，例如英文操作系统中是ISO-8859-1，中文系统是GBK</li>
<li>Unicode字符集只是定义了字符的集合和唯一编号，Unicode编码，则是对UTF-8、UCS-2/UTF-16等具体编码方案的统称而已，并不是具体的编码方案。</li>
</ul>
<h5 id="③-代码示例"><a href="#③-代码示例" class="headerlink" title="③ 代码示例"></a>③ 代码示例</h5><blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：用字节流（通过字符转换流转换）读取一个txt文件，将读取的内容输出到控制台上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 具体使用那个字符集，取决于要读取的文件保存时使用的字符集</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis, StandardCharsets.UTF_8);</span><br><span class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello world你好世界 // UTF-8</span><br><span class="line">hello world浣犲ソ涓栫晫 // gbk</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>需求：用字符转换流复制文本文件，并更换编码方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 造流</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)),</span><br><span class="line">            StandardCharsets.UTF_8);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">            <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;hello_gbk.txt&quot;</span>)),</span><br><span class="line">            <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制过程</span></span><br><span class="line">    <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        osw.write(cbuf, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-3-标准输入输出流"><a href="#6-4-3-标准输入输出流" class="headerlink" title="6.4.3 标准输入输出流"></a>6.4.3 标准输入输出流</h4><ul>
<li><p><code>System.in</code>和<code>System.out</code>分别代表了系统标准的输入和输出设备</p>
<ul>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li><p>System.in的类型是InputStream，字节输入流</p>
</li>
<li><p>System.out的类型是PrintStream，字节输出流，其是OutputStream的子类FilterOutputStream 的子类</p>
</li>
</ul>
</li>
<li><p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。</p>
<ul>
<li><code>public static void setIn(InputStream in)</code></li>
<li><code>public static void setOut(PrintStream out)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>需求：从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p>
<p>思路：<code>System.in（字节输入流） --&gt; 转换流 --&gt; BufferedReader的readLine()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串: &quot;</span>);</span><br><span class="line">            String data = br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String upperCase = data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-4-打印流"><a href="#6-4-4-打印流" class="headerlink" title="6.4.4 打印流"></a>6.4.4 打印流</h4><p>略</p>
<h4 id="6-4-5-数据流"><a href="#6-4-5-数据流" class="headerlink" title="6.4.5 数据流"></a>6.4.5 数据流</h4><p>略</p>
<h4 id="6-4-6-对象流"><a href="#6-4-6-对象流" class="headerlink" title="6.4.6 对象流"></a>6.4.6 对象流</h4><h5 id="①-概述-4"><a href="#①-概述-4" class="headerlink" title="① 概述"></a>① 概述</h5><p><code>ObjectInputStream</code>和<code>OjbectOutputSteam</code>：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p>
<p>序列化：用ObjectOutputStream类<strong>保存</strong>基本类型数据或对象的机制</p>
<p>反序列化：用ObjectInputStream类<strong>读取</strong>基本类型数据或对象的机制</p>
<p>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p>
<blockquote>
<p>对象的序列化</p>
</blockquote>
<ul>
<li>对象序列化机制允许把内存中的Java对象转换成<strong>平台无关的二进制流</strong>，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li>
<li>序列化的好处在于可将任何实现了<code>Serializable</code>接口的对象转化为字节数据，使其在保存和传输时可被还原。</li>
<li>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是JavaEE 平台的基础。</li>
<li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出<code>NotSerializableException</code>异常</p>
<ul>
<li><code>Serializable</code></li>
<li><code>Externalizable</code></li>
</ul>
</li>
<li><p>凡是实现Serializable接口的类都有一个表示<strong>序列化版本标识符</strong>的静态变量：</p>
<ul>
<li><code>private static final long serialVersionUID;</code></li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行<strong>版本控制</strong>，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID 可能发生变化。故建议显式声明。</li>
</ul>
</li>
<li>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</li>
</ul>
<h5 id="②-代码示例-1"><a href="#②-代码示例-1" class="headerlink" title="② 代码示例"></a>② 代码示例</h5><blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：</p>
<ul>
<li>序列化：将内存中的java对象保存到磁盘中</li>
<li>反序列化：将磁盘中的Java对象读入到内存中</li>
<li>注意写出一次，操作flush()一次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>; <span class="comment">// 字节流</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.txt&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;我爱北京天安门&quot;</span>)); <span class="comment">// String实现了序列化接口</span></span><br><span class="line">        oos.flush(); <span class="comment">// 刷新</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.txt&quot;</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str); <span class="comment">// 我爱北京天安门</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>需求：自定义类的序列化和反序列化</p>
<ul>
<li>Person类：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// 实现序列化接口</span></span><br><span class="line">    <span class="comment">// 自定义序列化版本标识符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">12345678910L</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectOutputStream oos = <span class="keyword">null</span>; <span class="comment">// 字节流</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;Mark&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        Object o = ois.readObject();</span><br><span class="line">        String str = (String) o;</span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        Person p = (Person) ois.readObject();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我爱北京天安门</span><br><span class="line">Person(name=Mark, age=24)</span><br></pre></td></tr></table></figure>
<p>注意：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类也不能序列化。</p>
<h4 id="6-4-7-随机存取文件流"><a href="#6-4-7-随机存取文件流" class="headerlink" title="6.4.7 随机存取文件流"></a>6.4.7 随机存取文件流</h4><h5 id="①-概述-5"><a href="#①-概述-5" class="headerlink" title="① 概述"></a>① 概述</h5><ul>
<li>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着<strong>这个类既可以读也可以写</strong>。</li>
<li><p>RandomAccessFile 类支持 “随机访问” 的方式，程序可以<strong>直接跳到文件的任意地方</strong>来读、写文件</p>
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile 类对象可以自由移动记录指针。</p>
<ul>
<li><code>long getFilePointer()</code>：获取文件记录指针的当前位置</li>
<li><code>void seek(long pos)</code>：将文件记录指针定位到 pos 位置</li>
</ul>
</li>
<li><p>构造器：</p>
<ul>
<li><code>public RandomAccessFile(File file, String mode)</code></li>
<li><code>public RandomAccessFile(String name, String mode)</code></li>
<li>创建 RandomAccessFile 类实例需要指定一个 <code>mode</code> 参数，该参数指定 RandomAccessFile 的访问模式：<ul>
<li><code>r</code>: 以只读方式打开</li>
<li><code>rw</code>：打开以便读取和写入</li>
<li><code>rwd</code>:打开以便读取和写入；同步文件内容的更新</li>
<li><code>rws</code>:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读r，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。 </li>
<li>如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建，且默认情况下对原内容进行覆盖操作。</li>
</ul>
</li>
<li>我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能，有兴趣的朋友们可以自己实现下。</li>
</ul>
<h5 id="②-代码示例-2"><a href="#②-代码示例-2" class="headerlink" title="② 代码示例"></a>② 代码示例</h5><blockquote>
<p>代码示例1</p>
</blockquote>
<p>需求：复制图片</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RandomAccessFile raf1 = <span class="keyword">null</span>;</span><br><span class="line">    RandomAccessFile raf2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 字节输入流</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;test.png&quot;</span>), <span class="string">&quot;r&quot;</span>);</span><br><span class="line">        <span class="comment">// 字节输入输出流，作为输出流使用</span></span><br><span class="line">        raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;test2.png&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            raf2.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2</p>
</blockquote>
<p>需求：给定一个字符文件，内容为<code>abcdefghijklmn</code>，要求在<code>abc</code>后插入（且不覆盖后面的字符）字符<code>xyz</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RandomAccessFile raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    <span class="comment">// 将指针指向第三个位置，即第四个字符d</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 保存指针后的所有数据到sb中</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder((<span class="keyword">int</span>) <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        sb.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调回指针</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">    <span class="comment">// 将sb的数据写入到文件</span></span><br><span class="line">    raf1.write(sb.toString().getBytes());</span><br><span class="line">    raf1.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-NIO"><a href="#6-5-NIO" class="headerlink" title="6.5 NIO"></a>6.5 NIO</h3><p>略，详见<code>实用技术-Netty学习笔记</code></p>
<h2 id="7-网络编程"><a href="#7-网络编程" class="headerlink" title="7 网络编程"></a>7 网络编程</h2><h2 id="8-反射机制"><a href="#8-反射机制" class="headerlink" title="8 反射机制"></a>8 反射机制</h2><h3 id="8-1-反射机制概述"><a href="#8-1-反射机制概述" class="headerlink" title="8.1 反射机制概述"></a>8.1 反射机制概述</h3><h4 id="8-1-1-概述"><a href="#8-1-1-概述" class="headerlink" title="8.1.1 概述"></a>8.1.1 概述</h4><ul>
<li><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期间借助于<code>Reflection API</code>取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
</li>
<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224638775.png" alt="image-20211215224638775"></p>
</li>
</ul>
<h4 id="8-1-2-与反射有关的API"><a href="#8-1-2-与反射有关的API" class="headerlink" title="8.1.2 与反射有关的API"></a>8.1.2 与反射有关的API</h4><ul>
<li><p><code>java.lang.Class</code>:代表一个类 </p>
</li>
<li><p><code>java.lang.reflect.Method</code>:代表类的方法</p>
</li>
<li><p><code>java.lang.reflect.Field</code>:代表类的成员变量</p>
</li>
<li><p><code>java.lang.reflect.Constructor</code>:代表类的构造器</p>
</li>
</ul>
<h4 id="8-1-3-利用反射之前对Person类的操作"><a href="#8-1-3-利用反射之前对Person类的操作" class="headerlink" title="8.1.3 利用反射之前对Person类的操作"></a>8.1.3 利用反射之前对Person类的操作</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;<span class="comment">// 公共属性</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是&quot;</span>+nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//公共构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射之前对于Person类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Person类的对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过对象，调用其内部的属性和方法</span></span><br><span class="line">    p1.setAge(<span class="number">24</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    p1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Person类外部，不可以通过对象调用其内部私有结构</span></span><br><span class="line">    <span class="comment">// 例如：name属性，showNation私有方法，私有构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-4-利用反射对Person类操作"><a href="#8-1-4-利用反射对Person类操作" class="headerlink" title="8.1.4 利用反射对Person类操作"></a>8.1.4 利用反射对Person类操作</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射对Person类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 1.通过反射创建Person类的对象</span></span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    Object obj = cons.newInstance(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    Person p = (Person)obj;</span><br><span class="line">    System.out.println(p);</span><br><span class="line">    <span class="comment">// 2.通过反射调用对象指定的属性和方法</span></span><br><span class="line">    <span class="comment">// 调用属性</span></span><br><span class="line">    Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(p,<span class="number">10</span>);</span><br><span class="line">    System.out.println(p);</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射，可以调用Person类的私有结构，例如私有属性，方法，构造器等</span></span><br><span class="line">    <span class="comment">// 调用私有构造器</span></span><br><span class="line">    Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1,<span class="string">&quot;HanMeimei&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有方法</span></span><br><span class="line">    Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String nation = (String)showNation.invoke(p1,<span class="string">&quot;中国&quot;</span>);<span class="comment">// 相当于String nation = p1.showNation(&quot;中国&quot;);</span></span><br><span class="line">    System.out.println(nation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-5-如何看待反射和封装性"><a href="#8-1-5-如何看待反射和封装性" class="headerlink" title="8.1.5 如何看待反射和封装性"></a>8.1.5 如何看待反射和封装性</h4><ul>
<li>通过直接new对象，或反射的方式都可以调用公共的结构，那么开发中到底用哪个？</li>
</ul>
<p>回答：建议直接用new的方法。</p>
<ul>
<li>反射机制与面向对象的封装性是不是矛盾的？</li>
</ul>
<p>回答：不矛盾。</p>
<h3 id="8-2-理解Class类并获取Class实例"><a href="#8-2-理解Class类并获取Class实例" class="headerlink" title="8.2 理解Class类并获取Class实例 *"></a>8.2 理解Class类并获取Class实例 *</h3><h4 id="8-2-1-Class类的理解"><a href="#8-2-1-Class类的理解" class="headerlink" title="8.2.1 Class类的理解"></a>8.2.1 Class类的理解</h4><p>1.类的加载过程：</p>
<p>程序在<code>javac.exe</code>命令后，会生成一个或多个字节码文件(<code>.class</code>结尾)，接着使用<code>java.exe</code>命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为==类的加载==。加载到内存中的类，就成为==运行时类==，此运行时类就作为Class类的一个实例对象。</p>
<p>2.换句话说，Class的实例就对应一个运行时类。</p>
<p>3.加载到内存中的运行时类，会缓存一定时间，在此时间之内，我们可以利用不同的方式来获取此运行时类。该运行时类在内存中只有一个。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224649657.png" alt="image-20211215224649657"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object.class;</span><br><span class="line">Class c2 = Comparable.class;</span><br><span class="line">Class c3 = String[].class;</span><br><span class="line">Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">Class c5 = ElementType.class;</span><br><span class="line">Class c6 = Override.class;</span><br><span class="line">Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c10 = a.getClass();</span><br><span class="line">Class c11 = b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">System.out.println(c10 == c11);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-获取Class实例的四种方法"><a href="#8-2-2-获取Class实例的四种方法" class="headerlink" title="8.2.2 获取Class实例的四种方法"></a>8.2.2 获取Class实例的四种方法</h4><ul>
<li>调用运行时类的属性：<code>.class</code></li>
<li>通过运行时类的对象，调用<code>getClass()</code>方法</li>
<li>调用Class的静态方法：<code>forName(String classPath)</code>用的最多</li>
<li>使用类加载器：<code>ClassLoader</code> 了解，用得少</li>
</ul>
<blockquote>
<p>代码实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class实例的四种方式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 方式1：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    System.out.println(clazz);<span class="comment">// class com.hongyi.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：通过运行时类的对象，调用getClass()方法</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式3：调用Class的静态方法：forName(String classPath) 用的最多</span></span><br><span class="line">    <span class="comment">// classPath：全类名</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;com.hongyi.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz == clazz2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(clazz2 == clazz3);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式4：使用类的加载器：ClassLoader 了解，用得少</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.hongyi.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);</span><br><span class="line">    System.out.println(clazz4 == clazz);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-3-类的加载与ClassLoader的理解"><a href="#8-3-类的加载与ClassLoader的理解" class="headerlink" title="8.3 类的加载与ClassLoader的理解"></a>8.3 类的加载与ClassLoader的理解</h3><h4 id="8-3-1-类的加载过程"><a href="#8-3-1-类的加载过程" class="headerlink" title="8.3.1 类的加载过程"></a>8.3.1 类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224659087.png" alt="image-20211215224659087"></p>
<ul>
<li><p>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。</p>
</li>
<li><p>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
</li>
</ul>
<ol>
<li><p>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题。</p>
</li>
<li><p>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 </p>
</li>
<li><p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 </p>
</li>
</ol>
<ul>
<li>初始化：</li>
</ul>
<ol>
<li><p>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 </p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 </p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</p>
</li>
</ol>
<h4 id="8-3-2-ClassLoader的理解"><a href="#8-3-2-ClassLoader的理解" class="headerlink" title="8.3.2 ClassLoader的理解"></a>8.3.2 ClassLoader的理解</h4><blockquote>
<p>类加载器</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224709444.png" alt="image-20211215224709444"></p>
<p>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在==堆==中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
<p>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p>
<blockquote>
<p>ClassLoader</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224719025.png" alt="image-20211215224719025"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取类加载器，自定义类的加载器类型为系统类加载器</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">// jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一层的类加载器，为扩展类加载器</span></span><br><span class="line">    ClassLoader classLoader1 = classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">// jdk.internal.loader.ClassLoaders$PlatformClassLoader@c818063</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一层的类加载器，为引导类加载器，但是获取不了，返回为null</span></span><br><span class="line">    <span class="comment">// 引导类加载器主要负责加载核心类库，无法加载自定义类</span></span><br><span class="line">    ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    ClassLoader classLoader3 = String.class.getClassLoader();<span class="comment">//引导类加载器</span></span><br><span class="line">    System.out.println(classLoader3);<span class="comment">// null：获取不了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>ClassLoader</code>加载配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 此时的文件默认在当前的project下</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    prop.load(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：使用类加载器</span></span><br><span class="line">    <span class="comment">// 配置文件默认识别为在当前project的src下</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    prop.load(is);</span><br><span class="line"></span><br><span class="line">    System.out.println(prop.getProperty(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    System.out.println(prop.getProperty(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-4-创建运行时对象"><a href="#8-4-创建运行时对象" class="headerlink" title="8.4 创建运行时对象 *"></a>8.4 创建运行时对象 *</h3><h4 id="8-4-1-newInstance"><a href="#8-4-1-newInstance" class="headerlink" title="8.4.1 newInstance()"></a>8.4.1 newInstance()</h4><p>此方法实质上是调用运行时类的空参构造器，要想此方法正确的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参构造器</li>
<li>空参构造器的访问权限必须得够，通常设置为<code>public</code></li>
</ul>
<p>在<code>javabean</code>中要求提供一个空参构造器，便于通过反射来创建运行时类对象，便于子类继承此运行时类时，默认调用<code>super()</code>时，保证父类有此构造器。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// newInstance():调用此方法，创建对应的运行时类的对象</span></span><br><span class="line">    <span class="comment">// 实际上还是通过调用Person类的空参构造器来造对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-4-2-反射的动态性理解"><a href="#8-4-2-反射的动态性理解" class="headerlink" title="8.4.2 反射的动态性理解"></a>8.4.2 反射的动态性理解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);<span class="comment">//产生0,1,2随机数</span></span><br><span class="line">    String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            classPath =  <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            classPath = <span class="string">&quot;com.hongyi.Person&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = getInstance(classPath);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法要创建一个指定全类名的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classPath 全限定类名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-5-获取运行时类的完整结构"><a href="#8-5-获取运行时类的完整结构" class="headerlink" title="8.5 获取运行时类的完整结构"></a>8.5 获取运行时类的完整结构</h3><h4 id="8-5-1-代码准备"><a href="#8-5-1-代码准备" class="headerlink" title="8.5.1 代码准备"></a>8.5.1 代码准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物呼吸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Creature</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">MyInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;ABC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Human(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是：&quot;</span>+nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">(String interests)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224729258.png" alt="image-20211215224729258"></p>
<h4 id="8-5-2-获取运行时类的属性结构和内部结构"><a href="#8-5-2-获取运行时类的属性结构和内部结构" class="headerlink" title="8.5.2 获取运行时类的属性结构和内部结构"></a>8.5.2 获取运行时类的属性结构和内部结构</h4><blockquote>
<p><code>getFields()</code></p>
<p><code>getDeclaredFields()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Human.class;</span><br><span class="line">    <span class="comment">// 获取属性结构</span></span><br><span class="line">    <span class="comment">// getFields():获取当前运行时类及其父类中声明为public的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// public int com.hongyi.Human.id</span></span><br><span class="line">        <span class="comment">// public double com.hongyi.Creature.weight</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// getDeclaredFields():获取当前运行时类的所有属性，不包含父类</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// private java.lang.String com.hongyi.Human.name</span></span><br><span class="line">        <span class="comment">// int com.hongyi.Human.age</span></span><br><span class="line">        <span class="comment">// public int com.hongyi.Human.id</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getModifiers()</code></p>
<p><code>getType()</code></p>
<p><code>getName()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限修饰符 数据类型 变量名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Human.class;</span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : declaredFields)&#123;</span><br><span class="line">        <span class="comment">// 1.获取权限修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line">        System.out.print(<span class="string">&quot;权限修饰符:&quot;</span>+Modifier.toString(modifiers)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="comment">// 2.数据类型</span></span><br><span class="line">        Class type = f.getType();</span><br><span class="line">        System.out.print(<span class="string">&quot;数据类型：&quot;</span>+type.getName()+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="comment">// 3.变量名</span></span><br><span class="line">        String name = f.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;变量名：&quot;</span>+name);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224738420.png" alt="image-20211215224738420"></p>
<h4 id="8-5-3-获取运行时类的方法结构"><a href="#8-5-3-获取运行时类的方法结构" class="headerlink" title="8.5.3 获取运行时类的方法结构"></a>8.5.3 获取运行时类的方法结构</h4><h3 id="8-6-调用运行时类的指定结构"><a href="#8-6-调用运行时类的指定结构" class="headerlink" title="8.6 调用运行时类的指定结构 *"></a>8.6 调用运行时类的指定结构 *</h3><h3 id="8-7-反射的应用——动态代理"><a href="#8-7-反射的应用——动态代理" class="headerlink" title="8.7 反射的应用——动态代理"></a>8.7 反射的应用——动态代理</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/img/java.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/24/%E3%82%B9%E3%82%AF%E3%83%BC%E3%83%AB%E3%83%A9%E3%83%B3%E3%83%96%E3%83%AB/"><img class="prev-cover" src="/img/schoolrumble.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">スクールランブル</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/22/Webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/webpack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Webpack学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/09/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="IDEA常用快捷键"><img class="cover" src="/img/idea.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-09</div><div class="title">IDEA常用快捷键</div></div></a></div><div><a href="/2020/12/01/Java%E8%A1%A5%E5%85%85/" title="Java补充知识"><img class="cover" src="/img/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">Java补充知识</div></div></a></div><div><a href="/2020/05/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="LeetCode刷题笔记"><img class="cover" src="/img/leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-20</div><div class="title">LeetCode刷题笔记</div></div></a></div><div><a href="/2021/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux学习笔记"><img class="cover" src="/img/linux.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-15</div><div class="title">Linux学习笔记</div></div></a></div><div><a href="/2021/03/20/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nginx学习笔记"><img class="cover" src="/img/nginx.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">Nginx学习笔记</div></div></a></div><div><a href="/2021/09/08/JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JavaWeb学习笔记"><img class="cover" src="/img/javaweb.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">JavaWeb学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%AB%98%E7%BA%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Java高级学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1 多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">2 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text">2.1 字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-text">2.1.2 String的不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-String%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1.3 String对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">① 概述和使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E4%B8%8D%E5%90%8C%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">② 不同拼接操作的对比</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">2.1.4 常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.1.5 数据转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">① 基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-char%E6%95%B0%E7%BB%84"><span class="toc-text">② char数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-byte%E6%95%B0%E7%BB%84"><span class="toc-text">③ byte数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-6-StringBuffer%E5%92%8CStringBuilder%E7%B1%BB"><span class="toc-text">2.1.6 StringBuffer和StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E4%BB%8B%E7%BB%8D"><span class="toc-text">① 介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-StringBuffer%E7%B1%BB"><span class="toc-text">② StringBuffer类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-StringBuilder%E7%B1%BB"><span class="toc-text">③ StringBuilder类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-text">2.2 日期时间相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-JDK8%E4%B9%8B%E5%89%8D%E7%9A%84API"><span class="toc-text">2.2.1 JDK8之前的API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-System%E7%B1%BB"><span class="toc-text">①  System类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-Date%E7%B1%BB"><span class="toc-text">② Date类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-SimpleDateFormat%E7%B1%BB"><span class="toc-text">③ SimpleDateFormat类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-Calendar%E7%B1%BB"><span class="toc-text">④ Calendar类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-JDK8%E4%B8%AD%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">2.2.2 JDK8中新的日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%96%B0API%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">① 新API的引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-LocalDate%E7%B1%BB"><span class="toc-text">② LocalDate类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-Instant%E7%B1%BB"><span class="toc-text">③ Instant类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-DateTimeFormatter%E7%B1%BB"><span class="toc-text">④ DateTimeFormatter类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E5%85%B6%E4%BB%96API"><span class="toc-text">⑤ 其他API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">2.3 比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2.3.1 自然排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E4%BE%8B%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">② 实例及使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">2.3.2 定制排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AE%9E%E4%BE%8B%E5%8F%8A%E4%BD%BF%E7%94%A8-1"><span class="toc-text">② 实例及使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%BA%8C%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-text">③ 二者对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-System%E7%B1%BB"><span class="toc-text">2.4 System类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-text">3 枚举类和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.1 枚举类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">3.1.2 自定义枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E4%BD%BF%E7%94%A8Enum%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">3.1.3 使用Enum定义枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">① 使用说明</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-Enum%E7%B1%BB%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="toc-text">② Enum类的主要方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">③ 实现接口的枚举类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3.2 注解的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2.2 常见的Annotation示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">3.2.3 自定义注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">① 基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">② 基本元注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9B%86%E5%90%88"><span class="toc-text">4 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1 集合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4.1.1 数组的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">4.1.2 集合框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.2 Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4.2.1 Collection接口中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.2.2 集合元素的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-text">4.2.3 foreach循环遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">4.3 List接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-List%E6%A6%82%E8%BF%B0"><span class="toc-text">4.3.1 List概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.3.2 ArrayList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.3.3 LinkedList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4.3.4 List接口的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-List%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">4.3.5 List集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">4.4 Set接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-Set%E6%A6%82%E8%BF%B0"><span class="toc-text">4.4.1 Set概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-HashSet%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">4.4.2 HashSet添加元素的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E5%85%B3%E4%BA%8Eequals-%E5%92%8ChashCode-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-text">4.4.3 关于equals()和hashCode()方法的重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-4-LinkedHashSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.4.4 LinkedHashSet的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-5-TreeSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">4.4.5 TreeSet的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">4.5 Map接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-Map%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">4.5.1 Map框架概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-Map%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9Akey%E5%92%8Cvalue%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">4.5.2 Map结构的理解：key和value的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">4.5.3 HashMap的底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">4.5.4 HashMap源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-5-LinkedHashMap%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">4.5.5 LinkedHashMap原理及使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-6-Hashtable%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">4.5.6 Hashtable原理及使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-7-Properties%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">4.5.7 Properties原理及使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">4.6 Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.6.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4.6.2 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%8E%92%E5%BA%8F"><span class="toc-text">① 排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="toc-text">② 查找和替换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6"><span class="toc-text">③ 同步控制</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B3%9B%E5%9E%8B"><span class="toc-text">5 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%83%8C%E6%99%AF"><span class="toc-text">5.1.1 泛型的设计背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1.2 泛型的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-text">5.1.3 需要泛型的理由</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">5.2 集合中使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-ArrayList"><span class="toc-text">5.2.1 ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-HashMap"><span class="toc-text">5.2.2 HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E6%80%BB%E7%BB%93"><span class="toc-text">5.2.3 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-text">5.3 自定义泛型结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.3.1 自定义泛型类和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">5.3.2 自定义泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">5.4 泛型在继承上的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">5.5 通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-IO%E6%B5%81"><span class="toc-text">6 IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-File%E7%B1%BB"><span class="toc-text">6.1 File类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">6.1.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">6.1.2 常用构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">6.1.3 常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-text">① 获取功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">② 重命名功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">③ 判断功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-text">④ 创建功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-text">⑤ 删除功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">6.2 IO流原理及流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">6.2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">6.2.2 流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-%E6%B5%81%E7%9A%84%E4%BD%93%E7%B3%BB"><span class="toc-text">6.2.3 流的体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">6.2.4 节点流和处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-5-InputStream-amp-Reader"><span class="toc-text">6.2.5 InputStream &amp; Reader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-6-OutputStream-amp-Writer"><span class="toc-text">6.2.6 OutputStream &amp; Writer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%88%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89"><span class="toc-text">6.3 节点流（文件流）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6"><span class="toc-text">6.3.1 字符流读取文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-2-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text">6.3.2 字符流写入文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-3-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6"><span class="toc-text">6.3.3 字节流读取和写入文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-text">6.4 处理流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">6.4.1 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0-2"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">② 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">6.4.2 转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0-3"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">② 字符集</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">③ 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">6.4.3 标准输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-4-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-text">6.4.4 打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">6.4.5 数据流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-6-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">6.4.6 对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0-4"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">② 代码示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-7-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">6.4.7 随机存取文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0-5"><span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">② 代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-NIO"><span class="toc-text">6.5 NIO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">7 网络编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">8 反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1 反射机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%89%E5%85%B3%E7%9A%84API"><span class="toc-text">8.1.2 与反射有关的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E4%B9%8B%E5%89%8D%E5%AF%B9Person%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">8.1.3 利用反射之前对Person类的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%AF%B9Person%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">8.1.4 利用反射对Person类操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">8.1.5 如何看待反射和封装性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-text">8.2 理解Class类并获取Class实例 *</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">8.2.1 Class类的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">8.2.2 获取Class实例的四种方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">8.3 类的加载与ClassLoader的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">8.3.1 类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-ClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">8.3.2 ClassLoader的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.4 创建运行时对象 *</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-newInstance"><span class="toc-text">8.4.1 newInstance()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7%E7%90%86%E8%A7%A3"><span class="toc-text">8.4.2 反射的动态性理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-text">8.5 获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E4%BB%A3%E7%A0%81%E5%87%86%E5%A4%87"><span class="toc-text">8.5.1 代码准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">8.5.2 获取运行时类的属性结构和内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-3-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">8.5.3 获取运行时类的方法结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">8.6 调用运行时类的指定结构 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">8.7 反射的应用——动态代理</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>