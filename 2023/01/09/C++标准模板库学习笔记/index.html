<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++标准模板库学习笔记 | Kisugi Takumi</title><meta name="keywords" content="C++,STL"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++标准模板库学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++标准模板库学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2023/01/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="C++标准模板库学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/stl.png">
<meta property="article:published_time" content="2023-01-09T06:46:25.000Z">
<meta property="article:modified_time" content="2023-01-15T11:41:15.436Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/stl.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2023/01/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++标准模板库学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-15 19:41:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++标准模板库学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-09T06:46:25.000Z" title="发表于 2023-01-09 14:46:25">2023-01-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T11:41:15.436Z" title="更新于 2023-01-15 19:41:15">2023-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++标准模板库学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="C-标准模板库学习笔记"><a href="#C-标准模板库学习笔记" class="headerlink" title="C++标准模板库学习笔记"></a>C++标准模板库学习笔记</h1><p>学习时间：2023年1月9日</p>
<p>参考资料：</p>
<ul>
<li>C++ primer plus中文第六版第十六章</li>
<li><a target="_blank" rel="noopener" href="https://wyqz.top/p/870124582.htm">行码棋的博客</a></li>
<li><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/6675.html">C语言中文网</a></li>
</ul>
<h2 id="0-STL简介"><a href="#0-STL简介" class="headerlink" title="0 STL简介"></a>0 STL简介</h2><h3 id="0-1-概述"><a href="#0-1-概述" class="headerlink" title="0.1 概述"></a>0.1 概述</h3><p>STL，英文全称 <code>standard template library</code>，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。</p>
<p>STL 最初由惠普实验室开发，于 1998 年被定为国际标准，正式成为 C++ 程序库的重要组成部分。值得一提的是，如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。</p>
<p><code>Alexander Stepanov</code>（后被誉为 STL 标准模板库之父，后简称 Stepanov），1950 年出生与前苏联的莫斯科，他曾在莫斯科大学研究数学，此后一直致力于计算机语言和泛型库研究。</p>
<h3 id="0-2-STL组成"><a href="#0-2-STL组成" class="headerlink" title="0.2 STL组成"></a>0.2 STL组成</h3><p>通常认为，STL 是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前  2 部分服务的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组成</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器</td>
<td>一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。</td>
</tr>
<tr>
<td>算法</td>
<td>STL 提供了非常多的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件<code>&lt;algorithm&gt;</code>中，少部分位于头文件 <code>&lt;numeric&gt;</code> 中。</td>
</tr>
<tr>
<td>迭代器</td>
<td>在  STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。</td>
</tr>
<tr>
<td>函数对象</td>
<td>如果一个类将 <code>()</code>运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。</td>
</tr>
<tr>
<td>适配器</td>
<td>可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。</td>
</tr>
<tr>
<td>内存分配器</td>
<td>为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。</td>
</tr>
</tbody>
</table>
</div>
<p>STL相关的头文件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109124542162.png" alt="image-20230109124542162"></p>
<p>按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 <code>&lt;vector&gt;</code> 为例，此为无扩展名的形式，而 <code>&lt;vector.h&gt;</code> 为有扩展名的形式。</p>
<h2 id="1-string类"><a href="#1-string类" class="headerlink" title="1 string类"></a>1 string类</h2><p>string类是由头文件<code>string</code>支持的，注意<code>string.h</code>和<code>cstring</code>不支持string类。</p>
<h3 id="1-1-构造字符串"><a href="#1-1-构造字符串" class="headerlink" title="1.1 构造字符串"></a>1.1 构造字符串</h3><p>以下是string类的构造函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109130723806.png" alt="image-20230109130723806"></p>
<p>表中<code>size_type</code>是一个依赖于实现的整型。</p>
<p>string类使用<code>string::npos</code>定义为字符串的最大长度，通常为<code>unsigned int</code>的最大值。</p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str1.cpp -- introducing the string class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="comment">// 将one初始化为C风格字符串</span></span><br><span class="line">    <span class="function">string <span class="title">one</span><span class="params">(<span class="string">&quot;Lottery Winner!&quot;</span>)</span></span>;     <span class="comment">// ctor #1</span></span><br><span class="line">    cout &lt;&lt; one &lt;&lt; endl;               <span class="comment">// overloaded &lt;&lt;</span></span><br><span class="line">    <span class="comment">// 将two初始化为20个$组成的字符串</span></span><br><span class="line">    <span class="function">string <span class="title">two</span><span class="params">(<span class="number">20</span>, <span class="string">&#x27;$&#x27;</span>)</span></span>;               <span class="comment">// ctor #2</span></span><br><span class="line">    cout &lt;&lt; two &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 复制构造</span></span><br><span class="line">    <span class="function">string <span class="title">three</span><span class="params">(one)</span></span>;                 <span class="comment">// ctor #3</span></span><br><span class="line">    cout &lt;&lt; three &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// +=重载，连接字符串</span></span><br><span class="line">    one += <span class="string">&quot; Oops!&quot;</span>;                   <span class="comment">// overloaded +=</span></span><br><span class="line">    cout &lt;&lt; one &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// =重载，可以将string对象、C风格字符串或char赋值给string对象</span></span><br><span class="line">    two = <span class="string">&quot;Sorry! That was &quot;</span>;</span><br><span class="line">    <span class="comment">// []重载，用于访问某个位置的字符</span></span><br><span class="line">    three[<span class="number">0</span>] = <span class="string">&#x27;P&#x27;</span>;</span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    string four;                       <span class="comment">// ctor #4</span></span><br><span class="line">    <span class="comment">// +和=的重载</span></span><br><span class="line">    four = two + three;                <span class="comment">// overloaded +, =</span></span><br><span class="line">    cout &lt;&lt; four &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">char</span> alls[] = <span class="string">&quot;All&#x27;s well that ends well&quot;</span>;</span><br><span class="line">    <span class="comment">// 20表示复制alls的前20个字符</span></span><br><span class="line">    <span class="function">string <span class="title">five</span><span class="params">(alls, <span class="number">20</span>)</span></span>;              <span class="comment">// ctor #5</span></span><br><span class="line">    cout &lt;&lt; five &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">    <span class="comment">// 模板参数构造</span></span><br><span class="line">    <span class="function">string <span class="title">six</span><span class="params">(alls + <span class="number">6</span>, alls + <span class="number">10</span>)</span></span>;     <span class="comment">// ctor #6</span></span><br><span class="line">    cout &lt;&lt; six  &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="comment">// 模板参数构造</span></span><br><span class="line">    <span class="function">string <span class="title">seven</span><span class="params">(&amp;five[<span class="number">6</span>], &amp;five[<span class="number">10</span>])</span></span>; <span class="comment">// ctor #6 again</span></span><br><span class="line">    cout &lt;&lt; seven &lt;&lt; <span class="string">&quot;...\n&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">eight</span><span class="params">(four, <span class="number">7</span>, <span class="number">16</span>)</span></span>;         <span class="comment">// ctor #7</span></span><br><span class="line">    cout &lt;&lt; eight &lt;&lt; <span class="string">&quot; in motion!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// std::cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意第6个构造函数使用了模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Iter&gt;</span></span><br><span class="line"><span class="function"><span class="title">string</span><span class="params">(Iter begin, Iter end)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常，<code>begin</code>和<code>end</code>可以是迭代器（STL中的<strong>广义化指针</strong>）。使用<code>[begin, end)</code>区间的值来构造string对象。</p>
<p>本例中的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// alls = All&#x27;s well that ends well</span></span><br><span class="line"><span class="function">string <span class="title">six</span><span class="params">(alls + <span class="number">6</span>, alls + <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由于数组名相当于指针，所以<code>alls+6</code>和<code>alls+10</code>的类型都是<code>char*</code>，因此使用模板时，将用类型<code>char*</code>替换Iter。第一个参数指向数组 alls中的第一个w，第二个参数指向第一个well后面的空格。因此，six将被初始化为字符串<code>&quot;well&quot;</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114112338238.png" alt="image-20230114112338238"></p>
<p>现在假设要用这个构造函数将对象初始化为另一个 string 对象（假设为 <code>five</code>）的一部分内容，则下面的语句不管用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">seven</span><span class="params">(five + <span class="number">6</span>, five + <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原因在于，对象名不是对象的地址。但是<code>five[6]</code>是一个char，<code>&amp;five[6]</code>就是该字符的地址，因此下面可行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">seven</span><span class="params">(&amp;five[<span class="number">6</span>], &amp;five[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-string类输入"><a href="#1-2-string类输入" class="headerlink" title="1.2 string类输入"></a>1.2 string类输入</h3><p>暂略</p>
<h3 id="1-3-使用字符串"><a href="#1-3-使用字符串" class="headerlink" title="1.3 使用字符串"></a>1.3 使用字符串</h3><h4 id="1-3-1-比较字符串"><a href="#1-3-1-比较字符串" class="headerlink" title="1.3.1 比较字符串"></a>1.3.1 比较字符串</h4><p>string类对关系运算符（<code>&lt;,&lt;=,==,!=,&gt;=,&gt;</code>）进行了重载。对于每个关系运算符，都以三种方式进行重载，以便能够将string对象与另一个string对象，C风格字符串进行比较。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;cobra&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;coral&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> s3[] = <span class="string">&quot;anaconda&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(s1 &lt; s2) &#123; <span class="comment">// operator&lt;(const string &amp;, const string &amp;);</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s1 == s3) &#123; <span class="comment">// operator==(const string &amp;, const char *);</span></span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s3 != s2) &#123; <span class="comment">// operator!=(const char *, const string &amp;);</span></span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-字符串长度"><a href="#1-3-2-字符串长度" class="headerlink" title="1.3.2 字符串长度"></a>1.3.2 字符串长度</h4><p>可使用<code>length()</code>或<code>size()</code>方法。前者来自较早版本的string类，后者为兼容STL而添加的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s1.<span class="built_in">length</span>() == s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-3-搜索子串和字符"><a href="#1-3-3-搜索子串和字符" class="headerlink" title="1.3.3 搜索子串和字符"></a>1.3.3 搜索子串和字符</h4><p>string 类有一些查找子串和字符的成员函数，它们的返回值都是子串或字符在 string 对象字符串中的位置（即下标）。如果查不到，则返回 <code>string::npos</code>。<code>string: :npos</code> 是在 string 类中定义的一个静态常量，为字符串可存储的最大字符数，通常为<code>unsigned int</code>或<code>unsigned long</code>的最大取值。</p>
<p>以<code>find</code>方法为例，string类提供了四个重载函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从字符串的 pos 位置开始，查找子字符串 str。如果找到，则返回该子符符串首次出现时其首字符的索引；否则，返回string::npos</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="keyword">const</span> string &amp;str, size_type pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, size_type pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的 pos 位置开始，查找s的前n个字符组成的子字符串。如果找到，则返回该子字符串首次出现时其首字符的索引；</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s, size_type pos = <span class="number">0</span>, size_type n)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串的 pos 位置开始，查找字符ch。如果找到，则返回该字符首次出现的位置；</span></span><br><span class="line"><span class="function">size_type <span class="title">find</span><span class="params">(<span class="keyword">char</span> ch, size_type pos = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>此外，string类还提供了如下方法，他们的重载函数特征标与<code>find()</code>相同：</p>
<ul>
<li><code>rfind</code>：从后往前查找子串或字符出现的位置。</li>
<li><code>find_first_of</code>：从前往后查找何处出现另一个字符串中包含的字符。</li>
<li><code>find_last_of</code>：从后往前查找何处出现另一个字符串中包含的字符。</li>
<li><code>find_first_not_of</code>：从前往后查找何处出现另一个字符串中没有包含的字符。</li>
<li><code>find_last_not_of</code>：从后往前查找何处出现另一个字符串中没有包含的字符。</li>
</ul>
<h4 id="1-3-4-求子串"><a href="#1-3-4-求子串" class="headerlink" title="1.3.4 求子串"></a>1.3.4 求子串</h4><p><code>substr</code> 成员函数可以用于求子串，原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从第n个位置开始，向后获取m个字符</span></span><br><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="keyword">int</span> n = <span class="number">0</span>, <span class="keyword">int</span> m = string::npos)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;this is ok&quot;</span>;</span><br><span class="line">string s2 = s1.<span class="built_in">substr</span>(<span class="number">2</span>, <span class="number">4</span>);  <span class="comment">// s2 = &quot;is i&quot;</span></span><br><span class="line"><span class="comment">// 如果省略 m 或 m 超过了字符串的长度，则求出来的子串就是从下标 n 开始一直到字符串结束的部分</span></span><br><span class="line">s2 = s1.<span class="built_in">substr</span>(<span class="number">2</span>);  <span class="comment">// s2 = &quot;is is ok&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="1-4-字符串种类"><a href="#1-4-字符串种类" class="headerlink" title="1.4 字符串种类"></a>1.4 字符串种类</h3><p>string类实际上是基于一个模板类的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">charT</span>, <span class="keyword">class</span> <span class="title">traits</span> =</span> <span class="keyword">char</span> _traits&lt;charT&gt;,</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> =</span> allocator&lt;charT&gt; &gt;</span><br><span class="line">basic_string &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>模板类<code>basic_string</code>有4个具体化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">wchar_t</span>&gt; wstring;</span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char16_t</span>&gt; u16string; <span class="comment">// C++11</span></span><br><span class="line"><span class="keyword">typedef</span> basic_string&lt;<span class="keyword">char32_t</span>&gt; u32string; <span class="comment">// C++11</span></span><br></pre></td></tr></table></figure>
<h2 id="2-智能指针模板类"><a href="#2-智能指针模板类" class="headerlink" title="2 智能指针模板类"></a>2 智能指针模板类</h2><p>暂略</p>
<h2 id="3-标准模板库"><a href="#3-标准模板库" class="headerlink" title="3 标准模板库"></a>3 标准模板库</h2><p>本章只对一些基本概念进行解释和介绍。</p>
<h3 id="3-1-模板类vector"><a href="#3-1-模板类vector" class="headerlink" title="3.1 模板类vector"></a>3.1 模板类vector</h3><p>矢量vector对应于数组。</p>
<p>vector模板使用动态分配内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">ratings</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">scores</span><span class="params">(n)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>[]</code>被重载，可以使用通常的数组表示法来访问各个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ratings[<span class="number">0</span>] = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    cout &lt;&lt; scores[i] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-可对vector执行的操作"><a href="#3-2-可对vector执行的操作" class="headerlink" title="3.2 可对vector执行的操作"></a>3.2 可对vector执行的操作</h3><p>所有的STL容器都提供了一些基本方法：</p>
<ul>
<li><code>size()</code>：返回容器中元素的个数</li>
<li><code>swap()</code>：交换两个容器的内容</li>
<li><code>begin()</code>：返回一个指向容器中第一个元素的迭代器</li>
<li><code>end()</code>：返回一个表示<strong>超过容器尾</strong>的迭代器，类似于字符串的<code>\0</code></li>
</ul>
<p>迭代器是一个广义指针。事实上，它可以是指针，也可以是一个可对其执行类似指针的操。通过将指针广义化为迭代器，让STL能够为各种不同的容器类（包括那些简单指针无法处理的类）提供统一的接口。每个容器类都定义了一个合适的迭代器（一个类成员），该迭代器的类型是一个名为<code>iterator</code>的<code>typedef</code>，其作用域为整个类。例如，要为vector的double类型规范声明一个迭代器，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个迭代器</span></span><br><span class="line">vector&lt;<span class="keyword">double</span>&gt;::iterator pd;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd = scores.<span class="built_in">begin</span>();</span><br><span class="line">*pd = <span class="number">22.3</span>; <span class="comment">// scores[0] = 22.3;</span></span><br><span class="line">++pd; <span class="comment">// 让迭代器向前移动一个位置</span></span><br></pre></td></tr></table></figure>
<p>可以看出，迭代器pd的行为类似于指针。</p>
<p>遍历容器：注意end的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(pd = scores.<span class="built_in">begin</span>(); pd != scores.<span class="built_in">end</span>(); pd++) &#123;</span><br><span class="line">    cout &lt;&lt; *pd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span>(pd = scores.<span class="built_in">begin</span>(); pd &lt; scores.<span class="built_in">end</span>(); pd++) &#123;</span><br><span class="line">    cout &lt;&lt; *pd &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114125902278.png" alt="image-20230114125902278"></p>
<blockquote>
<p>特有方法</p>
</blockquote>
<p>vector容器中有其他容器不具有的特有方法。</p>
<ul>
<li><code>push_back()</code>：将元素添加进矢量末尾。它将负责动态内存管理，当矢量内存不够时，将自动扩容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">double</span>&gt; scores; <span class="comment">// 一个空的vector</span></span><br><span class="line"><span class="keyword">double</span> temp;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt;temp &amp;&amp; temp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    scores.<span class="built_in">push_back</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>erase()</code>：接收两个迭代器，删除矢量中给定区间的元素，左闭右开</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scores.<span class="built_in">erase</span>(scores.<span class="built_in">begin</span>(), scores.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">// 删除begin()~begin()+1的元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>insert()</code>：接收三个迭代器，第一个指定新元素的插入位置，第二三个指定插入区间，左闭右开</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; old_v;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; new_v;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">old_v.<span class="built_in">insert</span>(old_v.<span class="built_in">begin</span>(), new_v.<span class="built_in">begin</span>() + <span class="number">1</span>, new_v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>上述代码将<code>new_v</code>的除第一个元素外的所有元素插入到<code>old_v</code>的第一个元素的前面。</p>
<h3 id="3-3-其他操作"><a href="#3-3-其他操作" class="headerlink" title="3.3 其他操作"></a>3.3 其他操作</h3><p>程序员通常要对数组执行很多操作，如搜索、排序、随机排序等。矢量模板类包含了执行这些常见的操作的方法吗？没有！STL从更广泛的角度定义了<strong>非成员</strong>（non-member）函数来执行这些操作，即不是为每个容器类定义find成员函数，而是定义了一个适用于所有容器类的非成员函数find。这种设计理念省去了大量重复的工作。</p>
<p>另一方面，即使有执行相同任务的非成员函数，STL有时也会定义一个成员函数。这是因为对有些操作来说，类特定算法的效率比通用算法高，因此，vector的成员函数swap的效率比非成员函数swap高，但非成员函数让您能够交换两个类型不同的容器的内容。</p>
<ul>
<li><code>for_each()</code>：接收三个参数，前两个是定义容器中区间的迭代器，最后一个是指向函数的指针（准确来说是函数对象）。它将被指向的函数应用于容器区间中的各个元素，函数不能修改容器元素的值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator, <span class="keyword">typename</span> _Function&gt;</span></span><br><span class="line"><span class="function">_Function</span></span><br><span class="line"><span class="function"><span class="title">for_each</span><span class="params">(_InputIterator __first, _InputIterator __last, _Function __f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Review&gt;::iterator pr;</span><br><span class="line"><span class="keyword">for</span>(pr = books.<span class="built_in">begin</span>(); pr != books.<span class="built_in">end</span>(); pr++) &#123;</span><br><span class="line">    <span class="built_in">ShowReview</span>(*pr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以替换为</span></span><br><span class="line">for_each(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), ShowReview);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>random_shuffle()</code>：接收两个指定容器区间的迭代器，随机排列该区间中的元素。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">random_shuffle</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>该函数要求容器类允许随机访问。</p>
<ul>
<li><p><code>sort()</code>：要求容器支持随机访问</p>
<ul>
<li><p>第一个版本：接受两个定义区间的迭代器参数，并使用为存储在容器中的类型元素定义的<code>&lt;</code>运算符，对区间中的元素进行操作。例如，下面的语句按<strong>升序</strong>对<code>coolstuff</code>的内容进行排序，排序时使用内置的<code>&lt;</code>运算符对值进行比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; coolstuff;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">sort</span>(coolstuff.<span class="built_in">begin</span>(), coolstuff.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个版本：如果容器元素是自定义类型，需要在类中对<code>operator&lt;()</code>函数进行重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Review类中：</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Review &amp; r1,<span class="keyword">const</span> Review &amp; r2) &#123;</span><br><span class="line">    <span class="comment">// 先对title比较</span></span><br><span class="line">    <span class="keyword">if</span> (r1.title &lt; r2.title)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// title相同则按rating比较</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(rl.title == r2.title &amp;&amp; r1.rating &lt; r2.rating)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">vector&lt;Review&gt; books;</span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三个版本：接受两个定义区间的迭代器参数，第三个参数是指向要使用的函数的指针（函数对象）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="keyword">const</span> Review &amp; r1, <span class="keyword">const</span> Review &amp; r2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r1.rating &lt; r2.rating) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), WorseThan);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-基于范围的for循环"><a href="#3-4-基于范围的for循环" class="headerlink" title="3.4 基于范围的for循环"></a>3.4 基于范围的for循环</h3><p>在Java中为增强for循环。</p>
<p>基于范围的for循环是为用于STL而设计的，但不仅可用于STL：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> x : prices) &#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>for_each</code>循环，可以修改为基于范围的for循环：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for_each(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), func);</span><br><span class="line"><span class="comment">// 基于范围的for：</span></span><br><span class="line"><span class="keyword">for</span>(Review x : books) &#123;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还可以使用auto关键字自动判别x的类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : books) &#123;</span><br><span class="line">    <span class="built_in">func</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于范围的for循环可以修改容器元素，而<code>for_each</code>不行。</p>
<h2 id="4-泛型编程"><a href="#4-泛型编程" class="headerlink" title="4 泛型编程"></a>4 泛型编程</h2><p>STL是一种泛型编程。泛型编程关注的是算法。</p>
<h3 id="4-1-迭代器的必要性"><a href="#4-1-迭代器的必要性" class="headerlink" title="4.1 迭代器的必要性"></a>4.1 迭代器的必要性</h3><p>模板使得算法独立于数据类型，迭代器使得算法独立于容器类型（数据结构）。</p>
<blockquote>
<p>问题的引出：<code>find</code>函数</p>
</blockquote>
<ul>
<li>在一个double数组中搜索特定值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 为数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> * <span class="title">find_ar</span><span class="params">(<span class="keyword">double</span> * ar, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">double</span> &amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(ar[i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;ar[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// or return nullptr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用模板将这种算法推广到包含<code>==</code>运算符的、任意类型的数组。尽管如此，这种算法仍然与一种特定的数据结构（数组）关联在一起。</p>
<ul>
<li>在一个链表中搜索特定值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> item;</span><br><span class="line">    Node * p_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">find_ll</span><span class="params">(Node* head, <span class="keyword">const</span> <span class="keyword">double</span> &amp; val)</span> </span>&#123;</span><br><span class="line">    Node* start;</span><br><span class="line">    <span class="keyword">for</span>(start = head; start != <span class="literal">nullptr</span>; start = start-&gt;p_next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(start-&gt;item == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，也可以使用模板将这种算法推广到支持<code>==</code>运算符的任何数据类型的链表。然而，这种算法也是与特定的数据结构（链表）关联在一起。</p>
<p>从实现细节上看，这两个find函数的算法是不同的：一个使用数组索引来遍历元素，另一个则将start 重置为 start-&gt;p_next。但从广义上说，这两种算法是相同的：将值依次与容器中的每个值进行比较，直到找到匹配的为止。</p>
<p>泛型编程旨在使用同一个<code>find</code>函数来处理数组、链表或任何其他容器类型。即函数不仅独立于容器中存储的数据类型，而且独立于容器本身的数据结构。模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。</p>
<p>要实现find函数，迭代器应至少具备哪些特征呢？下面是一个简短的列表。</p>
<ul>
<li>应能够对迭代器执行解除引用的操作，以便能够访问它引用的值。即如果p是一个迭代器，则应对<code>*p</code>进行定义。</li>
<li>应能够将一个迭代器赋给另一个。即如果p和q都是迭代器，则应对表达式 <code>p=q</code> 进行定义。</li>
<li>应能够将一个迭代器与另一个进行比较，看它们是否相等。即如果p和q都是迭代器，则应对<code>p==q</code>和<code>p!=q</code>进行定义。</li>
<li>应能够使用迭代器遍历容器中的所有元素，这可以通过为迭代器p定义<code>++p</code>和<code>p++</code>来实现。</li>
</ul>
<p>除了上面的功能之外，还可能有其他的功能。实际上，STL按照功能的强弱定义了多种级别的迭代器。</p>
<blockquote>
<p>修改后的<code>find</code>函数</p>
</blockquote>
<ul>
<li>常规指针就能满足迭代器的要求，对于<code>find_ar</code>函数可以修改为：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>* iterator;</span><br><span class="line"><span class="function">iterator <span class="title">find_ar</span><span class="params">(iterator ar, <span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">double</span> &amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++, ar++)</span><br><span class="line">        <span class="keyword">if</span>(*ar == val)</span><br><span class="line">            <span class="keyword">return</span> ar;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以修改函数参数，使之接受两个指示区间的指针参数，其中的一个指向数组的起始位置，另一个指向数组的<strong>超尾</strong>：同时函数可以通过返回尾指针，来指出没有找到要找的值，下面的<code>find_ar</code>版本完成了这些修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span>* iterator;</span><br><span class="line"><span class="function">iterator <span class="title">find_ar</span><span class="params">(iterator begin, iterator end, <span class="keyword">const</span> <span class="keyword">double</span> &amp; val)</span> </span>&#123;</span><br><span class="line">    iterator ar;</span><br><span class="line">    <span class="keyword">for</span>(ar = begin; ar != end; ar++)</span><br><span class="line">        <span class="keyword">if</span>(*ar == val)</span><br><span class="line">            <span class="keyword">return</span> ar;</span><br><span class="line">    <span class="keyword">return</span> end; <span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于<code>find_ll</code>函数，可以定义一个迭代器类<code>iterator</code>，其中重载了<code>*</code>和<code>++</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">    Node * pt;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">iterator</span>() : <span class="built_in">pt</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">iterator</span>(Node * pn) : <span class="built_in">pt</span>(pn) &#123;&#125;</span><br><span class="line">    doiuble <span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> pt-&gt;item; &#125;</span><br><span class="line">    iterator&amp; <span class="keyword">operator</span>++() &#123; <span class="comment">// for ++pt;</span></span><br><span class="line">        pt = pt-&gt;p_next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iterator&amp; iterator++(<span class="keyword">int</span>) &#123; <span class="comment">// for pt++;</span></span><br><span class="line">        iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">        pt = pt-&gt;p_next;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>于是函数可以修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">find_ll</span><span class="params">(iterator head, <span class="keyword">const</span> <span class="keyword">double</span> &amp; val)</span> </span>&#123;</span><br><span class="line">    iterator start;</span><br><span class="line">    <span class="keyword">for</span>(start = head; start != <span class="number">0</span>; ++start) &#123;</span><br><span class="line">        <span class="keyword">if</span>(*start == val)</span><br><span class="line">            <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这和 <code>find_ar</code>几乎相同，差别在于如何谓词已到达最后一个值。<code>find_ar</code>函数使用超尾迭代器，而<code>find_ll</code>使用存储在最后一个节点中的空值。除了这种差别外，这两个函数完全相同。例如，可以要求链表的最后一个元素后面还有一个额外的元素，即让数组和链表都有超尾元素，并在迭代器到达超尾位置时结束搜索。这样，<code>find_ar</code>和<code>find_ll</code>检测数据尾的方式将相同，从而成为相同的算法。</p>
<p>注意，增加超尾元素后，对迭代器的要求变成了对容器类的要求。</p>
<blockquote>
<p>STL对迭代器的实现</p>
</blockquote>
<p>STL遵循上面介绍的方法。首先，每个容器类（vector、list、deque等）定义了相应的迭代器类型。</p>
<p>对于其中的某个容器类，迭代器可能是指针；而对于另一个容器类，迭代器则可能是对象。不管实现方式如何，迭代器都将提供所需的操作，如<code>*</code>和<code>++</code>（有些类需要的操作可能比其他类多）。其次，每个容器类都有一个超尾标记，当迭代器递增到超越容器的最后一个值后，这个值将被赋给迭代器。每个容器类都有begin和end方法，它们分别返回一个指向容器的第一个元素和超尾位置的迭代器。每个容器类都使用<code>++</code>操作，让迭代器从指向第一个元素逐步指向超尾位置，从而遍历容器中的每一个元素。</p>
<p>使用容器类时，无需知道其迭代器是如何实现的，也无需知道超尾是如何实现的，而只需知道它有迭代器，其begin返回一个指向第一个元素的迭代器，end返回一个指向超尾位置的迭代器即可。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">double</span>&gt;::iterator pr; <span class="comment">// 将pr声明为vector&lt;double&gt;类的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(pr = scores.<span class="built_in">begin</span>(); pr != scores.<span class="built_in">end</span>(); pr++)</span><br><span class="line">    cout &lt;&lt; *pr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">list&lt;<span class="keyword">double</span>&gt;::iterator pr; <span class="comment">// 将pr声明为vector&lt;double&gt;类的迭代器</span></span><br><span class="line"><span class="keyword">for</span>(pr = scores.<span class="built_in">begin</span>(); pr != scores.<span class="built_in">end</span>(); pr++)</span><br><span class="line">    cout &lt;&lt; *pr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>唯一不同的是pr的类型。因此，STL通过为每个容器模板类定义适当的迭代器，并以统一的风格设计类，能够对内部表示绝然不同的容器，编写相同的代码。</p>
<p>使用C++11新增的自动类型推断可进一步简化：对于矢量或列表，都可使用如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省去了vector&lt;double&gt;::iterator pr;声明</span></span><br><span class="line"><span class="comment">// 使用auto自动判定类型</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pr = scores.<span class="built_in">begin</span>(); pr != scores.<span class="built_in">end</span>(); pr++)</span><br><span class="line">    cout &lt;&lt; *pr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者：基于范围的for循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : scores) cout &lt;&lt; x &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-迭代器类型"><a href="#4-2-迭代器类型" class="headerlink" title="4.2 迭代器类型"></a>4.2 迭代器类型</h3><p>不同的算法对迭代器的要求不同，STL定义了5种迭代器。</p>
<h4 id="4-2-1-输入迭代器"><a href="#4-2-1-输入迭代器" class="headerlink" title="4.2.1 输入迭代器"></a>4.2.1 输入迭代器</h4><p>略，单向迭代器，只能递增。</p>
<h4 id="4-2-2-输出迭代器"><a href="#4-2-2-输出迭代器" class="headerlink" title="4.2.2 输出迭代器"></a>4.2.2 输出迭代器</h4><p>略，单向迭代器，只能递增。</p>
<h4 id="4-2-3-正向迭代器"><a href="#4-2-3-正向迭代器" class="headerlink" title="4.2.3 正向迭代器"></a>4.2.3 正向迭代器</h4><p>单向迭代器，只能递增<code>++</code>，可以修改和读取数据：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pirw; <span class="comment">// read-write iterator</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * pirw; <span class="comment">// read-only iterator</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-4-双向迭代器"><a href="#4-2-4-双向迭代器" class="headerlink" title="4.2.4 双向迭代器"></a>4.2.4 双向迭代器</h4><p>能够双向遍历容器，即可以进行<code>++</code>和<code>--</code>的操作。</p>
<h4 id="4-2-5-随机访问迭代器"><a href="#4-2-5-随机访问迭代器" class="headerlink" title="4.2.5 随机访问迭代器"></a>4.2.5 随机访问迭代器</h4><p>有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫做<strong>随机访问</strong>，需要随机访问迭代器。</p>
<p>随机访问迭代器具有双向迭代器的所有特性，同时添加了支持随机访问的操作（如指针增加运算）和用于对元素进行排序的关系运算符。下表列出了除双向迭代器的操作外，随机访问迭代器还支持的操作。其中，a和b都是迭代器值，n为整数，r为随机迭代器变量或引用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114151713252.png" alt="image-20230114151713252"></p>
<h3 id="4-3-迭代器层次结构"><a href="#4-3-迭代器层次结构" class="headerlink" title="4.3 迭代器层次结构"></a>4.3 迭代器层次结构</h3><p>下表中<code>i</code>为迭代器，<code>n</code>为整数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114151901626.png" alt="image-20230114151901626"></p>
<blockquote>
<p>提供多种迭代器的必要性</p>
</blockquote>
<p>目的是为了在编写算法尽可能使用要求最低的迭代器，并让它适用于容器的最大区间。这样，通过使用级别最低的输入迭代器，<code>find</code>函数便可用于任何包含可读取值的容器。而<code>sort</code>函数由于需要随机访问迭代器，所以只能用于支持这种迭代器的容器。</p>
<p>注意，各种迭代器的类型并不是确定的，而只是一种概念性描述。正如前面指出的，每个容器类都定义了一个类级typedef名称——iterator，因此 <code>vector&lt;int&gt;</code> 类的迭代器类型为 <code>vector&lt;int&gt;::interator</code>。然而，该类的文档将指出，矢量迭代器是随机访问迭代器，它允许使用基于任何迭代器类型的算法，因为随机访问迭代器具有所有迭代器的功能。同样，<code>list&lt;int&gt;</code>类的迭代器类型为<code>list&lt;int&gt;::iterator</code>。STL实现了一个双向链表，它使用双向迭代器，因此不能使用基于随机访问迭代器的算法，但可以使用基于要求较低的迭代器的算法。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器</th>
<th>对应的迭代器类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>array</code></td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td><code>vector</code></td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>随机访问迭代器</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向迭代器</td>
</tr>
<tr>
<td><code>set / multiset</code></td>
<td>双向迭代器</td>
</tr>
<tr>
<td><code>map / multimap</code></td>
<td>双向迭代器</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>前向迭代器</td>
</tr>
<tr>
<td><code>unordered_map / unordered_multimap</code></td>
<td>前向迭代器</td>
</tr>
<tr>
<td><code>unordered_set / unordered_multiset</code></td>
<td>前向迭代器</td>
</tr>
<tr>
<td><code>stack</code></td>
<td>不支持迭代器</td>
</tr>
<tr>
<td><code>queue</code></td>
<td>不支持迭代器</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-4-概念、改进和类型"><a href="#4-4-概念、改进和类型" class="headerlink" title="4.4 概念、改进和类型"></a>4.4 概念、改进和类型</h3><p>概念是具有名称的通用类别，例如正向迭代器，双向迭代器，序列容器等，它满足一系列的要求。</p>
<p>改进是概念上的继承，例如双向迭代器是对正向迭代器的改进。</p>
<p>类型是概念的具体实现。</p>
<p>例如，指向<code>int</code>的常规指针是一个随机访问迭代器模型，也是一个正向迭代器模型，因为它满足该概念（随机访问和正向）的所有要求。</p>
<h4 id="4-4-1-预定义迭代器类型"><a href="#4-4-1-预定义迭代器类型" class="headerlink" title="4.4.1 预定义迭代器类型"></a>4.4.1 预定义迭代器类型</h4><div class="table-container">
<table>
<thead>
<tr>
<th>迭代器定义方式</th>
<th>具体格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>正向迭代器</td>
<td><code>容器类名::iterator 迭代器名;</code></td>
</tr>
<tr>
<td>常量正向迭代器</td>
<td><code>容器类名::const_iterator 迭代器名;</code></td>
</tr>
<tr>
<td>反向迭代器</td>
<td><code>容器类名::reverse_iterator 迭代器名;</code></td>
</tr>
<tr>
<td>常量反向迭代器</td>
<td><code>容器类名::const_reverse_iterator 迭代器名;</code></td>
</tr>
</tbody>
</table>
</div>
<p>通过定义以上几种迭代器，就可以读取它指向的元素，<code>*迭代器名</code>就表示迭代器指向的元素。其中，常量迭代器和非常量迭代器的分别在于，通过非常量迭代器还能修改其指向的元素。另外，反向迭代器和正向迭代器的区别在于：</p>
<ul>
<li>对正向迭代器进行 ++ 操作时，迭代器会指向容器中的后一个元素；</li>
<li>而对反向迭代器进行 ++ 操作时，迭代器会指向容器中的前一个元素。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//需要引入 vector 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;; <span class="comment">//v被初始化成有10个元素</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//size返回元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; v[i] &lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//像普通数组一样使用vector容器</span></span><br><span class="line">    <span class="comment">//创建一个正向迭代器，当然，vector也支持其他 3 种定义迭代器的方式</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第二种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="comment">//用 != 比较两个迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第三种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (i = v.<span class="built_in">begin</span>(); i &lt; v.<span class="built_in">end</span>(); ++i) <span class="comment">//用 &lt; 比较两个迭代器</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;第四种遍历方法：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span> (i &lt; v.<span class="built_in">end</span>()) &#123; <span class="comment">//间隔一个输出</span></span><br><span class="line">        cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        i += <span class="number">2</span>; <span class="comment">// 随机访问迭代器支持 &quot;+= 整数&quot;  的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-2-容器适配器"><a href="#4-4-2-容器适配器" class="headerlink" title="4.4.2 容器适配器"></a>4.4.2 容器适配器</h4><p>STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>容器适配器</th>
<th>基础容器筛选条件</th>
<th>默认使用的基础容器</th>
</tr>
</thead>
<tbody>
<tr>
<td>stack</td>
<td>满足条件的基础容器有 vector、deque、list。</td>
<td>deque</td>
</tr>
<tr>
<td>queue</td>
<td>满足条件的基础容器有 deque、list。</td>
<td>deque</td>
</tr>
<tr>
<td>priority_queue</td>
<td>满足条件的基础容器有vector、deque。</td>
<td>vector</td>
</tr>
</tbody>
</table>
</div>
<p>详见<code>4.5.2节序列容器</code></p>
<h3 id="4-5-容器种类"><a href="#4-5-容器种类" class="headerlink" title="4.5 容器种类"></a>4.5 容器种类</h3><p>STL具有容器概念和容器类型。概念是具有名称（如容器、序列容器、关联容器等）的通用类别；容器类型是可用于创建具体容器对象的模板，有<code>deque</code>，<code>stack</code>等等。</p>
<h4 id="4-5-1-基本容器"><a href="#4-5-1-基本容器" class="headerlink" title="4.5.1 基本容器"></a>4.5.1 基本容器</h4><p>所有的容器都提供某些特征和操作，以下是一些基本的容器特征：</p>
<ul>
<li><code>X</code>表示容器类型，如 <code>vector</code></li>
<li><code>T</code>表示存储在容器中的对象类型；</li>
<li><code>a</code>和<code>b</code>表示类型为<code>X</code>的值；</li>
<li><code>r</code>表示类型为<code>X&amp;</code>的值；</li>
<li><code>u</code>表示类型为<code>X</code>的标识符（即如果X表示 <code>vector&lt;int&gt;</code>，则u是一个<code>vector&lt;int&gt;</code>对象）。</li>
</ul>
<blockquote>
<p>容器通用操作</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114153204223.png" alt="image-20230114153204223"></p>
<h4 id="4-5-2-序列容器"><a href="#4-5-2-序列容器" class="headerlink" title="4.5.2 序列容器"></a>4.5.2 序列容器</h4><p>可以通过添加要求来改进基本的容器概念。序列是一种重要的改进，这种容器的概念称为序列容器。</p>
<p>序列要求：</p>
<ul>
<li>迭代器至少是正向迭代器（正向、双向或随机的一种）</li>
<li>容器元素按严格的线性顺序排列（有前驱和后继）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114153905272.png" alt="image-20230114153905272"></p>
<p>模板类<code>deque</code>，<code>list</code>，<code>queue</code>，<code>priority_queue</code>，<code>stack</code>和<code>vector</code>都是序列概念的模型。它们都支持上表中的操作，此外某些容器还有额外的操作可支持：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114154120007.png" alt="image-20230114154120007"></p>
<h5 id="①-vector"><a href="#①-vector" class="headerlink" title="① vector"></a>① vector</h5><p>该模板类在<code>&lt;vector&gt;</code>头文件中声明。</p>
<p>vector 是数组的一种类表示，它提供了自动内存管理功能，可以动态地改变vector对象的长度，并随着元素的添加和删除而增大和缩小。它提供了对元素的随机访问。在尾部添加和删除元素的时间是固定的，但在头部或中间插入和删除元素的复杂度为线性时间。</p>
<p>除序列外，vector还是可反转容器（reversible container）概念的模型。这增加了两个类方法：<code>rbegin</code>和<code>rend</code>，前者返回一个指向反转序列的第一个元素的迭代器，后者返回反转序列的超尾迭代器。因此，如果dice是一个<code>vector&lt;int&gt;</code>容器，而<code>Show(int)</code>是显示一个整数的函数，则下面的代码将首先正向显示dice的内容，然后反向显示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(dice.<span class="built_in">begin</span>(), dice.<span class="built_in">end</span>(), Show); <span class="comment">// 正向显示</span></span><br><span class="line">for_each(dice.<span class="built_in">rbegin</span>(), dice.<span class="built_in">rend</span>(), Show); <span class="comment">// 反向显示</span></span><br></pre></td></tr></table></figure>
<h5 id="②-deque"><a href="#②-deque" class="headerlink" title="② deque"></a>② deque</h5><p>在<code>&lt;deque&gt;</code>中声明，表示双端队列<code>double-ended queue</code>。</p>
<p>在STL中，其实现类似于vector容器，支持随机访问。主要区别在于，从deque对象的开始位置插入和删除元素的时间是固定（常数时间复杂度）的，而不像 vector 中那样是线性时间的。所以，<strong>如果多数操作发生在序列的起始和结尾处，则应考虑使用deque数据结构</strong>。</p>
<p>为实现在 deque 两端执行插入和删除操作的时间为固定的这一目的，deque 对象的设计比 vector 对象更为复杂。因此，尽管二者都提供对元素的随机访问和在序列中部执行线性时间的插入和删除操作，但vector容器执行这些操作时速度要快些。</p>
<h5 id="③-list"><a href="#③-list" class="headerlink" title="③ list"></a>③ list</h5><p>在<code>&lt;list&gt;</code>中声明，表示双向链表。</p>
<p>除了第一个和最后一个元素外，每个元素都与前后的元素相链接，这意味着可以双向遍历链表。list和 vector 之间关键的区别在于，list 在链表中任一位置进行插入和删除的时间都是固定的（vector 模板提供了除结尾处外的线性时间的插入和删除，在结尾处，它提供了固定时间的插入和删除）。因此，vector强调的是通过随机访问进行快速访问，<strong>而 list 强调的是元素的快速插入和删除</strong>。</p>
<p>与vector相似，list也是可反转容器。与vector不同的是，<strong>list不支持数组表示法和随机访问</strong>。</p>
<p>此外，list模板类还提供了专用的成员函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114155700147.png" alt="image-20230114155700147"></p>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list.cpp -- using a list</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outint</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">one</span><span class="params">(<span class="number">5</span>, <span class="number">2</span>)</span></span>; <span class="comment">// list of 5 2s</span></span><br><span class="line">    <span class="keyword">int</span> stuff[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    list&lt;<span class="keyword">int</span>&gt; two;</span><br><span class="line">    two.<span class="built_in">insert</span>(two.<span class="built_in">begin</span>(),stuff, stuff + <span class="number">5</span> );</span><br><span class="line">    <span class="keyword">int</span> more[<span class="number">6</span>] = &#123;<span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">list&lt;<span class="keyword">int</span>&gt; <span class="title">three</span><span class="params">(two)</span></span>;</span><br><span class="line">    three.<span class="built_in">insert</span>(three.<span class="built_in">end</span>(), more, more + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">    for_each(one.<span class="built_in">begin</span>(),one.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List two: &quot;</span>;</span><br><span class="line">    for_each(two.<span class="built_in">begin</span>(), two.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">remove</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three minus 2s: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">splice</span>(three.<span class="built_in">begin</span>(), one);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after splice: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List one: &quot;</span>;</span><br><span class="line">    for_each(one.<span class="built_in">begin</span>(), one.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">unique</span>();</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after unique: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    three.<span class="built_in">sort</span>();</span><br><span class="line">    three.<span class="built_in">unique</span>();</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;List three after sort &amp; unique: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    two.<span class="built_in">sort</span>();</span><br><span class="line">    three.<span class="built_in">merge</span>(two);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Sorted two merged into three: &quot;</span>;</span><br><span class="line">    for_each(three.<span class="built_in">begin</span>(), three.<span class="built_in">end</span>(), outint);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114160247596.png" alt="image-20230114160247596"></p>
<h5 id="④-forward-list"><a href="#④-forward-list" class="headerlink" title="④ forward_list"></a>④ forward_list</h5><p>表示单向链表。不可反转，提供正向迭代器。</p>
<h5 id="⑤-queue"><a href="#⑤-queue" class="headerlink" title="⑤ queue"></a>⑤ queue</h5><p>在<code>&lt;queue&gt;</code>中声明，是一个适配器类，它让底层类（默认为<code>deque</code>）展示典型的队列接口。</p>
<p>queue模板的限制比deque更多。它不仅不允许随机访问队列元素，甚至不允许遍历队列（没有迭代器）。</p>
<p>它把使用限制在定义队列的基本操作上，可以将元素添加到队尾、从队首删除元素、查看队首和队尾的值、检查元素数目和测试队列是否为空。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230114160513159.png" alt="image-20230114160513159"></p>
<p>注意pop函数没有返回值，如果要取得队首元素，需要先使用front来取得队首元素，再用pop删除。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li>创建一个空的 queue 容器适配器，其底层使用的基础容器选择默认的 deque 容器：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>&gt; values;</span><br></pre></td></tr></table></figure>
<ul>
<li>也可以手动指定 queue 容器适配器底层采用的基础容器类型。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;&gt; values;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用基础容器来初始化 queue 容器适配器，只要该容器类型和 queue 底层使用的基础容器类型相同即可。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;<span class="keyword">int</span>&gt; values&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">my_queue</span><span class="params">(values)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 queue 容器适配器</span></span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; values&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">    <span class="function">queue&lt;<span class="keyword">int</span>&gt; <span class="title">my_queue</span><span class="params">(values)</span></span>; <span class="comment">//&#123;1,2,3&#125;</span></span><br><span class="line">    <span class="comment">//查看 my_queue 存储元素的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of my_queue: &quot;</span> &lt;&lt; my_queue.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//访问 my_queue 中的元素</span></span><br><span class="line">    <span class="keyword">while</span> (!my_queue.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; my_queue.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//访问过的元素出队列</span></span><br><span class="line">        my_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">size of my_queue: 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h5 id="⑥-priority-queue"><a href="#⑥-priority-queue" class="headerlink" title="⑥ priority_queue"></a>⑥ priority_queue</h5><p>在<code>&lt;queue&gt;</code>中声明，是一个容器适配器类，默认的底层类为<code>vector</code>。</p>
<p>优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。底层是通过<strong>堆</strong>来实现的。</p>
<p>特性：<code>First in, Largest out</code></p>
<p>可以修改用于确定哪个元素放到队首的比较方式，方法是提供一个可选的构造函数参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq1; <span class="comment">// default version</span></span><br><span class="line"><span class="function">priority_queue&lt;<span class="keyword">int</span>&gt; <span class="title">pq2</span><span class="params">(greater&lt;<span class="keyword">int</span>&gt;)</span></span>; <span class="comment">// use greater&lt;int&gt; to order 小根堆</span></span><br></pre></td></tr></table></figure>
<p>支持的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>q.top()</code></td>
<td style="text-align:left">访问队首元素</td>
</tr>
<tr>
<td style="text-align:left"><code>q.push()</code></td>
<td style="text-align:left">入队</td>
</tr>
<tr>
<td style="text-align:left"><code>q.pop()</code></td>
<td style="text-align:left">堆顶（队首）元素出队</td>
</tr>
<tr>
<td style="text-align:left"><code>q.size()</code></td>
<td style="text-align:left">队列元素个数</td>
</tr>
<tr>
<td style="text-align:left"><code>q.empty()</code></td>
<td style="text-align:left">是否为空</td>
</tr>
<tr>
<td style="text-align:left"><strong>注意</strong>没有<code>clear()</code>！</td>
<td style="text-align:left">不提供该方法</td>
</tr>
<tr>
<td style="text-align:left">优先队列只能通过<code>top()</code>访问队首元素（优先级最高的元素）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个空的priority_queue容器适配器</span></span><br><span class="line">    std::priority_queue&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    <span class="comment">//使用 push() 成员函数向适配器中添加元素</span></span><br><span class="line">    values.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="number">4</span>);</span><br><span class="line">    values.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//遍历整个容器适配器</span></span><br><span class="line">    <span class="keyword">while</span> (!values.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//输出第一个元素并移除。</span></span><br><span class="line">        std::cout &lt;&lt; values.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        values.<span class="built_in">pop</span>();<span class="comment">//移除队头元素的同时，将剩余元素中优先级最大的移至队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure>
<h5 id="⑦-stack"><a href="#⑦-stack" class="headerlink" title="⑦ stack"></a>⑦ stack</h5><p>在<code>&lt;stack&gt;</code>中声明，是一个容器适配器类，默认底层类为<code>vector</code>。stack的限制和queue相同。</p>
<p>支持的操作如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115111322921.png" alt="image-20230115111322921"></p>
<p>和queue相同，pop没有返回值。</p>
<h5 id="⑧-array"><a href="#⑧-array" class="headerlink" title="⑧ array"></a>⑧ array</h5><p>在<code>&lt;array&gt;</code>中声明，C++11标准，并非STL容器。</p>
<h4 id="4-5-3-关联容器"><a href="#4-5-3-关联容器" class="headerlink" title="4.5.3 关联容器"></a>4.5.3 关联容器</h4><p>关联容器是对容器概念的另一个改进。关联容器将值与键关联在一起，并使用键来查找值。</p>
<p>关联容器带有模板参数<code>Key</code>和<code>Compare</code>，这两个参数分别表示用来对内容进行排序的键类型和用于对键进行比较的函数对象（被称为比较对象），后者的默认参数为<code>less</code>，即按升序排序。</p>
<ul>
<li><p>对于set和multiset容器，存储的键就是存储的值，因此键类型与值类型相同。</p>
</li>
<li><p>对于map和multimap容器，存储的值（模板参数T）与键类型（模板参数Key）相关联，<strong>值类型</strong>为 <code>pair&lt;const Key, T&gt;</code>。</p>
</li>
</ul>
<p>注意，关联容器中存储的元素，就是一个个的pair类（键值对）的对象。迭代器指向的关联容器元素，就是容器中的pair对象。</p>
<p>关联容器的优点在于，<strong>它提供了对元素的快速访问</strong>。与序列相似，关联容器也允许插入新元素，但<strong>不能指定元素的插入位置</strong>。原因是关联容器通常有用于确定数据放置位置的算法，以便能够快速检索信息。</p>
<p><strong>关联容器通常是使用某种树实现的（例如红黑树）</strong>。树是一种数据结构，其根节点链接到一个或两个节点，而这些节点又链接到一个或两个节点，从而形成分支结构。像链表一样，节点使得添加或删除数据项比较简单；但相对于链表，树的查找速度更快。</p>
<p>C++ STL 标准库提供了 4 种关联式容器，分别为 <code>map</code>、<code>set</code>、<code>multimap</code>、<code>multiset</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>定义在 <code>&lt;map&gt;</code> 头文件中，使用该容器存储的数据，其各个元素的键必须是唯一的（即不能重复），该容器会根据各元素键的大小，<strong>默认进行升序排序</strong>（调用 <code>std::less&lt;T&gt;</code>）。</td>
</tr>
<tr>
<td>set</td>
<td>定义在 <code>&lt;set&gt;</code> 头文件中，使用该容器存储的数据，各个元素键和值完全相同，且各个元素的值不能重复（保证了各元素键的唯一性）。该容器会自动根据各个元素的键（其实也就是元素值）的大小进行升序排序（调用 <code>std::less&lt;T&gt;</code>）。</td>
</tr>
<tr>
<td>multimap</td>
<td>定义在 <code>&lt;map&gt;</code> 头文件中，和 map 容器唯一的不同在于，multimap 容器中存储元素的键可以重复。</td>
</tr>
<tr>
<td>multiset</td>
<td>定义在 <code>&lt;set&gt;</code> 头文件中，和 set 容器唯一的不同在于，multiset 容器中存储元素的值可以重复（一旦值重复，则意味着键也是重复的）。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="①-pair"><a href="#①-pair" class="headerlink" title="① pair"></a>① pair</h5><p>上面提到，对于map和multimap，键值对中的值的类型为<code>pair&lt;const Key, T&gt;</code>，即由key的类型和T的类型组成的pair类型。</p>
<p>pair 类模板定义在<code>&lt;utility&gt;</code>头文件中。成员为<code>first</code>和<code>second</code>，可以分别表示键和值。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span>      <span class="comment">// pair</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用构造函数 1，也就是默认构造函数</span></span><br><span class="line">    pair &lt;string, <span class="keyword">double</span>&gt; pair1;</span><br><span class="line">    <span class="comment">// 调用第 2 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair2</span>(<span class="string">&quot;STL教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);  </span><br><span class="line">    <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair3</span>(pair2);</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair4</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>));</span><br><span class="line">    <span class="comment">// 调用第 5 种构造函数</span></span><br><span class="line">    pair &lt;string, string&gt; <span class="built_in">pair5</span>(<span class="built_in">string</span>(<span class="string">&quot;Python教程&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>));  </span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair1: &quot;</span> &lt;&lt; pair1.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair1.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair2: &quot;</span>&lt;&lt; pair2.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair2.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair3: &quot;</span> &lt;&lt; pair3.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair3.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair4: &quot;</span> &lt;&lt; pair4.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair4.second &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pair5: &quot;</span> &lt;&lt; pair5.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pair5.second &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair1:  0</span><br><span class="line">pair2: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair3: STL教程 http://c.biancheng.net/stl/</span><br><span class="line">pair4: C++教程 http://c.biancheng.net/cplus/</span><br><span class="line">pair5: Python教程 http://c.biancheng.net/python/</span><br></pre></td></tr></table></figure>
<h5 id="②-map"><a href="#②-map" class="headerlink" title="② map"></a>② map</h5><p>函数方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>begin()</code></td>
<td>返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。</td>
</tr>
<tr>
<td><code>end()</code></td>
<td>返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 begin() 结合使用。</td>
</tr>
<tr>
<td><code>find(key)</code></td>
<td>在 map 容器中查找键为 key 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 end() 方法一样的迭代器。</td>
</tr>
<tr>
<td><code>lower_bound(key)</code></td>
<td>返回一个指向当前 map 容器中第一个大于或等于 key 的键值对的双向迭代器。</td>
</tr>
<tr>
<td><code>upper_bound(key)</code></td>
<td>返回一个指向当前 map 容器中第一个大于 key 的键值对的迭代器。</td>
</tr>
<tr>
<td><code>operator[key]</code></td>
<td>map容器重载了 <code>[]</code> 运算符，只要知道 map 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。例如<code>m[key]</code></td>
</tr>
<tr>
<td><code>at(key)</code></td>
<td>找到 map 容器中 key 键对应的值，如果找不到，该函数会引发 out_of_range 异常。</td>
</tr>
<tr>
<td><code>insert()</code></td>
<td>向 map 容器中插入键值对。需要构造键值对。使用<code>pair</code>。</td>
</tr>
<tr>
<td>`erase(key</td>
<td>iter)`</td>
<td>删除 map 容器指定位置、指定键（key）值或者指定区域内的键值对。左闭右开。</td>
</tr>
<tr>
<td><code>emplace()</code></td>
<td>在当前 map 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>添加元素</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 1为key，1为value</span></span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">mp.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 方式3</span></span><br><span class="line">mp.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span>      <span class="comment">// map</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>       <span class="comment">// string</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">    std::map&lt;std::string, std::string, std::greater&lt;std::string&gt;&gt;myMap;</span><br><span class="line">    <span class="comment">//调用 emplace() 方法，直接向 myMap 容器中指定位置构造新键值对</span></span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;C语言教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/c/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    myMap.<span class="built_in">emplace</span>(<span class="string">&quot;STL教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/stl/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出当前 myMap 容器存储键值对的个数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;myMap size==&quot;</span> &lt;&lt; myMap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前 myMap 容器是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!myMap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">//借助 myMap 容器迭代器，将该容器的键值对逐个输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = myMap.<span class="built_in">begin</span>(); i != myMap.<span class="built_in">end</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; i-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i-&gt;second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myMap size==3</span><br><span class="line">STL教程 http://c.biancheng.net/stl/</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">C语言教程 http://c.biancheng.net/c/</span><br></pre></td></tr></table></figure>
<h5 id="③-set"><a href="#③-set" class="headerlink" title="③ set"></a>③ set</h5><p>略</p>
<h4 id="4-5-4-无序关联容器"><a href="#4-5-4-无序关联容器" class="headerlink" title="4.5.4 无序关联容器"></a>4.5.4 无序关联容器</h4><p>无序关联容器（或称哈希容器）是对容器概念的另一种改进。</p>
<p>与关联容器一样，无序关联容器也将值与键关联起来，并使用键来查找值。但底层的差别在于，关联容器是基于树结构的，而无序关联容器是基于数据结构<strong>哈希表</strong>的，这旨在提高添加和删除元素的速度以及提高查找算法的效率。</p>
<p>C++ STL 底层采用哈希表实现无序容器时，会将所有数据存储到一整块连续的内存空间中，并且当数据存储位置发生冲突时，解决方法选用的是“链地址法”（又称“开链法”）。</p>
<p>特点：</p>
<ul>
<li>无序容器内部存储的键值对是无序的，各键值对的存储位置取决于该键值对中的键，</li>
<li>和关联式容器相比，无序容器擅长通过指定键查找对应的值（平均时间复杂度为 O(1)）；但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li>
</ul>
<p>有4种无序关联容器，它们是<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered map</code> 和 <code>unordered multimap</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>存储键值对 <code>&lt;key, value&gt;</code> 类型的元素，其中各个键值对键的值不允许重复，且该容器中存储的键值对是无序的。</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>和 unordered_map 唯一的区别在于，该容器允许存储多个键相同的键值对。</td>
</tr>
<tr>
<td>unordered_set</td>
<td>不再以键值对的形式存储数据，而是直接存储数据元素本身（当然也可以理解为，该容器存储的全部都是键 key 和值 value 相等的键值对，正因为它们相等，因此只存储 value 即可）。另外，该容器存储的元素不能重复，且容器内部存储的元素也是无序的。</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>和 unordered_set 唯一的区别在于，该容器允许存储值相同的元素。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="①-unordered-map"><a href="#①-unordered-map" class="headerlink" title="① unordered_map"></a>① unordered_map</h5><p>在<code>&lt;unordered_map&gt;</code>中声明。</p>
<p>unordered_map 容器不会像 map 容器那样对存储的数据进行排序。换句话说，unordered_map 容器和 map 容器仅有一点不同，即 map 容器中存储的数据是有序的，而 unordered_map 容器中是无序的。</p>
<p>常用方法：同<code>map</code></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建空 umap 容器</span></span><br><span class="line">    unordered_map&lt;string, string&gt; umap;</span><br><span class="line">    <span class="comment">//向 umap 容器添加新键值对</span></span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Python教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Java教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>);</span><br><span class="line">    umap.<span class="built_in">emplace</span>(<span class="string">&quot;Linux教程&quot;</span>, <span class="string">&quot;http://c.biancheng.net/linux/&quot;</span>);</span><br><span class="line">    <span class="comment">//输出 umap 存储键值对的数量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;umap size = &quot;</span> &lt;&lt; umap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用迭代器输出 umap 容器存储的所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = umap.<span class="built_in">begin</span>(); iter != umap.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">umap size = 3</span><br><span class="line">Python教程 http://c.biancheng.net/python/</span><br><span class="line">Linux教程 http://c.biancheng.net/linux/</span><br><span class="line">Java教程 http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<h5 id="②-unordered-set"><a href="#②-unordered-set" class="headerlink" title="② unordered_set"></a>② unordered_set</h5><p>略</p>
<h2 id="5-函数对象"><a href="#5-函数对象" class="headerlink" title="5 函数对象"></a>5 函数对象</h2><h3 id="5-1-简介"><a href="#5-1-简介" class="headerlink" title="5.1 简介"></a>5.1 简介</h3><p>很多STL算法都使用函数对象——也叫函数符（functor）、仿函数。</p>
<p>函数符是可以以函数方式与<code>()</code>结合使用的任意对象。这包括函数名、指向函数的指针和重载了<code>()</code>运算符的类对象（即定义了函数<code>operator()</code>）的类），例如，可以像这样定义一个类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linear</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> slope;</span><br><span class="line">    <span class="keyword">double</span> y0;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Linear</span>(<span class="keyword">double</span> sl_ = <span class="number">1</span>, <span class="keyword">double</span> y_ = <span class="number">0</span>) : <span class="built_in">slope</span>(sl_), <span class="built_in">y0</span>(y_) &#123;&#125;</span><br><span class="line">    <span class="comment">// 提供对()的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> y0 + slope * x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于重载的<code>()</code>运算符，使得能够像函数一样使用Linear的对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Linear f1;</span><br><span class="line"><span class="function">Linear <span class="title">f2</span><span class="params">(<span class="number">2.5</span>, <span class="number">10.0</span>)</span></span>;</span><br><span class="line"><span class="comment">// 此时的f1（重载了括号运算符的类对象）为函数符</span></span><br><span class="line"><span class="keyword">double</span> y1 = <span class="built_in">f1</span>(<span class="number">12.5</span>);</span><br><span class="line"><span class="keyword">double</span> y2 = <span class="built_in">f2</span>(<span class="number">0.4</span>);  </span><br></pre></td></tr></table></figure>
<p>对于<code>for_each</code>，它将指定的函数应用于区间中的每个成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), ShowReview);</span><br></pre></td></tr></table></figure>
<p>函数将第三个参数（函数）设置为模板参数（因为可能为函数指针或函数符），其函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class InputIterator, class Function&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator first, InputIterator last, Function f)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ShowReview的原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowReview</span><span class="params">(<span class="keyword">const</span> Review &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样赋给模板参数<code>Function</code>的类型为<code>void(*)(const Review &amp;)</code>。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;num, Function f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="comment">// 将f作用于num[i]上</span></span><br><span class="line">        <span class="built_in">f</span>(num[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个函数符, 输出数组中的每个元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Output</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对()重载，使得对象可以成为函数那样被调用——仿函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">num</span><span class="params">(&amp;a[<span class="number">0</span>], &amp;a[<span class="number">5</span>])</span></span>;</span><br><span class="line">    Output out;</span><br><span class="line">    <span class="built_in">process</span>(num, out);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-函数符概念"><a href="#5-2-函数符概念" class="headerlink" title="5.2 函数符概念"></a>5.2 函数符概念</h3><p>正如STL定义了容器和迭代器的概念一样，它也定义了函数符概念。</p>
<ul>
<li>生成器（generator）是不用参数就可以调用的函数符</li>
<li>一元函数（unary function）是用一个参数可以调用的函数符</li>
<li>二元函数（binary function）是用两个参数可以调用的函数符。</li>
</ul>
<p>例如，提供给 <code>for_each</code>的函数符应当是一元函数，因为它每次用于一个容器元素。</p>
<p>当然，这些概念都有相应的改进版：</p>
<ul>
<li>返回bool值的一元函数是谓词（predicate）；</li>
<li>返回bool值的二元函数是二元谓词（binary predicate）。</li>
</ul>
<p>一些STL函数需要谓词参数或二元谓词参数。例如，使用了<code>sort</code>的这样一个版本，即将二元谓词作为其第3个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元谓词</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WorseThan</span><span class="params">(<span class="keyword">const</span> Review &amp;, <span class="keyword">const</span> Review &amp;)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">sort</span>(books.<span class="built_in">begin</span>(), books.<span class="built_in">end</span>(), WorseThan);</span><br></pre></td></tr></table></figure>
<h3 id="5-3-预定义的函数符"><a href="#5-3-预定义的函数符" class="headerlink" title="5.3 预定义的函数符"></a>5.3 预定义的函数符</h3><blockquote>
<p>引入</p>
</blockquote>
<p>例如，考虑函数<code>transform</code>。它有两个版本。</p>
<p>第一个版本将接收四个参数，前两个指定区间的迭代器，第三个是指定将结果复制到哪里的迭代器，最后一个参数是一个函数符，为一元函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LIM = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">double</span> arr1[LIM] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">double</span>&gt; <span class="title">gr8</span><span class="params">(arr1, arr1 + LIM)</span></span>;</span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">double</span>, <span class="keyword">char</span>&gt; <span class="title">out</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(), gr8.<span class="built_in">end</span>(), out, sqrt);</span><br></pre></td></tr></table></figure>
<p>上述代码计算每个元素的平方根，并将结果发送到输出流。目标迭代器可以位于原始区间中。例如，将上述示例中的out替换为<code>gr8.begin</code>后，新值将覆盖原来的值。很明显，使用的函数符必须是接受单个参数的函数符。</p>
<p>第二种版本使用一个接受两个参数的函数，并将该函数用于两个区间中元素。它用另一个参数（即第3个）标识第二个区间的起始位置。例如，如果 m8 是另一个<code>vector&lt;double&gt;</code>对象，<code>mean(double, double)</code>返回两个值的平均值，则下面的的代码将输出来自gr8和m8的值的平均值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(), gr8.<span class="built_in">end</span>(), m8.<span class="built_in">begin</span>(), out, mean);</span><br></pre></td></tr></table></figure>
<p>现在假设要将两个数组相加。不能将<code>+</code>作为参数，因为对于类型double来说，<code>+</code>是内置的运算符，而不是函数。可以定义一个将两个数相加的函数，然后使用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(), gr8.<span class="built_in">end</span>(), m8.<span class="built_in">begin</span>(), out, add);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>介绍</p>
</blockquote>
<p>STL定义了多个基本函数符，它们执行诸如将两个值相加、比较两个值是否相等操作。提供这些函数对象是为了支持将函数作为参数的STL函数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230115144724308.png" alt="image-20230115144724308"></p>
<p>可以使用<code>plus&lt;&gt;</code>类来完成常规的相加运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span> <span class="comment">// 提供plus&lt;&gt;的声明</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">plus&lt;<span class="keyword">double</span>&gt; add; <span class="comment">// 声明一个plus&lt;double&gt;的对象</span></span><br><span class="line"><span class="keyword">double</span> y = <span class="built_in">add</span>(<span class="number">2.2</span>, <span class="number">3.4</span>);</span><br><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(), gr8.<span class="built_in">end</span>(), m8.<span class="built_in">begin</span>(), out, add);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">transform</span>(gr8.<span class="built_in">begin</span>(), gr8.<span class="built_in">end</span>(), m8.<span class="built_in">begin</span>(), out, plus&lt;<span class="keyword">double</span>&gt;());</span><br><span class="line"><span class="comment">// ()是默认构造，即调用默认构造函数，创建一个匿名对象传入</span></span><br></pre></td></tr></table></figure>
<p>C++11提供了函数指针和函数符的替代品——lambda表达式。</p>
<hr>
<p>之前介绍过的<code>map</code>和<code>priority_queue</code>，在构造时，可以指定排序的规则，可以使用预定义的函数符。或者一些排序算法，例如<code>sort</code>也会用到。</p>
<p>以优先队列和map为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">// 默认大根堆, 即每次取出的元素是队列中的最大值</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">// 小根堆, 每次取出的元素是队列中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建空 map 容器，默认根据个键值对中键的值，对键值对做降序排序</span></span><br><span class="line">map&lt;string, string, greater&lt;string&gt; &gt; myMap;</span><br></pre></td></tr></table></figure>
<p>以排序为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 升序排列</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span>(iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); iter++) &#123;</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-算法"><a href="#6-算法" class="headerlink" title="6 算法"></a>6 算法</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/STL/">STL</a></div><div class="post_share"><div class="social-share" data-image="/img/stl.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/10/%E3%81%95%E3%82%88%E3%81%AA%E3%82%89%E7%B5%B6%E6%9C%9B%E5%85%88%E7%94%9F/"><img class="prev-cover" src="/img/zetubousensei.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">さよなら絶望先生</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/C++.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++学习笔记"><img class="cover" src="/img/C++.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">C++学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">C++标准模板库学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-STL%E7%AE%80%E4%BB%8B"><span class="toc-text">0 STL简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">0.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-2-STL%E7%BB%84%E6%88%90"><span class="toc-text">0.2 STL组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-string%E7%B1%BB"><span class="toc-text">1 string类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%9E%84%E9%80%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.1 构造字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-string%E7%B1%BB%E8%BE%93%E5%85%A5"><span class="toc-text">1.2 string类输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.3 使用字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1.3.1 比较字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">1.3.2 字符串长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E6%90%9C%E7%B4%A2%E5%AD%90%E4%B8%B2%E5%92%8C%E5%AD%97%E7%AC%A6"><span class="toc-text">1.3.3 搜索子串和字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E6%B1%82%E5%AD%90%E4%B8%B2"><span class="toc-text">1.3.4 求子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A7%8D%E7%B1%BB"><span class="toc-text">1.4 字符串种类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">2 智能指针模板类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-text">3 标准模板库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%A8%A1%E6%9D%BF%E7%B1%BBvector"><span class="toc-text">3.1 模板类vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%AF%E5%AF%B9vector%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">3.2 可对vector执行的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">3.3 其他操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF"><span class="toc-text">3.4 基于范围的for循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">4 泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-text">4.1 迭代器的必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.2 迭代器类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E8%BE%93%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.2.1 输入迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E8%BE%93%E5%87%BA%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.2.2 输出迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%AD%A3%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.2.3 正向迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%8F%8C%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.2.4 双向迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-5-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.2.5 随机访问迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">4.3 迭代器层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%A6%82%E5%BF%B5%E3%80%81%E6%94%B9%E8%BF%9B%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.4 概念、改进和类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E9%A2%84%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">4.4.1 预定义迭代器类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-text">4.4.2 容器适配器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%AE%B9%E5%99%A8%E7%A7%8D%E7%B1%BB"><span class="toc-text">4.5 容器种类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8"><span class="toc-text">4.5.1 基本容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-text">4.5.2 序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-vector"><span class="toc-text">① vector</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-deque"><span class="toc-text">② deque</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-list"><span class="toc-text">③ list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3-forward-list"><span class="toc-text">④ forward_list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4-queue"><span class="toc-text">⑤ queue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A5-priority-queue"><span class="toc-text">⑥ priority_queue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A6-stack"><span class="toc-text">⑦ stack</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A7-array"><span class="toc-text">⑧ array</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">4.5.3 关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-pair"><span class="toc-text">① pair</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-map"><span class="toc-text">② map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2-set"><span class="toc-text">③ set</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-4-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-text">4.5.4 无序关联容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0-unordered-map"><span class="toc-text">① unordered_map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1-unordered-set"><span class="toc-text">② unordered_set</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-text">5 函数对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%AE%80%E4%BB%8B"><span class="toc-text">5.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E7%AC%A6%E6%A6%82%E5%BF%B5"><span class="toc-text">5.2 函数符概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%87%BD%E6%95%B0%E7%AC%A6"><span class="toc-text">5.3 预定义的函数符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AE%97%E6%B3%95"><span class="toc-text">6 算法</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>