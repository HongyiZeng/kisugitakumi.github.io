<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++学习笔记 | Kisugi Takumi</title><meta name="keywords" content="C++"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2023/01/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="C++学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/C++.png">
<meta property="article:published_time" content="2023-01-01T06:46:25.000Z">
<meta property="article:modified_time" content="2023-01-15T11:41:35.509Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/C++.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2023/01/01/C++%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-15 19:41:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">97</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">77</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li><li><a class="site-page child" href="/songs/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-01T06:46:25.000Z" title="发表于 2023-01-01 14:46:25">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-15T11:41:35.509Z" title="更新于 2023-01-15 19:41:35">2023-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">35.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>143分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="C-学习笔记"><a href="#C-学习笔记" class="headerlink" title="C++学习笔记"></a>C++学习笔记</h1><p>学习时间：2023年1月1日</p>
<p>学习来源：C++ primer plus 中文版第六版</p>
<h2 id="1-IDE环境搭建"><a href="#1-IDE环境搭建" class="headerlink" title="1 IDE环境搭建"></a>1 IDE环境搭建</h2><p>我使用的IDE：Clion</p>
<p>编译器：Visual Studio 也可以使用MinGW</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20220929205829608.png" alt="image-20220929205829608"></p>
<h2 id="2-快速开始"><a href="#2-快速开始" class="headerlink" title="2 快速开始"></a>2 快速开始</h2><h3 id="2-1-一个简单的C-程序"><a href="#2-1-一个简单的C-程序" class="headerlink" title="2.1 一个简单的C++程序"></a>2.1 一个简单的C++程序</h3><p>程序源文件命名约定：不同编译器使用不同后缀名，包括<code>.cc</code> <code>.cxx</code> <code>.cpp</code> <code>.cp</code>以及<code>.C</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用GNU或微软编译器</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img18/image-20220929212105735.png" alt="image-20220929212105735"></p>
<p>假设 main 程序在名为 <code>main.cpp</code> 的文件中，可以使用如下命令来编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl main.cpp -o main <span class="comment"># 微软编译器采用命令 cl 来调用，调用 GNU 编译器的默认命令是g++</span></span><br></pre></td></tr></table></figure>
<p><code>-o main</code> 是编译器参数以及用来存放可执行文件的文件名。如果省略，那么编译器在 UNIX 系统下产生名为 <code>a.out</code> 而在 Windows 下产生名为 <code>a.exe</code> 的可执行文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@HongyiZeng c++]<span class="comment"># make hello</span></span><br><span class="line">g++     hello.cpp   -o hello</span><br></pre></td></tr></table></figure>
<h3 id="2-2-初识输入输出"><a href="#2-2-初识输入输出" class="headerlink" title="2.2 初识输入输出"></a>2.2 初识输入输出</h3><p>C++ 并没有直接定义进行输入或输出（IO）的任何语句，这种功能是由<strong>标准库</strong>提供的。</p>
<p>本书的大多数例子都使用了处理格式化输入和输出的 <strong>iostream</strong> 库。iostream 库的基础是两种命名为 <strong>istream</strong> 和 <strong>ostream</strong> 的类型，分别表示输入流和输出流。</p>
<h4 id="2-2-1-标准输入与输出对象"><a href="#2-2-1-标准输入与输出对象" class="headerlink" title="2.2.1 标准输入与输出对象"></a>2.2.1 标准输入与输出对象</h4><p>标准库定义了 4 个 IO 对象。</p>
<ul>
<li>cin对象，这个对象也称为<strong>标准输入</strong></li>
<li>cout对象，这个对象也称为<strong>标准输出</strong>。</li>
<li>cerr 对象又叫作<strong>标准错误</strong>，通常用来输出警告和错误信息给程序的使用者。</li>
<li>clog 对象用于产生程序执行的一般信息。</li>
</ul>
<h4 id="2-2-2-程序实例"><a href="#2-2-2-程序实例" class="headerlink" title="2.2.2 程序实例"></a>2.2.2 程序实例</h4><p>要求用户给出两个数，然后输出它们的和：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预处理提示</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter two numbers: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">int</span> v1, v2;</span><br><span class="line">    std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#include &lt;iostream&gt;</code>告诉编译器要使用 iostream 库。尖括号里的名字是一个<strong>头文件</strong>。程序使用库工具时必须包含相关的头文件。相当于java中的<code>import</code>。</p>
<blockquote>
<p>写入到流</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p><code>&lt;&lt;</code>：输出操作符，：左操作数必须是 ostream 对象，右操作数是要输出的值，当操作符是输出操作符时，结果是左操作数的值。也就是说，输出操作返回的值是输出流本身。 相当于java中的<strong>链式调用</strong>。</p>
<p>该语句等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p><code>endl</code>：操纵符，将它写入输出流时，具有<strong>输出换行</strong>的效果，并<strong>刷新与设备相关联的缓冲区</strong>。通过刷新缓冲区，用户可立即看到写入到流中的输出。</p>
<blockquote>
<p>使用标准库中的名字</p>
</blockquote>
<p>前缀 <code>std::</code> 表明 cout 和 endl 是定义在<strong>命名空间 std</strong> 中的。使用命名空间程序员可以避免与库中定义的名字相同而引起无意冲突。因为标准库定义的名字是定义在命名空间中，所以我们可以按自己的意图使用相同的名字。 </p>
<p><code>::</code>：作用域操作符，表示使用的是定义在命名空间 std 中的 cout</p>
<blockquote>
<p>读入流</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br></pre></td></tr></table></figure>
<p><code>&gt;&gt;</code>：输入操作符，它接受一个 istream 对象作为其左操作数，接受一个对象作为其右操作数，它从 istream 操作数读取数据并保存到右操作数中。同样也是链式调用。</p>
<p>等价于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::cin&gt;&gt; v1;</span><br><span class="line">std::cin&gt;&gt; v2;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-控制结构"><a href="#2-3-控制结构" class="headerlink" title="2.3 控制结构"></a>2.3 控制结构</h3><p>只展示代码，不做说明。</p>
<h4 id="2-3-1-while"><a href="#2-3-1-while" class="headerlink" title="2.3.1 while"></a>2.3.1 while</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (val &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">        ++val;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-for"><a href="#2-3-2-for" class="headerlink" title="2.3.2 for"></a>2.3.2 for</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val) &#123;</span><br><span class="line">        sum += val;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-if"><a href="#2-3-3-if" class="headerlink" title="2.3.3 if"></a>2.3.3 if</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, val;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; val) &#123;</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += val;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Sum is &quot;</span> &lt;&lt; sum &lt;&lt;std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-变量和基本类型"><a href="#3-变量和基本类型" class="headerlink" title="3 变量和基本类型"></a>3 变量和基本类型</h2><h3 id="3-1-基本内置类型"><a href="#3-1-基本内置类型" class="headerlink" title="3.1 基本内置类型"></a>3.1 基本内置类型</h3><p>C++定义了<strong>算术类型和空类型</strong>在内的基本数据类型。</p>
<h4 id="3-1-1-算术类型"><a href="#3-1-1-算术类型" class="headerlink" title="3.1.1 算术类型"></a>3.1.1 算术类型</h4><p>算术类型分为：<strong>整型</strong>（包括字符和布尔类型）和<strong>浮点型</strong>。</p>
<p>算术类型的尺寸（也就是该类型数据所占的比特数）在不同机器上有所差别。下表列出了C++标准规定的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img20/image-20221222111257985.png" alt="image-20221222111257985"></p>
<blockquote>
<p>字符类型</p>
</blockquote>
<p>基本的字符类型是<code>char</code>，占一个字节，8个比特位。</p>
<p>其他的字符类型可用于扩展字符集，例如<code>wchar_t</code>，<code>char16_t</code>和<code>char32_t</code>。</p>
<blockquote>
<p>其它整型</p>
</blockquote>
<p>C++规定：</p>
<ul>
<li><code>int</code>至少和<code>short</code>一样大</li>
<li><code>long</code>至少和<code>int</code>一样大</li>
<li><code>long long</code>至少和<code>long</code>一样大</li>
</ul>
<blockquote>
<p>浮点型</p>
</blockquote>
<p>浮点型可表示单精度、双精度和扩展精度值。</p>
<p>C++标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。</p>
<p>通常，float以1个字来表示，double以2个字来表示，long double以3或4个字来表示。一般来说，类型float和double分别有7和16个有效位；类型long double则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。</p>
<blockquote>
<p>有符号和无符号</p>
</blockquote>
<p>除去布尔类型和扩展字符型，其它整型可以划分为有符号（<code>signed</code>，正负和0）和无符号（<code>unsigned</code>，0和正数）两种。</p>
<p>无符号类型中的所有比特位均用来存储值，例如8比特的<code>unsigned char</code>可以用来表示<code>0~255</code>。</p>
<p>标准中并未规定有符号类型应该如何表示，但是约定了在表示范围内正值和负值的量应该平衡，例如<code>signed char</code>可以表示<code>-127~127</code>，而大多数现代计算机将实际的表示范围定为<code>-128~127</code>。</p>
<blockquote>
<p>如何选择数据类型</p>
</blockquote>
<ul>
<li>当明确知晓数值不可能为负时，选用无符号类型。</li>
<li>使用int执行整数运算。在实际应用中，short常常显得太小而long一般和int有一样的尺寸。如果数值超过了int的表示范围，选用long long。</li>
<li>在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型 char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么<strong>明确指定</strong>它的类型是<code>signed char</code>或者<code>unsigned char</code>。</li>
<li>执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</li>
</ul>
<h4 id="3-1-2-类型转换"><a href="#3-1-2-类型转换" class="headerlink" title="3.1.2 类型转换"></a>3.1.2 类型转换</h4><p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="number">42</span>; <span class="comment">// b为真</span></span><br><span class="line"><span class="keyword">int</span> i = b; <span class="comment">// i = 1</span></span><br><span class="line">i = <span class="number">3.14</span>; <span class="comment">// i = 3</span></span><br><span class="line"><span class="keyword">double</span> pi = i; <span class="comment">// pi = 3.0</span></span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-1</span>; <span class="comment">// c = 255</span></span><br><span class="line"><span class="keyword">signed</span> <span class="keyword">char</span> c2 = <span class="number">256</span>; <span class="comment">// c2未定义</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>给无符号类型一个超出表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的<strong>余数</strong>。<ul>
<li>例如<code>unsigned char</code>可以表示<code>0~255</code>共256个数，则示例中<code>-1 % 256 = 255</code></li>
</ul>
</li>
<li>给有符号类型一个超出表示范围的值时，结果是未定义的（<code>undefined</code>）</li>
</ul>
<p>提示：不要混用有符号类型和无符号类型</p>
<h2 id="4-复合类型"><a href="#4-复合类型" class="headerlink" title="4 复合类型"></a>4 复合类型</h2><h3 id="4-1-命名空间"><a href="#4-1-命名空间" class="headerlink" title="4.1 命名空间"></a>4.1 命名空间</h3><h4 id="4-1-1-历史"><a href="#4-1-1-历史" class="headerlink" title="4.1.1 历史"></a>4.1.1 历史</h4><p>C++ 是在C语言的基础上开发的，早期的 C++ 还不完善，不支持命名空间，没有自己的编译器，而是将 C++ 代码翻译成C代码，再通过C编译器完成编译。这个时候的 C++ 仍然在使用C语言的库，stdio.h、stdlib.h、string.h 等头文件依然有效；此外 C++ 也开发了一些新的库，增加了自己的头文件，例如：</p>
<ul>
<li><code>iostream.h</code>：用于控制台输入输出头文件。</li>
<li><code>fstream.h</code>：用于文件操作的头文件。</li>
<li><code>complex.h</code>：用于复数计算的头文件。</li>
</ul>
<p>和C语言一样，C++ 头文件仍然以.h为后缀，它们所包含的<strong>类、函数、宏</strong>等都是全局范围的。</p>
<p>后来 C++ 引入了命名空间的概念，计划重新编写库，将<strong>类、函数、宏</strong>等都统一纳入一个命名空间，这个命名空间的名字就是std。std 是 standard 的缩写，意思是“<strong>标准命名空间</strong>”。</p>
<p>为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀<code>.h</code>，所以老式 C++ 的<code>iostream.h</code>变成了<code>iostream</code>，<code>fstream.h</code>变成了<code>fstream</code>。而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个<code>c</code>字母，所以C语言的<code>stdio.h</code>变成了<code>cstdio</code>，<code>stdlib.h</code>变成了<code>cstdlib</code>。</p>
<p>可以发现，对于不带<code>.h</code>的头文件，所有的符号（名字）都位于命名空间 std 中，使用时需要声明命名空间 std，这是 C++ 的做法；对于带<code>.h</code>的头文件，没有使用任何命名空间，所有符号都位于全局作用域，这是 C 的做法。</p>
<p>不过现实情况和 C++ 标准所期望的有些不同，对于原来C语言的头文件，即使按照 C++ 的方式来使用，即<code>#include &lt;cstdio&gt;</code>这种形式，那么符号可以位于命名空间 std 中，也可以位于全局范围中，请看下面的两段代码。</p>
<ul>
<li>使用命名空间std</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>); <span class="comment">// 标准写法，因为库函数都在命名空间std中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不使用std</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;http://c.biancheng.net\n&quot;</span>); <span class="comment">// 不标准，是C的写法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种形式在 Microsoft Visual C++ 和 GCC 下都能够编译通过，也就是说，大部分编译器在实现时并没有严格遵循C++标准，它们对两种写法都支持，程序员可以使用 std 也可以不使用。</p>
<p>第 1) 种写法是标准的，第 2) 种不标准，虽然它们在目前的编译器中都没有错误，但依然推荐使用第 1) 种写法，因为标准写法会一直被编译器支持，非标准写法可能会在以后的升级版本中不再支持。</p>
<hr>
<p>虽然 C++ 几乎完全兼容C语言，C语言的头文件在 C++ 中依然被支持，但 C++ 新增的库更加强大和灵活，<strong>请尽量使用这些 C++ 新增的头文件</strong>，例如 iostream、fstream、string 等，并使用标准命名空间。</p>
<h4 id="4-1-2-简介"><a href="#4-1-2-简介" class="headerlink" title="4.1.2 简介"></a>4.1.2 简介</h4><p>在C++中，名称（<code>name</code>，或名字）可以是符号常量、变量、函数、结构、枚举、类和对象等等。工程越大，名称互相冲突性的可能性越大。另外使用多个厂商的类库时，也可能导致名称冲突。</p>
<p>为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突，标准 C++ 引入关键字<code>namespace</code>（命名空间），可以更好地控制标识符的作用域。</p>
<p>作用：增加标识符的使用率，不同命名空间下允许相同的标识符（c语言在同一个作用域不允许定义相同的标识符，报错：重定义，多次初始化）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span>; <span class="comment">// 编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MM &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> GG &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>; <span class="comment">// 允许</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; MM::a &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; GG::a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3-使用语法"><a href="#4-1-3-使用语法" class="headerlink" title="4.1.3 使用语法"></a>4.1.3 使用语法</h4><ul>
<li>创建一个命名空间：<strong>命名空间只能在全局范围内定义</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123; <span class="comment">// 指定命名空间A</span></span><br><span class="line">    <span class="comment">// 花括号内为声明块</span></span><br><span class="line">    <span class="comment">// 声明的实体称为命名空间成员，其中包括变量（可以带有初始化）、常量、函数（可以是定义或声明）、结构体、类、模板、命名空间（在一个命名空间中又定义一个命名空间，即嵌套的命名空间）</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; <span class="comment">// 注意没有分号</span></span><br><span class="line"><span class="keyword">namespace</span> B &#123; <span class="comment">// 指定命名空间B</span></span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名空间限定：指使用的变量名前面加上命名空间名和域解析操作符<code>::</code>的用法。例如<code>A::a</code>表示使用命名空间<code>A</code>中的变量<code>a</code>。</p>
<ul>
<li>命名空间可以嵌套定义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">namespace</span> B&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl; <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无名命名空间，意味着命名空间中的标识符<strong>只能在本文件内访问</strong>，相当于给这个标识符加上了<code>static</code>，使得其可以作为内部连接</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; ::a &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">	<span class="built_in">func</span>(); <span class="comment">// hello namespace</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>命名空间可以起别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Television &#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">namespace</span> TV =Televison; <span class="comment">//别名TV指向原名Televison,在原来出现Television的位置都可以无条件使用TV代替</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a : &quot;</span> &lt;&lt; TV::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-4-using声明"><a href="#4-1-4-using声明" class="headerlink" title="4.1.4 using声明"></a>4.1.4 using声明</h4><p>使用<code>using</code>声明就可以无需专门的前缀（形如<code>命名空间::</code>）就可以使用该命名空间里的名字。</p>
<p>语法格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>using 命名空间::成员名</code>的形式</li>
</ul>
<p>注意using声明的有效范围是从using开始到using所在的作用域结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using声明，当使用名字cin时，会从命名空间std中获取它，该声明全局有效</span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    cout &lt;&lt; i; <span class="comment">// 错误，没有对应的using声明</span></span><br><span class="line">    std::cout &lt;&lt; i; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 必须重新声明，否则cout为未定义标识符</span></span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 只在main函数作用域中有效</span></span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">   </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>using namespace 命名空间</code>的形式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 声明命名空间std，后续如果有未指定命名空间的符号，那么默认使用 std，代码中的 string、cin、cout 都位于命名空间 std</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h3><p>略，详见C语言。</p>
<p>C++标准模板库（<code>STL</code>）提供了一种数组替代品——模板类<code>vector</code>，而C++11新增了模板类<code>array</code>。这些替代品比内置复合类型数组更复杂、更灵活。</p>
<h3 id="4-3-字符串"><a href="#4-3-字符串" class="headerlink" title="4.3 字符串"></a>4.3 字符串</h3><p>字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。</p>
<ul>
<li>第一种来自 C 语言，常被称为C-风格字符串（C-style string）</li>
<li>另一种基于<code>string类库</code>，详见<code>4.4节</code></li>
</ul>
<p>下略，详见C语言。</p>
<h3 id="4-4-string类"><a href="#4-4-string类" class="headerlink" title="4.4 string类"></a>4.4 string类</h3><h4 id="4-4-1-简介和初始化"><a href="#4-4-1-简介和初始化" class="headerlink" title="4.4.1 简介和初始化"></a>4.4.1 简介和初始化</h4><p>ISO/ANSI C++98标准通过添加 string类扩展了C++库，因此可以使用 string类型的变量（使用C++的话说是<strong>对象</strong>）而不是字符数组来存储字符串。</p>
<p>要使用string类，必须在程序中包含头文件<code>string</code>。string类位于名称空间<code>std</code>中，因此必须提供一条 using 编译指令，或者使用<code>std::string</code>来引用它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>头文件string，string.h和cstring的区别</p>
</blockquote>
<ul>
<li>string.h是c语言的库，用于处理<code>char *</code>类型的字符串。</li>
<li>string和cstring是c++标准库，位于std名字空间。string是c++标准库中的一个类，它实际上是basic_string模版类实例化产生的。</li>
<li>cstring兼容了过去string.h的函数，但是采用了c++的写法。</li>
</ul>
<blockquote>
<p>程序实例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> charr1[<span class="number">20</span>]; <span class="comment">// C风格：创建空的字符数组 </span></span><br><span class="line">    <span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>; <span class="comment">// C风格：创建并初始化字符数组</span></span><br><span class="line"></span><br><span class="line">    string str1; <span class="comment">// 创建string空对象</span></span><br><span class="line">    string str2 = <span class="string">&quot;panther&quot;</span>; <span class="comment">// 创建并初始化string对象</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The third letter of charr2 is &quot;</span> &lt;&lt; charr2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The third letter of str2 is &quot;</span> &lt;&lt; str2[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">panther</span><br><span class="line">The third letter of charr2 is g</span><br><span class="line">The third letter of str2 is n</span><br></pre></td></tr></table></figure>
<p>可以看出，可以使用数组表示法来访问存储在string对象中的字符。</p>
<p>类设计让程序能够自动处理string的大小。例如，str1的声明创建一个长度为0的string对象，但程序将输入读取到str1中时，将自动调整str1的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; str1;</span><br></pre></td></tr></table></figure>
<p>这使得与使用数组相比，使用string对象更方便，也更安全。</p>
<p>从理论上说，可以将char数组视为一组用于存储一个字符串的char存储单元，而string类变量是一个表示字符串的实体。</p>
<h4 id="4-4-2-赋值、拼接和附加"><a href="#4-4-2-赋值、拼接和附加" class="headerlink" title="4.4.2 赋值、拼接和附加"></a>4.4.2 赋值、拼接和附加</h4><p>可以将一个string对象赋值给另一个string对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> charr1[<span class="number">20</span>]; <span class="comment">// 创建空的字符数组</span></span><br><span class="line"><span class="keyword">char</span> charr2[<span class="number">20</span>] = <span class="string">&quot;jaguar&quot;</span>; <span class="comment">// 创建并初始化字符数组</span></span><br><span class="line"></span><br><span class="line">charr1 = charr2; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str1; <span class="comment">// 创建string空对象</span></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;panther&quot;</span>; <span class="comment">// 创建并初始化string对象</span></span><br><span class="line"></span><br><span class="line">str1 = str2; <span class="comment">// valid!</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>+</code>拼接两个字符串对象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str3 = str1 + str2;</span><br><span class="line">str3 += <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 相当于str3 = str3 + &quot;Hello&quot;;</span></span><br><span class="line">str1 += str2; <span class="comment">// 相当于str1 = str1 + str2;</span></span><br></pre></td></tr></table></figure>
<p>可以看出string简化了C语言对字符串的操作，例如上面的操作，C语言需要调用库函数<code>strcpy</code>，<code>strcat</code>等。</p>
<h4 id="4-4-3-长度"><a href="#4-4-3-长度" class="headerlink" title="4.4.3 长度"></a>4.4.3 长度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> len1 = str1.<span class="built_in">size</span>();	<span class="comment">// size()是string类的方法</span></span><br><span class="line"><span class="keyword">int</span> len2 = <span class="built_in">strlen</span>(charr1); <span class="comment">// strlen原型在string.h中</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-结构"><a href="#4-5-结构" class="headerlink" title="4.5 结构"></a>4.5 结构</h3><p>略</p>
<h3 id="4-6-联合"><a href="#4-6-联合" class="headerlink" title="4.6 联合"></a>4.6 联合</h3><p>略</p>
<h3 id="4-7-枚举"><a href="#4-7-枚举" class="headerlink" title="4.7 枚举"></a>4.7 枚举</h3><p>略</p>
<h3 id="4-8-指针"><a href="#4-8-指针" class="headerlink" title="4.8 指针"></a>4.8 指针</h3><h4 id="4-8-1-补充和注意点"><a href="#4-8-1-补充和注意点" class="headerlink" title="4.8.1 补充和注意点"></a>4.8.1 补充和注意点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面三种表达方式都是一样的</span></span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span>* p;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：p1是int*，而p2是int</span></span><br><span class="line"><span class="keyword">int</span>* p1, p2;</span><br></pre></td></tr></table></figure>
<p>指针的值（地址）不是整型，虽然计算机通常把地址当做整型来处理，因此，不能简单地将整数赋给指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* pt;</span><br><span class="line">pt = <span class="number">0xB8000000</span>; <span class="comment">// error 类型不匹配</span></span><br><span class="line"></span><br><span class="line">pt = (<span class="keyword">int</span> *)<span class="number">0xB8000000</span>; <span class="comment">// valid</span></span><br></pre></td></tr></table></figure>
<p>甚至有这样的做法，将地址强制转换为整型，会报warning：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *)<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> m = (<span class="keyword">int</span>)p;</span><br></pre></td></tr></table></figure>
<h4 id="4-8-2-new和delete"><a href="#4-8-2-new和delete" class="headerlink" title="4.8.2 new和delete"></a>4.8.2 new和delete</h4><p>在C语言中，可以用库函数 <code>malloc</code> 来分配内存，该内存在堆空间中；在C++中仍然可以这样做，但C++还有更好的方法——<code>new</code> 运算符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 相当于：</span></span><br><span class="line"><span class="keyword">int</span>* p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
<p>对应的，与free函数功能相同的运算符是<code>delete</code>。注意，delete只能释放由new分配的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">*p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* ptr = &amp;m;</span><br><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h4 id="4-8-3-动态数组"><a href="#4-8-3-动态数组" class="headerlink" title="4.8.3 动态数组"></a>4.8.3 动态数组</h4><p>使用new来创建动态数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size;</span><br><span class="line">cin &gt;&gt; size;</span><br><span class="line"><span class="keyword">int</span>* psome = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">delete</span> [] psome; <span class="comment">//注意[]</span></span><br></pre></td></tr></table></figure>
<p>动态数组的使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">p[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">p[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0] is &quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line">p += <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0] is &quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">p -= <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p[0] is &quot;</span> &lt;&lt; p[<span class="number">0</span>] &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
<h3 id="4-9-指针算术"><a href="#4-9-指针算术" class="headerlink" title="4.9 指针算术"></a>4.9 指针算术</h3><h4 id="4-9-1-数组名"><a href="#4-9-1-数组名" class="headerlink" title="4.9.1 数组名"></a>4.9.1 数组名</h4><p>数组名：通常情况下，是数组第一个元素的地址。将<code>sizeof</code>运用于数组名时，返回数组的大小，以字节为单位。</p>
<p>数组名不可以进行运算，指针可以进行运算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[] = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="string">&quot;I love you.&quot;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; arr &lt;&lt; endl; <span class="comment">// Hello World!</span></span><br><span class="line">cout &lt;&lt; *arr &lt;&lt; endl; <span class="comment">// H 相当于*(&amp;arr[0])</span></span><br><span class="line">cout &lt;&lt; *(arr + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// e 指针表示法</span></span><br><span class="line">cout &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// e 数组表示法</span></span><br><span class="line">arr += <span class="number">1</span>; <span class="comment">// error 数组名不能进行运算</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ptr &lt;&lt; endl; <span class="comment">// I love you.</span></span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// I</span></span><br><span class="line">cout &lt;&lt; *(ptr + <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 指针表示法</span></span><br><span class="line">cout &lt;&lt; ptr[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// 数组表示法</span></span><br><span class="line">ptr += <span class="number">2</span>; <span class="comment">// valid</span></span><br><span class="line">cout &lt;&lt; *ptr &lt;&lt; endl; <span class="comment">// l</span></span><br></pre></td></tr></table></figure>
<h4 id="4-9-2-指针和字符串"><a href="#4-9-2-指针和字符串" class="headerlink" title="4.9.2 指针和字符串"></a>4.9.2 指针和字符串</h4><p>给<code>cout</code>提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ptr = <span class="string">&quot;I love you.&quot;</span>;</span><br><span class="line">cout &lt;&lt; ptr &lt;&lt; endl; <span class="comment">// I love you.</span></span><br></pre></td></tr></table></figure>
<h2 id="5-循环"><a href="#5-循环" class="headerlink" title="5 循环"></a>5 循环</h2><p>略。</p>
<p>补充：</p>
<p>C++11新增了一种循环：基于范围（range-based）的for循环（相当于java的增强for循环）。这简化了一种常见的循环任务：对数组（或容器类，如 vector和 array）的每个元素执行相同的操作，如下例所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> prices[<span class="number">5</span>] = &#123;<span class="number">4.99</span>, <span class="number">10.99</span>, <span class="number">6.87</span>, <span class="number">7.99</span>, <span class="number">8.49</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">double</span> price : prices) &#123;</span><br><span class="line">    cout &lt;&lt; price &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-分支"><a href="#6-分支" class="headerlink" title="6 分支"></a>6 分支</h2><p>略</p>
<h2 id="7-函数"><a href="#7-函数" class="headerlink" title="7 函数"></a>7 函数</h2><h3 id="7-1-内联函数"><a href="#7-1-内联函数" class="headerlink" title="7.1 内联函数"></a>7.1 内联函数</h3><p>编译过程的最终产品是可执行程序——由一组机器语言指令组成。运行程序时，操作系统将这些指令载入到计算机内存中，因此每条指令都有特定的内存地址。计算机随后将逐步执行这些指令。有时（如有循环或分支语句时），将跳过一些指令，向前或向后跳到特定地址。</p>
<p><strong>常规函数</strong>调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈（为此保留的内存块），跳到标记函数起点的内存单元，执行函数代码（也许还需将返回值放入到寄存器中），然后跳回到地址被保存的指令处。来回跳跃并记录跃位置意味着以前使用函数时，需要一定的开销。</p>
<p>C++<strong>内联函数</strong>提供了另一种选择。内联函数的编译代码与其他程序代码”内联”起来了。也就是说，编译器将使用相应的函数代码替换函数调用。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，<strong>内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存</strong>。如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230102182710366.png" alt="image-20230102182710366"></p>
<p>内联函数使用<code>inline</code>进行修饰，一般在头文件中定义。而一般函数在头文件中声明，在cpp中定义。</p>
<blockquote>
<p>使用内联函数的时机</p>
</blockquote>
<ul>
<li>函数本身内容比较少，代码比较短，函数功能相对简单</li>
<li>函数被调用得频繁，不如循环中的函数</li>
</ul>
<blockquote>
<p>不使用内联函数的时机</p>
</blockquote>
<ul>
<li>函数代码量多，功能复杂，体积庞大。对于这种函数，就算加上inline修饰符，编译器也不一定会满足要求，可能还是会当成一般函数处理</li>
<li>递归函数不能使用内联函数</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">13.0</span>;</span><br><span class="line">    <span class="keyword">double</span> a = <span class="built_in">square</span>(<span class="number">5.0</span>);</span><br><span class="line">    <span class="keyword">double</span> b = <span class="built_in">square</span>(<span class="number">4.5</span> + <span class="number">7.5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c squared = &quot;</span> &lt;&lt; <span class="built_in">square</span>(c++) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 25, b = 144</span><br><span class="line">c = 13</span><br><span class="line">c squared = 169</span><br><span class="line">Now c = 14</span><br></pre></td></tr></table></figure>
<hr>
<p>内联函数比宏更加强大，宏通过文本替换实现，而内联函数和常规函数一样，通过按值来传递参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x) x*x</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="built_in">SUM</span>(<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">	<span class="keyword">int</span> b = <span class="built_in">fun</span>(<span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 11</span><br><span class="line">b = 25</span><br></pre></td></tr></table></figure>
<p>原因：<code>int a = SUM(2 + 3);</code>相当于<code>int a = 2 + 3 * 2 + 3;</code>，而内联函数传入的参数为5。</p>
<p>为了得到正确的结果，我们应该将宏改变为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SUM(x) ((x)*(x))</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-引用变量"><a href="#7-2-引用变量" class="headerlink" title="7.2 引用变量"></a>7.2 引用变量</h3><p> 引用变量是C++新增的一种复合类型。引用是已定义的变量的别名。例如，a = 5，如果将 b 作为 a 变量的引用，则可以交替使用 a 和 b 表示该变量（即 a 和 b 都可以表示 5）。引用有指针的作用，但它比指针使用起来更加方便。 </p>
<p>作用：用作函数的形参。通过将引用变量用作参数，函数将使用原始的数据，而不是其副本（类似指针）。</p>
<h4 id="7-2-1-创建引用变量"><a href="#7-2-1-创建引用变量" class="headerlink" title="7.2.1 创建引用变量"></a>7.2.1 创建引用变量</h4><p>C和C++使用&amp;符号来指示变量的地址。C++给<code>&amp;</code>符号赋予了另一个含义，将其用来声明引用。例如，要将rodents作为rats变量的别名，可以这样做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats; <span class="comment">// 指向int的引用</span></span><br></pre></td></tr></table></figure>
<p>其中，&amp;不是地址运算符，而是类型标识符的一部分。就类似声明 char* 指的是指向 char 的指针一样， <code>int &amp;</code>指的是指向 int 的引用。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, a address: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, b address: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">    b++; <span class="comment">// 相当于a++</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = 5, a address: 0x7ffd5d00f404</span><br><span class="line">b = 5, b address: 0x7ffd5d00f404</span><br><span class="line">a = 6</span><br><span class="line">b = 6</span><br></pre></td></tr></table></figure>
<ul>
<li>和指针不同，<strong>必须在声明引用时将其初始化</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents;</span><br><span class="line">rodents = rats; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> &amp; rodents = rats; <span class="comment">// correct!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rats;</span><br><span class="line"><span class="keyword">int</span> * rodents;</span><br><span class="line">rodents = &amp;rats; <span class="comment">// correct for pointer!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一旦初始化引用，该引用将一直与引用的变量相关联，因此：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp; rodents = rats;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * rodents = &amp;rats;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span>&amp; b = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, a address: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, b address: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">	b = c; <span class="comment">// 试图改变 b 的指向,从指向a变为指向c</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;, c address: &quot;</span> &lt;&lt; &amp;c &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, a address: &quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, b address: &quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 5, a address: 0x7ffec654fff4</span><br><span class="line">b = 5, b address: 0x7ffec654fff4</span><br><span class="line">c = 10, c address: 0x7ffec654fff0</span><br><span class="line">a = 10, a address: 0x7ffec654fff4</span><br><span class="line">b = 10, b address: 0x7ffec654fff4</span><br></pre></td></tr></table></figure>
<p>可以看出b确实变成了c，但是a也变成了c，并且a和b的地址一致，并未发生改变，实际上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = c;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">a = c; <span class="comment">// 相当于给a赋值为c</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果用<code>const</code>修饰引用，则不可改变引用；这种修饰常常用于函数参数的修饰，称为<strong>常量引用参数</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; n = m;</span><br><span class="line">n = <span class="number">1</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<h4 id="7-2-2-将引用作为函数参数"><a href="#7-2-2-将引用作为函数参数" class="headerlink" title="7.2.2 将引用作为函数参数"></a>7.2.2 将引用作为函数参数</h4><p>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为<strong>按引用传递</strong>。</p>
<p>按引用传递允许被调用的函数能够访问调用函数中的变量。C++新增的这项特性是对C 语言的超越，<strong>C语言只能按值传递</strong>。按值传递导致被调用函数使用调用程序的值的拷贝。当然，C语言也允许避开按值传递的限制，采用按指针传递的方式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230103112108728.png" alt="image-20230103112108728"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;未交换前: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap1</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用引用参数函数后: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap2</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调用指针参数函数后: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap3</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;使用传值函数后: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap1</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line"> </span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 按指针传递（C版本的“按引用传递”）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line"> </span><br><span class="line">	temp = *a;</span><br><span class="line">	*a = *b;</span><br><span class="line">	*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line"> </span><br><span class="line">	temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">未交换前: a = 5, b = 10</span><br><span class="line">调用引用参数函数后: a = 10, b = 5</span><br><span class="line">调用指针参数函数后: a = 5, b = 10</span><br><span class="line">使用传值函数后: a = 5, b = 10</span><br></pre></td></tr></table></figure>
<p>按引用传递<code>swap1(a, b)</code>和按值传递<code>swap3(a, b)</code>在调用时看起来相同，只能通过函数原型或函数定义才知道<code>swap1()</code>是按引用传递。</p>
<h4 id="7-2-3-引用的属性和特别之处"><a href="#7-2-3-引用的属性和特别之处" class="headerlink" title="7.2.3 引用的属性和特别之处"></a>7.2.3 引用的属性和特别之处</h4><p>使用基本数据类型，应采用按值传递的方式。</p>
<p>使用按引用传递时，要求更加严格，下面的代码不会通过编译：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">refcube</span><span class="params">(<span class="keyword">double</span>&amp; y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">double</span> z = <span class="built_in">refcube</span>(x + <span class="number">4.0</span>); <span class="comment">// 实参应该是变量，而不是表达式x+4.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-4-临时变量、引用参数和const"><a href="#7-2-4-临时变量、引用参数和const" class="headerlink" title="7.2.4 临时变量、引用参数和const"></a>7.2.4 临时变量、引用参数和const</h4><p>暂略</p>
<h4 id="7-2-5-将引用用于结构"><a href="#7-2-5-将引用用于结构" class="headerlink" title="7.2.5 将引用用于结构"></a>7.2.5 将引用用于结构</h4><p>引用非常适合用于结构和类。确实，引入引用主要是为了用于这些类型的，而不是基本的内置类型。</p>
<p>使用结构引用参数的方式与使用基本变量引用相同，只需在声明结构参数时使用引用运算符<code>&amp;</code>即可，例如，假设有如下结构定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_throws</span> &#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> made;</span><br><span class="line">    <span class="keyword">int</span> attempts;</span><br><span class="line">    <span class="keyword">float</span> percent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在函数中将指向该结构的引用作为参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果不想让函数修改传入的结构，可以使用<code>const</code>修饰，使其成为常量引用参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">const</span> free_throws &amp; ft)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strc_ref.cpp -- using structure references</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_throws</span> &#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> made;</span><br><span class="line">    <span class="keyword">int</span> attempts;</span><br><span class="line">    <span class="keyword">float</span> percent;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> free_throws &amp; ft)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span></span>;</span><br><span class="line"><span class="comment">// 该函数返回引用</span></span><br><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp;target, <span class="keyword">const</span> free_throws &amp;source)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    free_throws one = &#123;<span class="string">&quot;Ifelsa Branch&quot;</span>, <span class="number">13</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    free_throws two = &#123;<span class="string">&quot;Andor Knott&quot;</span>, <span class="number">10</span>, <span class="number">16</span>&#125;;</span><br><span class="line">    free_throws three = &#123;<span class="string">&quot;Minnie Max&quot;</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    free_throws four = &#123;<span class="string">&quot;Whily Looper&quot;</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    free_throws five = &#123;<span class="string">&quot;Long Long&quot;</span>, <span class="number">6</span>, <span class="number">14</span>&#125;;</span><br><span class="line">    free_throws team = &#123;<span class="string">&quot;Throwgoods&quot;</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    free_throws dup;</span><br><span class="line">    <span class="built_in">set_pc</span>(one);</span><br><span class="line">    <span class="built_in">display</span>(one);</span><br><span class="line">    <span class="built_in">accumulate</span>(team, one);</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line"><span class="comment">// use return value as argument</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="built_in">accumulate</span>(team, two));</span><br><span class="line">    <span class="built_in">accumulate</span>(<span class="built_in">accumulate</span>(team, three), four);</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line"><span class="comment">// use return value in assignment</span></span><br><span class="line">    dup = <span class="built_in">accumulate</span>(team,five);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Displaying team:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(team);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Displaying dup after assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(dup);</span><br><span class="line">    <span class="built_in">set_pc</span>(four);</span><br><span class="line"><span class="comment">// ill-advised assignment</span></span><br><span class="line">    <span class="built_in">accumulate</span>(dup,five) = four;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Displaying dup after ill-advised assignment:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">display</span>(dup);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> free_throws &amp; ft)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; ft.name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;  Made: &quot;</span> &lt;&lt; ft.made &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Attempts: &quot;</span> &lt;&lt; ft.attempts &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Percent: &quot;</span> &lt;&lt; ft.percent &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置percent</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(free_throws &amp; ft)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ft.attempts != <span class="number">0</span>)</span><br><span class="line">        ft.percent = <span class="number">100.0f</span> *<span class="built_in"><span class="keyword">float</span></span>(ft.made)/<span class="built_in"><span class="keyword">float</span></span>(ft.attempts);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ft.percent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加attempts和made，并设置percent</span></span><br><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp; target, <span class="keyword">const</span> free_throws &amp; source)</span> </span>&#123;</span><br><span class="line">    target.attempts += source.attempts;</span><br><span class="line">    target.made += source.made;</span><br><span class="line">    <span class="built_in">set_pc</span>(target);</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序说明</li>
</ul>
<p>第一个函数调用为<code>set_pc(one)</code>。如果采用指针参数传递的话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set_pcp</span>(&amp;one);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pcp</span><span class="params">(free_throws * pt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pt -&gt; attempts != <span class="number">0</span>)</span><br><span class="line">        pt -&gt; percent = <span class="number">100.0f</span> *<span class="built_in"><span class="keyword">float</span></span>(pt -&gt; made)/<span class="built_in"><span class="keyword">float</span></span>(pt -&gt; attempts);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pt -&gt; percent = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个函数调用为<code>display(one)</code>，函数原型使用了<code>const</code>修饰引用。下略。</p>
<ul>
<li>返回引用</li>
</ul>
<p>传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而调用程序将使用这个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> m = <span class="built_in">sqrt</span>(<span class="number">16.0</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">sqrt</span>(<span class="number">25.0</span>);</span><br></pre></td></tr></table></figure>
<p>在第一条语句中，sqrt函数返回值4.0被复制到一个临时位置，然后被复制给m。</p>
<p>在第二条语句中，sqrt函数返回值5.0被复制到一个临时位置，然后被传递给cout。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup = <span class="built_in">accumulate</span>(team, five);</span><br></pre></td></tr></table></figure>
<p>如果 accumulate 返回一个结构，而不是指向结构的引用，将把整个结构复制到一个临时位置，再将这个拷贝复制给 dup。但在返回值为引用时，将直接把返回值复制到dup，其效率更高。</p>
<ul>
<li>返回引用时注意的问题</li>
</ul>
<p>注意，应该<strong>避免返回函数终止时不再存在的内存单元的引用</strong>，同样的，也应该<strong>避免返回指向局部变量的指针</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> free_throws &amp; <span class="title">clone</span><span class="params">(free_throws &amp; ft)</span> </span>&#123;</span><br><span class="line">    free_throws newguy; <span class="comment">// 在栈中为局部变量开辟内存</span></span><br><span class="line">    newguy = ft;</span><br><span class="line">    <span class="keyword">return</span> newguy; <span class="comment">// 释放该内存区域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span> </span>&#123;</span><br><span class="line">    FILE tmp; <span class="comment">// 局部变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给结构体成员赋值初始化</span></span><br><span class="line">    tmp.xxx = xxx;</span><br><span class="line">    tmp.yyy = yyy;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> &amp;tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数退出后，释放为局部变量<code>newguy</code>匹配的内存（该内存地址位于栈区），因此，返回的引用指向的是一个没有被分配的内存。</p>
<p>同理，函数退出后，释放为局部变量<code>tmp</code>匹配的内存（该内存地址位于栈区），因此，返回的指针指向的是一个没有被分配的内存。</p>
<p>为避免这种问题，可以返回一个作为参数传递给函数的引用，或者使用new出来的内存存放，此时变量的生命周期为动态内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp; ft)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对ft的操作</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ft;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-------------------</span></span><br><span class="line"><span class="function">free_throws &amp; <span class="title">accumulate</span><span class="params">(free_throws &amp; ft)</span> </span>&#123;</span><br><span class="line">    free_throws newguy = <span class="keyword">new</span> free_throws; <span class="comment">// 在堆区开辟动态内存</span></span><br><span class="line">    newguy = ft;</span><br><span class="line">    <span class="keyword">return</span> newguy; <span class="comment">// 该内存不会被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">free_throws &amp; m = <span class="built_in">accumulate</span>(ft);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 需要手动释放该内存</span></span><br><span class="line"><span class="keyword">delete</span> m;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-6-将引用用于类对象"><a href="#7-2-6-将引用用于类对象" class="headerlink" title="7.2.6 将引用用于类对象"></a>7.2.6 将引用用于类对象</h4><p>将类对象传递给函数时，C++通常的做法是使用引用。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strquote.cpp  -- different designs</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">string <span class="title">version1</span><span class="params">(<span class="keyword">const</span> string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp; <span class="title">version2</span><span class="params">(string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span></span>;  <span class="comment">// has side effect</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp; <span class="title">version3</span><span class="params">(string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span></span>;  <span class="comment">// bad design</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    string copy;</span><br><span class="line">    string result;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a string: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    copy = input;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your string as entered: &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">    result = <span class="built_in">version1</span>(input, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">    result = <span class="built_in">version2</span>(input, <span class="string">&quot;###&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Resetting original string.\n&quot;</span>;</span><br><span class="line">    input = copy;</span><br><span class="line">    result = <span class="built_in">version3</span>(input, <span class="string">&quot;@@@&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your string enhanced: &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Your original string: &quot;</span> &lt;&lt; input &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// cin.get();</span></span><br><span class="line">	<span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">version1</span><span class="params">(<span class="keyword">const</span> string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span> </span>&#123;</span><br><span class="line">    string temp;</span><br><span class="line"></span><br><span class="line">    temp = s2 + s1 + s2;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp; <span class="title">version2</span><span class="params">(string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span> </span>&#123;  <span class="comment">// has side effect：修改s1引用的变量 </span></span><br><span class="line">    s1 = s2 + s1 + s2;</span><br><span class="line"><span class="comment">// safe to return reference passed to function</span></span><br><span class="line">    <span class="keyword">return</span> s1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> string &amp; <span class="title">version3</span><span class="params">(string &amp; s1, <span class="keyword">const</span> string &amp; s2)</span> </span>&#123;  <span class="comment">// bad design</span></span><br><span class="line">    string temp;</span><br><span class="line"></span><br><span class="line">    temp = s2 + s1 + s2;</span><br><span class="line"><span class="comment">// unsafe to return reference to local variable：程序试图引用已经释放的内存</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-2-7-使用引用参数的时机"><a href="#7-2-7-使用引用参数的时机" class="headerlink" title="7.2.7 使用引用参数的时机"></a>7.2.7 使用引用参数的时机</h4><p>使用引用参数的优点：</p>
<ul>
<li>能够修改主调函数中的数据对象</li>
<li>通过传递引用而不是整个数据对象，可以提高程序的运行速度和减少占用内存</li>
</ul>
<blockquote>
<p>不修改主调函数的值的函数</p>
</blockquote>
<ul>
<li>如果数据对象很小，如内置数据类型或小型结构，则按值传递</li>
<li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向<code>const</code>的指针</li>
<li>如果数据对象是较大的结构，则使用<code>const指针</code>或<code>const引用</code>，以提高程序的效率。这样可以节省复制结构所需的时间和空间</li>
<li>如果数据对象是类对象，则使用<code>const引用</code>。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递</li>
</ul>
<blockquote>
<p>修改主调函数中数据的函数</p>
</blockquote>
<ul>
<li>如果数据对象是内置数据类型，则使用指针</li>
<li>如果数据对象是数组，则只能使用指针</li>
<li>如果数据对象是结构，则使用引用或指针</li>
<li>如果数据对象是类对象，则使用引用</li>
</ul>
<h3 id="7-3-默认参数"><a href="#7-3-默认参数" class="headerlink" title="7.3 默认参数"></a>7.3 默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。有默认值的参数即为默认参数。在函数调用时，有默认参数可以缺省。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">left</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str, <span class="keyword">int</span> n = <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">char</span> * m = <span class="built_in">left</span>(<span class="keyword">char</span> * str); <span class="comment">// 省略了n</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">char</span> * m = <span class="built_in">left</span>(<span class="keyword">char</span> * str, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// --------------</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> n = <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="built_in">func</span>(); </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="built_in">fun</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">harpo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m = <span class="number">4</span>, <span class="keyword">int</span> j = <span class="number">5</span>)</span></span>; <span class="comment">// valid</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">harpo</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m = <span class="number">4</span>, <span class="keyword">int</span> j)</span></span>; <span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">harpo</span><span class="params">(<span class="keyword">int</span> n = <span class="number">3</span>, <span class="keyword">int</span> m = <span class="number">4</span>, <span class="keyword">int</span> j = <span class="number">5</span>)</span></span>; <span class="comment">// valid</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数声明和函数实现（即函数定义），只允许其中一个有默认值，即如果函数声明有默认值，则函数实现的时候就不能有默认参数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">bool</span> is_add = <span class="literal">true</span>)</span></span>;	<span class="comment">//函数声明中设置了参数is_add的默认值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> abs = <span class="built_in">func</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;abs = &quot;</span> &lt;&lt; abs &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">bool</span> is_add = <span class="literal">true</span>)</span> </span>&#123;	<span class="comment">//函数实现中也设置了参数is_add的默认值</span></span><br><span class="line">	<span class="keyword">if</span> (is_add) &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b - c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确方式：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">bool</span> is_add)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (is_add) &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b + c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a - b - c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误	C2572	“func”: 重定义默认参数 : 参数 <span class="number">1</span>	</span><br></pre></td></tr></table></figure>
<h3 id="7-4-函数重载"><a href="#7-4-函数重载" class="headerlink" title="7.4 函数重载"></a>7.4 函数重载</h3><p>函数签名（函数特征标）：参数的数量、类型（以及类型引用）和排列顺序三者构成函数签名。</p>
<p><strong>如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的</strong>。</p>
<p>函数重载：<strong>函数名相同，函数签名不同</strong>的函数。例如，可以定义一组原型如下的 print 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * str,<span class="keyword">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span> d,<span class="keyword">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> l,<span class="keyword">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *str)</span></span>; <span class="comment">// 所有的print的特征标各不相同</span></span><br></pre></td></tr></table></figure>
<p>最后两个print函数也是重载，因为一个参数是由<code>const</code>修饰，另一个没有。编译器将根据传入的参数是否由<code>const</code>修饰来决定使用哪一个函数原型。</p>
<p>注意，在函数签名中，类型引用等价于类型，下面同名的函数原型不是重载（函数签名相同，尽管一个参数是类型，一个是类型引用，但两者等价），因此不能共存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube</span><span class="params">(<span class="keyword">double</span> &amp; x)</span></span>; <span class="comment">// 特征标相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">double</span> y = <span class="built_in">cube</span>(x); <span class="comment">// 编译器无法确定调用哪一个cube函数</span></span><br></pre></td></tr></table></figure>
<p>注意，返回类型不属于函数签名，因此下面的同名的函数原型不是重载，不能共存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>; <span class="comment">// 两者特征标相同，不构成重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>; <span class="comment">// 两者特征标不同，构成重载</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">gronk</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">gronk</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>; <span class="comment">// 两者特征标不同，构成重载</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用重载的时机</p>
</blockquote>
<p>仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。</p>
<h3 id="7-5-函数模板"><a href="#7-5-函数模板" class="headerlink" title="7.5 函数模板"></a>7.5 函数模板</h3><p>函数模板是通用的函数描述，也就是说，它们使用<strong>泛型</strong>来定义函数，其中的泛型可用具体的类型（如int或 double）替换。</p>
<p>通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型。</p>
<p>语法格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">返回值 函数名(参数)&#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>template</code>：声明创建模板的关键字</li>
<li><code>typename</code>：关键字，或者使用<code>class</code>，关键字，后面接的符号代表一种数据类型</li>
<li><code>T</code>：是一个通用的数据类型，名称自定义，通常为大写字母 </li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnyType&gt;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(AnyType &amp;a, AnyType &amp;b)</span> </span>&#123;</span><br><span class="line">    AnyType temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// funtemp.cpp -- using a function template</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// function template prototype</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// or class T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated int swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(i,j);  <span class="comment">// generates void Swap(int &amp;, int &amp;)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> x = <span class="number">24.5</span>;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">81.7</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x, y = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated double swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(x,y);  <span class="comment">// generates void Swap(double &amp;, double &amp;)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now x, y = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function template definition</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// or class T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T temp;   <span class="comment">// temp a variable of type T</span></span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数模板调用方式有两种：显式类型推导和隐式类型推导。使用显式类型推导，参数和推导的类型必须一致。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">Swap</span>(a, b); <span class="comment">// 隐式类型推导</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> c = <span class="number">30.0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">40.0</span>;</span><br><span class="line">MySwap&lt;<span class="keyword">double</span>&gt;(c, d); <span class="comment">// 显式类型推导</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码示例2——重载的模板</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// twotemps.cpp -- using overloaded template functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// original template</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;     <span class="comment">// new template</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T *a, T *b, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 重载的模板函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span> a[])</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Lim = <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>, j = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using compiler-generated int swapper:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Swap</span>(i,j);              <span class="comment">// matches original template</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Now i, j = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> d1[Lim] = &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> d2[Lim] = &#123;<span class="number">0</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Original arrays:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Show</span>(d1); </span><br><span class="line">    <span class="built_in">Show</span>(d2);</span><br><span class="line">    <span class="built_in">Swap</span>(d1,d2,Lim);        <span class="comment">// matches new template</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Swapped arrays:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">Show</span>(d1);</span><br><span class="line">    <span class="built_in">Show</span>(d2);</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T &amp;a, T &amp;b)</span>  </span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T a[], T b[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    T temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = a[i];</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        b[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; a[<span class="number">3</span>] &lt;&lt; <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; Lim; i++)</span><br><span class="line">        cout &lt;&lt; a[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-对象和类"><a href="#8-对象和类" class="headerlink" title="8 对象和类"></a>8 对象和类</h2><p>面向对象编程（OOP）的重要特性：</p>
<ul>
<li>抽象</li>
<li>封装和数据隐藏</li>
<li>多态</li>
<li>继承</li>
<li>代码的可重用性</li>
</ul>
<h3 id="8-1-基本使用"><a href="#8-1-基本使用" class="headerlink" title="8.1 基本使用"></a>8.1 基本使用</h3><h4 id="8-1-1-类的声明"><a href="#8-1-1-类的声明" class="headerlink" title="8.1.1 类的声明"></a>8.1.1 类的声明</h4><p>将类的声明放在头文件中，实现（定义）放在源代码文件中。</p>
<blockquote>
<p>代码示例<code>stock00.h</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock00.h -- Stock class interface</span></span><br><span class="line"><span class="comment">// version 00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCK00_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCK00_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">   	<span class="comment">// 公司名</span></span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="comment">// 股票</span></span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="comment">// 股票价值</span></span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="comment">// 股票总价值</span></span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="comment">// 设置股票总价值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">const</span> std::string &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;; <span class="comment">// 注意有分号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="8-1-2-访问控制"><a href="#8-1-2-访问控制" class="headerlink" title="8.1.2 访问控制"></a>8.1.2 访问控制</h4><p>关键字 <code>private</code> 和 <code>public</code> 描述了对类成员的访问控制。</p>
<p>使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数（或友元函数）来访问对象的私有成员。例如，要修改Stock类的shares成员，只能通过Stock的成员函数。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。<strong>防止程序直接访问数据被称为数据隐藏</strong>。C++还提供了第三个访问控制关键字 <code>protected</code>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230104124359578.png" alt="image-20230104124359578"></p>
<h4 id="8-1-3-控制对成员的访问"><a href="#8-1-3-控制对成员的访问" class="headerlink" title="8.1.3 控制对成员的访问"></a>8.1.3 控制对成员的访问</h4><p>通常将数据项放在私有部分，成员函数放在共有部分。</p>
<p>访问控制的关键字缺省时，默认是<code>private</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">World</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> mass; <span class="comment">// private</span></span><br><span class="line">    <span class="keyword">char</span> names[<span class="number">20</span>]; <span class="comment">// private</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tellAll</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-4-实现类成员函数"><a href="#8-1-4-实现类成员函数" class="headerlink" title="8.1.4 实现类成员函数"></a>8.1.4 实现类成员函数</h4><ul>
<li>定义成员函数时，使用作用域解析运算符<code>::</code>来标识函数所属类</li>
<li>类方法可以访问类的<code>private</code>组件</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这种表示法意味着我们定义的update函数是Stock类的成员。这不仅将update标识为成员函数，还意味着我们可以将另一个类的成员函数也命名为update。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Buffoon::update</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>因此，作用域解析运算符确定了方法定义对应的类的身份。我们说，标识符update具有<strong>类作用域</strong>。Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update方法，这是因为它们属于同一个类，因此update是可见的。</p>
<p>类方法的完整名称中包括类名。我们说，<code>Stock::update</code>是函数的限定名；而简单的update是全名的缩写（非限定名），它只能在类作用域中使用。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>实现类方法（类成员函数），将其定义在独立的实现文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock00.cpp -- implementing the Stock class</span></span><br><span class="line"><span class="comment">// version 00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock00.h&quot;</span> <span class="comment">// 包含类定义的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="keyword">const</span> std::string &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类作用域中，可以直接使用成员变量，例如这里的company，完整写法是Stock::company</span></span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                  &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        shares = n;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number of shares purchased can&#x27;t be negative. &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Transaction is aborted.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        shares += num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Number of shares sold can&#x27;t be negative. &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Transaction is aborted.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;You can&#x27;t sell more than you have! &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Transaction is aborted.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        shares -= num;</span><br><span class="line">        share_val = price;</span><br><span class="line">        <span class="built_in">set_tot</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">    share_val = price;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>内联方法：定义位于类声明中的函数都将自动称为内联函数，例如<code>Stock::set_tot()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 内联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以将定义和声明分离：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 内联函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个文件中</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Stock::set_tot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    total_val = shares * share_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-5-使用类对象"><a href="#8-1-5-使用类对象" class="headerlink" title="8.1.5 使用类对象"></a>8.1.5 使用类对象</h4><p>创建对象和使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock kate, joe;</span><br><span class="line">kate.<span class="built_in">show</span>(); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure>
<p>所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享同一组类方法，即<strong>每种方法只有一个副本</strong>。</p>
<p>例如，假设kate和 joe都是 Stock 对象，则 <code>kate.shares</code> 将占据一个内存块，而<code>joe.shares</code> 占用另一个内存块，但<code>kate.show</code>和<code>joe.show</code>都调用同一个方法，也就是说，它们将执行同一个代码块，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230104131756935.png" alt="image-20230104131756935"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usestok0.cpp -- the client program</span></span><br><span class="line"><span class="comment">// compile with stock.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock00.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stock fluffy_the_cat; <span class="comment">// 创建对象</span></span><br><span class="line">    fluffy_the_cat.<span class="built_in">acquire</span>(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">20</span>, <span class="number">12.50</span>);</span><br><span class="line">    fluffy_the_cat.<span class="built_in">show</span>();</span><br><span class="line">    fluffy_the_cat.<span class="built_in">buy</span>(<span class="number">15</span>, <span class="number">18.125</span>);</span><br><span class="line">    fluffy_the_cat.<span class="built_in">show</span>();</span><br><span class="line">    fluffy_the_cat.<span class="built_in">sell</span>(<span class="number">400</span>, <span class="number">20.00</span>);</span><br><span class="line">    fluffy_the_cat.<span class="built_in">show</span>();</span><br><span class="line">    fluffy_the_cat.<span class="built_in">buy</span>(<span class="number">300000</span>,<span class="number">40.125</span>);</span><br><span class="line">    fluffy_the_cat.<span class="built_in">show</span>();</span><br><span class="line">    fluffy_the_cat.<span class="built_in">sell</span>(<span class="number">300000</span>,<span class="number">0.125</span>);</span><br><span class="line">    fluffy_the_cat.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-6-小结"><a href="#8-1-6-小结" class="headerlink" title="8.1.6 小结"></a>8.1.6 小结</h4><ul>
<li>第一步是提供类声明。类声明类似结构声明，可以包括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数被放在公有部分中。</li>
<li>第二步是实现类成员函数。可以在类声明中提供完整的函数定义，而不是函数原型，但是通常的做法是单独提供函数定义（除非函数很小）。在这种情况下，需要使用作用域解析运算符来指出成员函数属于哪个类。</li>
</ul>
<h3 id="8-2-构造函数和析构函数"><a href="#8-2-构造函数和析构函数" class="headerlink" title="8.2 构造函数和析构函数"></a>8.2 构造函数和析构函数</h3><p>目前的类还不能按照常规的语法来初始化类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">2001</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thing</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>*pn;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">thing amabob=&#123;<span class="string">&quot;wodget&quot;</span>,<span class="number">-23</span>&#125;; <span class="comment">// valid initialization</span></span><br><span class="line">Stock hot =&#123;<span class="string">&quot;Sukie&#x27;s Autos,Inc.&quot;</span>,<span class="number">200</span>,<span class="number">50.25</span>&#125;; <span class="comment">// NO! compile error</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-1-声明和定义构造函数"><a href="#8-2-1-声明和定义构造函数" class="headerlink" title="8.2.1 声明和定义构造函数"></a>8.2.1 声明和定义构造函数</h4><p>构造函数名称与类名相同，没有返回值，其他与常规函数相同，可以重载，可以有默认参数等等。它专门用于构造新对象，将值赋给对象的数据成员。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>函数原型（声明）：位于类声明的公有部分</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>(<span class="keyword">const</span> string &amp; co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>
<p>参数分别用于初始化成员<code>company</code>，<code>shares</code>和<code>share_val</code>。</p>
<p>函数定义：一种可能的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>(<span class="keyword">const</span> string &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    company = co;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shares = n; </span><br><span class="line">    &#125;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    <span class="built_in">set_tot</span>(); <span class="comment">// 设置total_val</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：构造函数的参数名不能与类的成员名相同：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>(<span class="keyword">const</span> string &amp; company, <span class="keyword">long</span> shares, <span class="keyword">double</span> share_val) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    shares = shares; <span class="comment">// error!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-2-2-使用构造函数"><a href="#8-2-2-使用构造函数" class="headerlink" title="8.2.2 使用构造函数"></a>8.2.2 使用构造函数</h4><p>调用构造函数分为两种：</p>
<ul>
<li>显式调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>隐式调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stock <span class="title">food</span><span class="params">(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建出的对象位于程序的栈区。也可以使用<code>new</code>与构造函数一起使用，返回的指针将指向对象开始的内存区域，内存位于堆区，具有动态生命周期：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stock *pstock = <span class="keyword">new</span> <span class="built_in">Stock</span>(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动释放内存</span></span><br><span class="line"><span class="keyword">delete</span> pstock;</span><br></pre></td></tr></table></figure>
<p>这种情况下，对象没有名称，但是可以使用指针来管理该对象。</p>
<h4 id="8-2-3-默认构造函数"><a href="#8-2-3-默认构造函数" class="headerlink" title="8.2.3 默认构造函数"></a>8.2.3 默认构造函数</h4><p>如果没有提供任何构造函数，C++将自动提供<strong>默认构造函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，之前的代码是可行的，它将不初始化任何成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock joe; <span class="comment">// 调用默认构造函数</span></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">Stock joe = <span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>
<p>一旦提供了非默认构造函数，该默认构造函数将消失，因此下面的语句将出错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock joe; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<hr>
<p>定义默认构造函数的方式有两种（这两种方式不能共存）：</p>
<ul>
<li>给已有构造函数的所有参数提供默认值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>(<span class="keyword">const</span> string &amp; co = <span class="string">&quot;Error&quot;</span>, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过函数重载来定义另一个构造函数——一个没有参数的构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>
<p>通常应该提供对所有类成员做隐式初始化的默认构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;</span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock first; <span class="comment">// 隐式调用</span></span><br><span class="line">Stock first = <span class="built_in">Stock</span>(); <span class="comment">// 显式调用</span></span><br><span class="line">Stock *prelief = <span class="keyword">new</span> Stock; <span class="comment">// 隐式调用</span></span><br></pre></td></tr></table></figure>
<h4 id="8-2-4-析构函数"><a href="#8-2-4-析构函数" class="headerlink" title="8.2.4 析构函数"></a>8.2.4 析构函数</h4><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的<strong>成员函数</strong>——析构函数。</p>
<p>析构函数完成清理工作，因此实际上很有用。例如，如果构造函数使用 new 来分配内存，则析构函数将使用 delete 来释放这些内存。析构函数可用于释放对象时构造或在对象的生命期中所获取的资源。</p>
<p>Stock 的构造函数没有使用 new，因此析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可，Stock 类第一版正是这样做的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Stock</span>(); <span class="comment">// 提供的默认析构函数声明</span></span><br><span class="line"></span><br><span class="line">Stock::~<span class="built_in">Stock</span>() &#123; <span class="comment">// 默认定义</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>析构函数的特点</p>
</blockquote>
<ul>
<li>析构函数没有返回值和参数列表</li>
<li>析构函数不能重载</li>
<li>析构函数由系统自动调用，不能显式调用</li>
<li>析构函数可以是inline函数</li>
<li>析构函数应该设置为类的公有成员</li>
<li>每个类有应该有一个析构函数，如果没有显式定义，那么系统会自动生成一个默认的析构函数</li>
<li>析构函数的名称为在类名前加上<code>~</code></li>
<li>构造函数中使用了<code>new</code>（或者在堆区分配了动态内存），则必须提供使用<code>delete</code>的析构函数</li>
</ul>
<blockquote>
<p>析构函数调用时机</p>
</blockquote>
<ul>
<li>静态存储类对象：程序结束时自动调用</li>
<li>自动存储类对象：自动存储期结束时自动调用</li>
<li>new出来的对象：调用delete销毁对象时，自动调用</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">String</span>( <span class="keyword">char</span> *ch );  <span class="comment">// Declare constructor</span></span><br><span class="line">   ~<span class="built_in">String</span>();           <span class="comment">//  and destructor.</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">char</span>    *_text;</span><br><span class="line">   <span class="keyword">size_t</span>  sizeOfText;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">String::<span class="built_in">String</span>( <span class="keyword">char</span> *ch ) &#123;</span><br><span class="line">   sizeOfText = <span class="built_in">strlen</span>( ch ) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Dynamically allocate the correct amount of memory.</span></span><br><span class="line">   <span class="comment">// 动态分配内存</span></span><br><span class="line">   _text = <span class="keyword">new</span> <span class="keyword">char</span>[ sizeOfText ];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// If the allocation succeeds, copy the initialization string.</span></span><br><span class="line">   <span class="keyword">if</span>( _text )</span><br><span class="line">      <span class="built_in">strcpy_s</span>( _text, sizeOfText, ch );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">   <span class="comment">// Deallocate the memory that was previously reserved</span></span><br><span class="line">   <span class="comment">//  for this string.</span></span><br><span class="line">   <span class="keyword">delete</span>[] _text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="function">String <span class="title">str</span><span class="params">(<span class="string">&quot;The piper in the glen...&quot;</span>)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>str</code>是栈中的内存（自动存储类对象），当所在的作用域main函数退出时，<code>str</code>被销毁，此时执行析构函数，释放成员<code>_text</code>占用的堆区动态内存。</p>
<h4 id="8-2-5-改进Stock类"><a href="#8-2-5-改进Stock类" class="headerlink" title="8.2.5 改进Stock类"></a>8.2.5 改进Stock类</h4><p>将析构函数和构造函数加入到Stock类中。</p>
<ul>
<li>头文件：类的声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCK1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCK1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="keyword">long</span> shares;</span><br><span class="line">    <span class="keyword">double</span> share_val;</span><br><span class="line">    <span class="keyword">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock</span>();        <span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">Stock</span>(<span class="keyword">const</span> std::string &amp; co, <span class="keyword">long</span> n = <span class="number">0</span>, <span class="keyword">double</span> pr = <span class="number">0.0</span>);</span><br><span class="line">    ~<span class="built_in">Stock</span>();       <span class="comment">// noisy destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>类的成员函数实现（定义）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock1.cpp  Stock class implementation with constructors, destructor added</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors (verbose versions)</span></span><br><span class="line">Stock::<span class="built_in">Stock</span>() &#123;        <span class="comment">// default constructor</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default constructor called\n&quot;</span>;</span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="keyword">const</span> std::string &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Constructor using &quot;</span> &lt;&lt; co &lt;&lt; <span class="string">&quot; called\n&quot;</span>;</span><br><span class="line">    company = co;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                   &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        shares = n;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class destructor</span></span><br><span class="line">Stock::~<span class="built_in">Stock</span>() &#123;       <span class="comment">// verbose class destructor</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye, &quot;</span> &lt;&lt; company &lt;&lt; <span class="string">&quot;!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// other methods...</span></span><br></pre></td></tr></table></figure>
<ul>
<li>列表初始化：C++11支持</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stock hot_tip = &#123;<span class="string">&quot;hello&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>&#125;;</span><br><span class="line">Stock hot_tip &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">Stock temp &#123;&#125;; <span class="comment">// 调用默认构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对应于：</span></span><br><span class="line">Stock hot_tip = <span class="built_in">Stock</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">100</span>, <span class="number">45.0</span>);</span><br><span class="line">Stock hot_tip = <span class="built_in">Stock</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">Stock temp = <span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>const成员函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Stock land = <span class="built_in">Stock</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">land.<span class="built_in">show</span>(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>原因在于show无法保证land对象不会被修改。</p>
<p>C++的解决办法是将const关键字放在函数的括号后面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>同样的，在函数定义处：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的函数称为const成员函数。</p>
<h3 id="8-3-this指针"><a href="#8-3-this指针" class="headerlink" title="8.3 this指针"></a>8.3 this指针</h3><p>现在需要定义一个成员函数，查看两个Stock对象，并返回股价高的那个对象的引用，命名为<code>topval</code>。</p>
<p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="keyword">const</span> Stock &amp; s)</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数解释：该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其中一个对象的引用。括号中的 const 表明，该函数不会修改被显式地访问的对象；而括号后的 const 表明，该函数不会修改被隐式地访问的对象。由于该函数返回了两个const对象之一的引用，因此返回类型也应为const引用。</p>
<p>函数使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top = stock1.<span class="built_in">topval</span>(stock2);</span><br><span class="line">top = stock2.<span class="built_in">topval</span>(stock1);</span><br></pre></td></tr></table></figure>
<p>第一种格式隐式地访问 stock1，而显式地访问 stock2：第二种格式显式地访问 stock1，而隐式地访问stock2。无论使用哪一种方式，都将对这两个对象进行比较，并返回股价总值较高的那一个对象。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230106093329912.png" alt="image-20230106093329912"></p>
<p>函数定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="keyword">const</span> Stock &amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.total_val &gt; total_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ???; <span class="comment">// 如何返回隐式访问的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>s.total_val</code> 是作为参数传递的对象的总值，<code>total_val</code> 是用来调用该方法的对象的总值。如果<code>s.total_val</code>大于<code>total_val</code>，则函数将返回指向s的引用；否则，将返回用来调用该方法的对象。问题在于，如何称呼这个对象？如果调用<code>stock1.topval(stock2)</code>，则s是stock2 的引用（即stock2的别名），但stock1没有别名。</p>
<p>C++解决这种问题的方法是：使用被称为<code>this</code>的特殊指针。</p>
<p><strong>this指针指向用来调用成员函数的对象</strong>（this 被作为隐藏参数传递给方法）。这样，函数调用<code>stock1.topval(stock2)</code>将this设置为stock1对象的地址，使得这个指针可用于topval方法。相当于：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(Stock * <span class="keyword">const</span> <span class="keyword">this</span>, <span class="keyword">const</span> Stock &amp; s)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，所有的类方法都将this指针设置为调用它的对象的地址。this指针的用const修饰的，this指针本身是不能被修改的（不能指向其他地址），但是内容是可以修改的。</p>
<p>因此问题解决方法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="keyword">const</span> Stock &amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.total_val &gt; <span class="keyword">this</span>-&gt;total_val) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>this</code>指针的特性</p>
</blockquote>
<ul>
<li>this指针的类型：<code>类类型 * const</code></li>
<li>只能在成员函数的内部使用</li>
<li>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针</li>
<li>this指针是<strong>成员函数第一个隐含的指针形参</strong>，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递</li>
<li><strong>static静态成员函数不能使用this指针</strong>。原因是静态成员函数属于类，而不属于某个对象，所以static静态成员函数压根就没有this指针</li>
</ul>
<h3 id="8-4-对象数组"><a href="#8-4-对象数组" class="headerlink" title="8.4 对象数组"></a>8.4 对象数组</h3><p>对象数组的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock mystuff[<span class="number">4</span>]; <span class="comment">// 调用默认构造函数</span></span><br></pre></td></tr></table></figure>
<p>可以使用构造函数来初始化数组元素，这种情况下必须为每一个元素调用构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">3</span>;</span><br><span class="line">Stock stocks[STKS] = &#123;</span><br><span class="line">    <span class="built_in">Stock</span>();</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">12</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">Stock</span>(<span class="string">&quot;World&quot;</span>, <span class="number">12</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>过程：用花括号中的构造函数创建临时对象，然后将临时对象的内容复制到相应的元素中。</p>
<h3 id="8-5-类作用域"><a href="#8-5-类作用域" class="headerlink" title="8.5 类作用域"></a>8.5 类作用域</h3><h4 id="8-5-1-概念"><a href="#8-5-1-概念" class="headerlink" title="8.5.1 概念"></a>8.5.1 概念</h4><p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。</p>
<p>因此，可以在不同类中使用相同的类成员名而不会引起冲突。</p>
<p>另外，类作用域意味着不能从外部直接访问类的成员，公有成员函数也是如此。也就是说，要调用公有成员函数，必须通过对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stock <span class="title">sleeper</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="number">100</span>, <span class="number">0.25</span>)</span></span>;</span><br><span class="line">sleeper.<span class="built_in">show</span>();</span><br><span class="line"><span class="built_in">show</span>(); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>在类的作用域之外，类的数据和函数成员只能由<strong>对象、引用或者指针</strong>使用成员访问运算符（<code>.</code>）来访问。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ik</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> fuss;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Ik</span>(<span class="keyword">int</span> f = <span class="number">9</span>) &#123; fuss = f; &#125; <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ViewIk</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;; <span class="comment">// 类作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类作用域之外</span></span><br><span class="line"><span class="comment">// ------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用作用域解析运算符指明ViewIk函数位于Ik的类作用域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Ik::ViewIk</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; fuss &lt;&lt; endl; <span class="comment">// 类作用域中，fuss是可见的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Ik * pik = <span class="keyword">new</span> Ik;</span><br><span class="line">    Ik ee = <span class="built_in">Ik</span>(<span class="number">8</span>);</span><br><span class="line">    ee.<span class="built_in">ViewIk</span>(); <span class="comment">// 对象将ViewIk函数带入到类作用域</span></span><br><span class="line">    pik-&gt;<span class="built_in">ViewIk</span>(); <span class="comment">// 指向Ik的指针将ViewIk函数带入到类作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="8-5-2-作用域为类的常量"><a href="#8-5-2-作用域为类的常量" class="headerlink" title="8.5.2 作用域为类的常量"></a>8.5.2 作用域为类的常量</h4><p>有时候，使符号常量的作用域为类很有用。例如，类声明可能使用字面值30来指定数组的长度，由于该常量对于所有对象来说都是相同的，因此创建一个由所有对象共享的常量是个不错的主意。</p>
<p>C++提供了一种在类中定义常量的方式：使用关键字 <code>static</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bakary</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> Months = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">double</span> costs[Months];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这将创建一个名为 Months 的常量，<strong>该常量将与其他静态变量存储在一起，而不是存储在对象中</strong>。因此，只有一个Months 常量，被所有Bakery对象共享。</p>
<h3 id="8-6-抽象数据类型"><a href="#8-6-抽象数据类型" class="headerlink" title="8.6 抽象数据类型"></a>8.6 抽象数据类型</h3><p>Stock类非常具体。然而，程序员常常通过定义类来表示更通用的概念。例如，就实现计算机专家们所说的抽象数据类型（<code>abstract datatype，ADT</code>）而言，使用类是一种非常好的方式。</p>
<p>顾名思义，ADT以通用的方式描述数据类型，而没有引入语言或实现细节。抽象数据类型是指一个数学模型以及定义在这个模型上的一组操作。抽象数据类型的定义仅仅取决于它的一组逻辑特性，而与它在计算机中的表示和实现无关。</p>
<p>标准格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名 &#123;</span><br><span class="line">Data:</span><br><span class="line">	数据元素之间逻辑关系的定义;</span><br><span class="line">Operation:</span><br><span class="line">	操作<span class="number">1</span>;</span><br><span class="line">	操作<span class="number">2</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，通过使用栈，可以以这样的方式存储数据，即总是从堆顶添加或删除数据。</p>
<p>栈的基本操作：</p>
<ul>
<li>可创建空栈</li>
<li>可将数据项添加到堆顶（压入）</li>
<li>可从栈顶删除数据项（弹出）</li>
<li>可查看栈否填满</li>
<li>可查看栈是否为空</li>
</ul>
<p>可以将上述描述转换为一个类声明，其中公有成员函数提供了表示栈操作的接口，而私有数据成员负责存储栈数据。类概念非常适合于ADT方法。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<ul>
<li><code>stack.h</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.h -- class definition for the stack ADT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACK_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACK_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>MAX = <span class="number">10</span>&#125;;    <span class="comment">// constant specific to class</span></span><br><span class="line">    Item items[MAX];    <span class="comment">// holds stack items</span></span><br><span class="line">    <span class="keyword">int</span> top;            <span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// push() returns false if stack already is full, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>;   <span class="comment">// add item to stack</span></span><br><span class="line">    <span class="comment">// pop() returns false if stack already is empty, true otherwise</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>;          <span class="comment">// pop top into item</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>分析：</p>
<ol>
<li>私有部分表明，栈是使用数组实现的；而公有部分隐藏了这一点。因此，可以使用动态数组来代替数组，而不会改变类的接口。这意味着修改栈的实现后，不需要重新编写使用栈的程序，而只需重新编译栈代码，并将其与已有的程序代码链接起来即可。</li>
<li>接口是冗余的，因为 pop和 push返回有关栈状态的信息（满或空），而不是 void类型。在如何处理超出栈限制或者清空栈方面，这为程序员提供了两种选择。他可以在修改栈前使用isempty和isfull来查看，也可以使用 push和 pop的返回值来确定操作是否成功。</li>
<li>这个类不是根据特定的类型来定义栈，而是根据通用的<code>Item</code>类型来描述。在这个例子中，头文件使用typedef用Item代替unsigned long。如果需要 double 栈或结构类型的栈，则只需修改 typedef 语句，而类声明和方法定义保持不变。类模板（参见第14章）提供了功能更强大的方法，来将存储的数据类型与类设计隔离开来。</li>
</ol>
<ul>
<li><code>stack.cpp</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack.cpp -- Stack member functions</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stack.h&quot;</span></span></span><br><span class="line">Stack::<span class="built_in">Stack</span>() &#123;    <span class="comment">// create an empty stack</span></span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isempty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::isfull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::pop</span><span class="params">(Item &amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-类的使用"><a href="#9-类的使用" class="headerlink" title="9 类的使用"></a>9 类的使用</h2><h3 id="9-1-运算符重载"><a href="#9-1-运算符重载" class="headerlink" title="9.1 运算符重载"></a>9.1 运算符重载</h3><h4 id="9-1-1-概念和引入"><a href="#9-1-1-概念和引入" class="headerlink" title="9.1.1 概念和引入"></a>9.1.1 概念和引入</h4><p>和函数重载一样，运算符重载也是一种形式的C++多态。</p>
<p>C++允许将运算符重载扩展到用户定义的类型，例如，允许使用<code>+</code>将两个对象相加。编译器将根据操作数的数目和类型决定使用哪种加法定义。</p>
<blockquote>
<p>程序实例——两个时间相加</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime0.h -- Time class before operator overloading</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME0_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>();</span><br><span class="line">    <span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 分钟相加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">    <span class="comment">// 小时相加</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line">    <span class="comment">// 重置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 将小时和分钟相加</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Time <span class="title">Sum</span><span class="params">(<span class="keyword">const</span> Time &amp; t)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime0.cpp  -- implementing Time methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mytime0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>() &#123;</span><br><span class="line">    hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m ) &#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    minutes += m;</span><br><span class="line">    hours += minutes / <span class="number">60</span>;</span><br><span class="line">    minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> Time <span class="title">Time::Sum</span><span class="params">(<span class="keyword">const</span> Time &amp; t)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：函数Sum返回Time对象，而不是引用。前面说过，不要返回局部变量或临时对象的引用。此外，该方法返回时，是将sum对象复制（浅复制）一份返回，然后将局部变量sum释放。</p>
<h4 id="9-1-2-加法运算符重载示例"><a href="#9-1-2-加法运算符重载示例" class="headerlink" title="9.1.2 加法运算符重载示例"></a>9.1.2 加法运算符重载示例</h4><p>运算符重载的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[返回值] <span class="keyword">operator</span>[运算符] (参数...) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将Time类转换为重载的加法运算符很容易，只要将<code>Sum()</code>的名称改为<code>operator +()</code>即可。它是类的成员函数。</p>
<blockquote>
<p>修改后的代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime1.h -- Time class before operator overloading</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME1_H_</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total = coding.<span class="keyword">operator</span>+(fixing);</span><br><span class="line"><span class="comment">// 或者直接使用运算符+</span></span><br><span class="line">total = coding + fixing; <span class="comment">// 左侧视为调用对象，右侧视为函数的参数</span></span><br><span class="line"></span><br><span class="line">a = b + c + d;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">a = b.<span class="keyword">operator</span>+(c.<span class="keyword">operator</span>+(d));</span><br></pre></td></tr></table></figure>
<h4 id="9-1-3-重载限制"><a href="#9-1-3-重载限制" class="headerlink" title="9.1.3 重载限制"></a>9.1.3 重载限制</h4><p>可以重载的运算符如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230106143856435.png" alt="image-20230106143856435"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230106143906614.png" alt="image-20230106143906614"></p>
<p>重载的限制：</p>
<ul>
<li>重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（<code>-</code>）重载为计算两个double值的和，而不是它们的差。虽然这种限制将对创造性有所影响，但可以确保程序正常运行。</li>
<li>使用运算符时不能违反运算符原来的句法规则（操作数个数、优先级等）。例如，不能将求模运算符（<code>%</code>）重载成使用一个操作数。</li>
<li>不能创建新的运算符</li>
<li>以下运算符<strong>只能通过成员函数</strong>进行重载：<ul>
<li><code>=</code>：赋值运算符</li>
<li><code>()</code>：函数调用运算符</li>
<li><code>[]</code>：下标运算符</li>
<li><code>-&gt;</code>：通过指针访问类成员的运算符</li>
</ul>
</li>
</ul>
<h4 id="9-1-4-其他重载示例"><a href="#9-1-4-其他重载示例" class="headerlink" title="9.1.4 其他重载示例"></a>9.1.4 其他重载示例</h4><p>例如将相减和相乘重载为时间相减和相乘。</p>
<blockquote>
<p>代码示例——只列出重要代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time diff;</span><br><span class="line">    <span class="keyword">int</span> tot1, tot2;</span><br><span class="line">    tot1 = t.minutes + <span class="number">60</span> * t.hours;</span><br><span class="line">    tot2 = minutes + <span class="number">60</span> * hours;</span><br><span class="line">    diff.minutes = (tot2 - tot1) % <span class="number">60</span>;</span><br><span class="line">    diff.hours = (tot2 - tot1) / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time_a = time_b - time_c;</span><br><span class="line"><span class="comment">// 等价于：或者编译器认为</span></span><br><span class="line">time_a = time_b.<span class="keyword">operator</span>-(time_c);</span><br><span class="line"></span><br><span class="line">time_a = time_b * <span class="number">1.2</span>;</span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line">time_a = time_b.<span class="keyword">operator</span>*(<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">// 注意：不能写为：</span></span><br><span class="line">time_a = <span class="number">1.2</span> * time_b;</span><br></pre></td></tr></table></figure>
<p>最后一行不能成立的理由是：<code>1.2</code>不是Time类的对象，而<code>time_b</code>也不是double类型。</p>
<h3 id="9-2-友元"><a href="#9-2-友元" class="headerlink" title="9.2 友元"></a>9.2 友元</h3><h4 id="9-2-1-概念"><a href="#9-2-1-概念" class="headerlink" title="9.2.1 概念"></a>9.2.1 概念</h4><p>私有成员对于类外部的所有程序部分来说都是隐藏的，访问它们需要调用一个公共成员函数，但有时也可能会需要创建该规则的一项例外。 </p>
<p>友元是用<code>friend</code>关键字修饰的函数或者类，友元用来打破类的封装。</p>
<p>友元分为三种：</p>
<ul>
<li>友元函数</li>
<li>友元类</li>
<li>友元成员函数</li>
</ul>
<hr>
<p>上面的乘法运算将Time对象和double结合在一起：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = B * <span class="number">2.75</span>;</span><br><span class="line"><span class="comment">// 即</span></span><br><span class="line">A = B.<span class="keyword">operator</span>*(<span class="number">2.75</span>);</span><br></pre></td></tr></table></figure>
<p>如果将B和2.75调换顺序，由于2.75并不是Time对象，因此编译器不能使用成员函数调用来替换该表达式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">2.75</span> * B; <span class="comment">// 语义和B * 2.75一致</span></span><br></pre></td></tr></table></figure>
<p>一种解决方法是，使用<strong>非成员函数</strong>来对乘法进行重载：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">A = <span class="number">2.75</span> * B;</span><br><span class="line"><span class="comment">// 被解释为</span></span><br><span class="line">A = <span class="keyword">operator</span>*(<span class="number">2.75</span>, B);</span><br></pre></td></tr></table></figure>
<p>非成员函数存在的问题是，不能访问类的私有数据，于是引入友元。</p>
<h4 id="9-2-2-创建友元"><a href="#9-2-2-创建友元" class="headerlink" title="9.2.2 创建友元"></a>9.2.2 创建友元</h4><p>创建友元函数是将<strong>函数原型放在类的声明</strong>中，并用<code>friend</code>修饰：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure>
<p>作用：</p>
<ul>
<li>虽然<code>operator*()</code>在类声明中声明，但它不是类的成员函数</li>
<li>虽然<code>operator*()</code>不是类的成员函数，但具有与成员函数相同的访问权限</li>
</ul>
<p>函数定义：注意，因为它不是成员函数，所以不用<code>Time::</code>限定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="comment">// 非成员函数使用类的私有成员</span></span><br><span class="line">    <span class="keyword">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以用友元函数来反转操作数的顺序。</p>
<h4 id="9-2-3-常用的友元：重载-lt-lt-运算符"><a href="#9-2-3-常用的友元：重载-lt-lt-运算符" class="headerlink" title="9.2.3 常用的友元：重载&lt;&lt;运算符"></a>9.2.3 常用的友元：重载&lt;&lt;运算符</h4><p>使用重载<code>&lt;&lt;</code>运算符来打印对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; trip; <span class="comment">// trip is a Time object</span></span><br></pre></td></tr></table></figure>
<p>之所以可以这样做，是因为<code>&lt;&lt;</code>是可被重载的C++运算符之一。</p>
<p>实际上，它已经被重载很多次了。最初，<code>&lt;&lt;</code>运算符是C和C++的位运算符，将值中的位左移。ostream类对该运算符进行了重载，将其转换为一个输出工具。前面讲过，cout是一个ostream对象，它是智能的，能够识别所有的C++基本类型。这是因为对于每种基本类型，ostream类声明中都包含了相应的重载的<code>operator&lt;&lt;()</code>定义。也就是说，一个定义使用int参数，一个定义使用double参数，等等。因此，要使cout能够识别Time对象，一种方法是将一个新的函数运算符定义添加到 ostream 类声明中。但修改 iostream 文件是个危险的主意，这样做会在标准接口上浪费时间。相反，<strong>通过Time类声明来让Time类知道如何使用cout</strong>。</p>
<blockquote>
<p>成员函数和友元函数的重载版本</p>
</blockquote>
<p>如果使用Time成员函数来重载<code>&lt;&lt;</code>，则第一个操作数必须是Time对象，意味着会这样打印对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型，在类中</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">void</span> Time::<span class="keyword">operator</span>&lt;&lt;(ostream &amp; os) &#123;</span><br><span class="line">    os &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trip &lt;&lt; cout;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">trip.<span class="keyword">operator</span>&lt;&lt;(cout);</span><br></pre></td></tr></table></figure>
<p>这样会让人迷惑，但通过友元函数，可以使参数反转：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是可以使用下面的语句打印Time对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; trip;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(cout, trip);</span><br></pre></td></tr></table></figure>
<p>注意，该友元函数是Time类的友元，因为它必须访问Time类对象的私有成员，但它不是ostream的友元，因此不必修改osteam的定义。</p>
<blockquote>
<p>改进版本</p>
</blockquote>
<p>当打印多条语句时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">6</span>;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">(cout &lt;&lt; x) &lt;&lt; y;</span><br></pre></td></tr></table></figure>
<p>因此重载&lt;&lt;运算符函数应该返回<code>ostream</code>对象的引用，才能连续输出。</p>
<p>对于上面的友元函数版本，不能处理如下语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Trip time: &quot;</span> &lt;&lt; trip &lt;&lt; <span class="string">&quot; Tuesday\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>需要修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Time类改进</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime3.h -- Time class with friends</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYTIME3_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYTIME3_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> hours;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>();</span><br><span class="line">    <span class="built_in">Time</span>(<span class="keyword">int</span> h, <span class="keyword">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddMin</span><span class="params">(<span class="keyword">int</span> m)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddHr</span><span class="params">(<span class="keyword">int</span> h)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">int</span> h = <span class="number">0</span>, <span class="keyword">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="keyword">const</span> Time &amp; t) <span class="keyword">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="keyword">double</span> n) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp; t)</span><br><span class="line">        &#123; <span class="keyword">return</span> t * m; &#125;   <span class="comment">// 内联定义</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> Time &amp; t);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实现：只列出重要代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="keyword">double</span> mult) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="keyword">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> Time &amp; t) &#123;</span><br><span class="line">    os &lt;&lt; t.hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; t.minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>小结：对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。一般来说，<strong>非成员函数应是友元函数</strong>，这样它才能直接访问类的私有数据。</p>
<h3 id="9-3-类的自动和强制类型转换"><a href="#9-3-类的自动和强制类型转换" class="headerlink" title="9.3 类的自动和强制类型转换"></a>9.3 类的自动和强制类型转换</h3><h4 id="9-3-1-构造函数转换"><a href="#9-3-1-构造函数转换" class="headerlink" title="9.3.1 构造函数转换"></a>9.3.1 构造函数转换</h4><blockquote>
<p>引出：内置类型的转换</p>
</blockquote>
<p>隐式转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">8</span>; <span class="comment">// int -&gt; long</span></span><br><span class="line"><span class="keyword">double</span> time = <span class="number">11</span>; <span class="comment">// int -&gt; double</span></span><br><span class="line"><span class="keyword">int</span> side = <span class="number">3.33</span>;  <span class="comment">// double -&gt; int，会丢失精度</span></span><br></pre></td></tr></table></figure>
<p>C++不自动转换不兼容的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = <span class="number">10</span>; <span class="comment">//error!整数和地址不能转换</span></span><br></pre></td></tr></table></figure>
<p>但是可以进行强制类型转换（显式转换）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span> *)<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>使用磅（<code>pounds</code>）和英石（<code>stone</code>）来表示重量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stonewt.h -- definition for the Stonewt class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONEWT_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STONEWT_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stonewt</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>Lbs_per_stn = <span class="number">14</span>&#125;;      <span class="comment">// 1英石对应14磅</span></span><br><span class="line">    <span class="keyword">int</span> stone;                    <span class="comment">// 英石数</span></span><br><span class="line">    <span class="keyword">double</span> pds_left;              <span class="comment">// 磅的分数部分</span></span><br><span class="line">    <span class="keyword">double</span> pounds;                <span class="comment">// 磅数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以磅初始化</span></span><br><span class="line">    <span class="built_in">Stonewt</span>(<span class="keyword">double</span> lbs);</span><br><span class="line">    <span class="comment">// 以磅和英石初始化</span></span><br><span class="line">    <span class="built_in">Stonewt</span>(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs);</span><br><span class="line">    <span class="comment">// 默认构造</span></span><br><span class="line">    <span class="built_in">Stonewt</span>();                    </span><br><span class="line">    ~<span class="built_in">Stonewt</span>();</span><br><span class="line">    <span class="comment">// 以磅为单位显示重量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_lbs</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 以英石为单位显示重量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show_stn</span><span class="params">()</span> <span class="keyword">const</span></span>;        </span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stonewt.cpp -- Stonewt methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stonewt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将double类型转换为（构造出）Stonewt对象</span></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="keyword">double</span> lbs) &#123;</span><br><span class="line">    stone = <span class="built_in"><span class="keyword">int</span></span> (lbs) / Lbs_per_stn;    <span class="comment">// integer division</span></span><br><span class="line">    pds_left = <span class="built_in"><span class="keyword">int</span></span> (lbs) % Lbs_per_stn + lbs - <span class="built_in"><span class="keyword">int</span></span>(lbs);</span><br><span class="line">    pounds = lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int和double类型转换为（构造出）Stonewt对象</span></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs) &#123;</span><br><span class="line">    stone = stn;</span><br><span class="line">    pds_left = lbs;</span><br><span class="line">    pounds =  stn * Lbs_per_stn +lbs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::<span class="built_in">Stonewt</span>() &#123;        <span class="comment">// default constructor, wt = 0</span></span><br><span class="line">    stone = pounds = pds_left = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stonewt::~<span class="built_in">Stonewt</span>() &#123;         <span class="comment">// destructor</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show weight in stones</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stonewt::show_stn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; stone &lt;&lt; <span class="string">&quot; stone, &quot;</span> &lt;&lt; pds_left &lt;&lt; <span class="string">&quot; pounds\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// show weight in pounds</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stonewt::show_lbs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; pounds &lt;&lt; <span class="string">&quot; pounds\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类Stonewt现在可以通过将整数或浮点值转换为Stonewt对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>; <span class="comment">// 通过构造函数Stonewt(double lbs)，将double转换为Stonewt</span></span><br></pre></td></tr></table></figure>
<p>首先，程序使用构造函数创建一个临时的Stonewt对象，并用19.6作为初始化值，然后将该临时对象的内容浅复制到myCat中，然后释放临时对象，这一过程称为<strong>隐式转换</strong>，或者<strong>自动转换</strong>。</p>
<p><strong>只有接受一个参数的构造函数才能作为转换函数</strong>，下面的函数不能用来转换类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs); <span class="comment">// 有两个参数</span></span><br><span class="line"></span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">1</span>, <span class="number">19.6</span>; <span class="comment">// 不能这样使用</span></span><br></pre></td></tr></table></figure>
<p>如果第二个参数有默认值，则可以，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stonewt::<span class="built_in">Stonewt</span>(<span class="keyword">int</span> stn, <span class="keyword">double</span> lbs = <span class="number">0.1</span>);</span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">10</span>; <span class="comment">// // 通过构造函数Stonewt(int stn, double lbs = 0.1)，将int类型转换为Stonewt类型</span></span><br></pre></td></tr></table></figure>
<p>下面的场合也会导致隐式转换：</p>
<ul>
<li>将对象初始化为double，例如<code>Stonewt myCat = 19.6;</code></li>
<li>将 double 值传递给接受 Stonewt参数的函数时</li>
<li>返回值被声明为Stonewt的函数试图返回double值时</li>
<li>在上述任意一种情况下，使用可转换为double类型的内置类型（例如int）时</li>
</ul>
<p>此外，隐式转换的特性可以通过关键字<code>explicit</code>关闭，这种情况下只能使用显式的强制类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Stonewt</span><span class="params">(<span class="keyword">double</span> lbs)</span></span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Stonewt myCat;</span><br><span class="line">myCat = <span class="number">19.6</span>; <span class="comment">// error!</span></span><br><span class="line">myCat = (Stonewt) <span class="number">19.6</span>; <span class="comment">// OK!</span></span><br><span class="line">myCat = <span class="built_in">Stonewt</span>(<span class="number">19.6</span>); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure>
<p>总结：构造函数（隐式转换）只用于从某种类型到类类型的转换。</p>
<h4 id="9-3-2-转换函数转换"><a href="#9-3-2-转换函数转换" class="headerlink" title="9.3.2 转换函数转换"></a>9.3.2 转换函数转换</h4><p>问题：能否将类类型转换为double？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">wolf</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> host = wolf; <span class="comment">// ??</span></span><br></pre></td></tr></table></figure>
<p>回答：可以，但不能使用构造函数，而是使用特殊的C++运算符函数——转换函数。</p>
<p><strong>转换函数是用户定义的强制类型转换</strong>。显式转换例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">wolf</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> thinker = <span class="built_in"><span class="keyword">double</span></span> (wolf); <span class="comment">// 语法格式1</span></span><br><span class="line"><span class="keyword">double</span> host = (<span class="keyword">double</span>) wolf; <span class="comment">// 语法格式2</span></span><br></pre></td></tr></table></figure>
<p>也可以通过编译器判断来隐式转换，即通过左值的类型判断隐式转换的类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">wolf</span><span class="params">(<span class="number">285.7</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> thinker = wolf; <span class="comment">// 隐式转换为double类型</span></span><br></pre></td></tr></table></figure>
<hr>
<p>转换函数语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>; <span class="comment">// typeName可以是int，double等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>转换函数必须是类方法，由类对象来调用；</li>
<li>转换函数不能指定返回类型；</li>
<li>转换函数不能有参数。</li>
</ul>
<p>修改后的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stonewt1.h -- revised definition for the Stonewt class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STONEWT1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STONEWT1_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stonewt</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in"><span class="keyword">int</span></span> (pounds + <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Stonewt::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pounds; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stonewt <span class="title">poppins</span><span class="params">(<span class="number">9</span>, <span class="number">2.8</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> p_wt = poppins; <span class="comment">// p_wt = 2.8，隐式转换</span></span><br><span class="line"><span class="keyword">double</span> p_wt = (<span class="keyword">double</span>) popins; <span class="comment">// 显式的强制转换</span></span><br></pre></td></tr></table></figure>
<p>在C++11中，也可以将转换运算符声明为显式的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样只能采取显式的强制转换。</p>
<h2 id="10-类和动态内存分配"><a href="#10-类和动态内存分配" class="headerlink" title="10 类和动态内存分配"></a>10 类和动态内存分配</h2><h3 id="10-1-动态内存和类"><a href="#10-1-动态内存和类" class="headerlink" title="10.1 动态内存和类"></a>10.1 动态内存和类</h3><h4 id="10-1-1-问题引入"><a href="#10-1-1-问题引入" class="headerlink" title="10.1.1 问题引入"></a>10.1.1 问题引入</h4><p>一个模拟<code>String</code>类的但有问题的<code>StringBad</code>类。</p>
<ul>
<li><code>strngbad.h</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strngbad.h -- flawed string class definition</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRNGBAD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRNGBAD_H_</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringBad</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * str;                <span class="comment">// pointer to string</span></span><br><span class="line">    <span class="keyword">int</span> len;                   <span class="comment">// length of string</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings;    <span class="comment">// number of objects</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringBad</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s); <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">StringBad</span>();               <span class="comment">// default constructor</span></span><br><span class="line">    ~<span class="built_in">StringBad</span>();              <span class="comment">// destructor</span></span><br><span class="line"><span class="comment">// friend function</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, </span><br><span class="line">                       <span class="keyword">const</span> StringBad &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>strngbad.cpp</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strngbad.cpp -- StringBad class methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>                    <span class="comment">// string.h for some</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strngbad.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initializing static class member</span></span><br><span class="line"><span class="keyword">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct StringBad from C string</span></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);             <span class="comment">// set size</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];          <span class="comment">// allot storage，因为下面的strcpy会赋值0字符</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);              <span class="comment">// initialize pointer</span></span><br><span class="line">    num_strings++;                    <span class="comment">// set object count</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;    <span class="comment">// For Your Information</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>() &#123;               <span class="comment">// default constructor</span></span><br><span class="line">    len = <span class="number">4</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">4</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, <span class="string">&quot;C++&quot;</span>);          <span class="comment">// default string</span></span><br><span class="line">    num_strings++;</span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\&quot; default object created\n&quot;</span>;  <span class="comment">// FYI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::~<span class="built_in">StringBad</span>() &#123;              <span class="comment">// necessary destructor</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object deleted, &quot;</span>;    <span class="comment">// FYI</span></span><br><span class="line">    --num_strings;                    <span class="comment">// required</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left\n&quot;</span>; <span class="comment">// FYI</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;                    <span class="comment">// required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="keyword">const</span> StringBad &amp; st) &#123;</span><br><span class="line">    os &lt;&lt; st.str;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序分析：</p>
<p>在类的定义中，对静态成员进行了初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>请注意，<strong>不能在类声明中初始化静态成员变量</strong>，这是因为声明描述了如何分配内存，但并不分配内存。对于静态类成员，可以在类声明之外使用单独的语句来讲行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。请注意，初始化语句指出了类型，并使用了作用域运算符，但没有使用关键字 static。</p>
<p>初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。</p>
<hr>
<blockquote>
<p>测试代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vegnews.cpp -- using new and delete with classes</span></span><br><span class="line"><span class="comment">// compile with strngbad.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;strngbad.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp;)</span></span>;  <span class="comment">// pass by reference</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme2</span><span class="params">(StringBad)</span></span>;    <span class="comment">// pass by value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::endl; </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Starting an inner block.\n&quot;</span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">headline1</span><span class="params">(<span class="string">&quot;Celery Stalks at Midnight&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">headline2</span><span class="params">(<span class="string">&quot;Lettuce Prey&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">StringBad <span class="title">sports</span><span class="params">(<span class="string">&quot;Spinach Leaves Bowl for Dollars&quot;</span>)</span></span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sports: &quot;</span> &lt;&lt; sports &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">callme1</span>(headline1);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;headline1: &quot;</span> &lt;&lt; headline1 &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 按值传递，调用复制构造函数</span></span><br><span class="line">        <span class="built_in">callme2</span>(headline2);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Initialize one object to another:\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 初始化对象时，调用复制构造函数</span></span><br><span class="line">        StringBad sailor = sports;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sailor: &quot;</span> &lt;&lt; sailor &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Assign one object to another:\n&quot;</span>;</span><br><span class="line">        StringBad knot;</span><br><span class="line">        <span class="comment">// 赋值运算符重载</span></span><br><span class="line">        knot = headline1;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;knot: &quot;</span> &lt;&lt; knot &lt;&lt; endl; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Exiting the block.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;End of main()\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="comment">// 打印字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme1</span><span class="params">(StringBad &amp; rsb)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String passed by reference:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;    \&quot;&quot;</span> &lt;&lt; rsb &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递打印字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme2</span><span class="params">(StringBad sb)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String passed by value:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Starting an inner block.</span><br><span class="line"><span class="number">1</span>: <span class="string">&quot;Celery Stalks at Midnight&quot;</span> object created </span><br><span class="line"><span class="number">2</span>: <span class="string">&quot;Lettuce Prey&quot;</span> object created</span><br><span class="line"><span class="number">3</span>: <span class="string">&quot;Spinach Leaves Bowl for Dollars&quot;</span> object created </span><br><span class="line">headlinel: Celery Stalks at Midnight headline2:Lettuce Prey</span><br><span class="line">sports: Spinach Leaves Bowl <span class="keyword">for</span> Dollars </span><br><span class="line">String passed by reference:<span class="string">&quot;Celery Stalks at Midnight&quot;</span></span><br><span class="line">headlinel: Celery Stalks at Midnight </span><br><span class="line">String passed by value:<span class="string">&quot;Lettuce Prey&quot;</span></span><br><span class="line"><span class="string">&quot;Lettuce Prey&quot;</span> object deleted,<span class="number">2</span> left </span><br><span class="line"><span class="comment">// 第一次出现了乱码</span></span><br><span class="line">headline2:Dü°</span><br><span class="line">Initialize one object to another:</span><br><span class="line">sailor: Spinach Leaves Bowl <span class="keyword">for</span> Dollars </span><br><span class="line">Assign one object to another:</span><br><span class="line"><span class="number">3</span>:<span class="string">&quot;C++&quot;</span> <span class="keyword">default</span> object created</span><br><span class="line">knot: Celery Stalks at Midnight </span><br><span class="line">Exiting the block. <span class="comment">// 退出代码块，调用析构函数</span></span><br><span class="line"><span class="string">&quot;Celery Stalks at Midnight&quot;</span> object deleted, <span class="number">2</span> left </span><br><span class="line"><span class="string">&quot;Spinach Leaves Bowl for Dollars&quot;</span> object deleted, <span class="number">1</span> left </span><br><span class="line"><span class="string">&quot;Spinach Leaves Bowl for Doll8&quot;</span> object deleted, <span class="number">0</span> left </span><br><span class="line"><span class="comment">// 第二次出现乱码</span></span><br><span class="line"><span class="string">&quot;@g&quot;</span> object deleted, <span class="number">-1</span> left </span><br><span class="line"><span class="string">&quot;-|&quot;</span> object deleted,<span class="number">-2</span> <span class="function">left </span></span><br><span class="line"><span class="function">End of <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>每个对象被构造和析构一次，因此调用构造函数的次数与调用析构函数的次数相同。对象计数<code>num_strings</code>最后值为-2，说明不将<code>num_strings</code>递增的构造函数创建了两个对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBad sailor = sports;</span><br></pre></td></tr></table></figure>
<p>这种形式的初始化等效于下面的语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBad sailor = <span class="built_in">StringBad</span>(sports);</span><br></pre></td></tr></table></figure>
<p>相应的构造函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringBad</span>(<span class="keyword">const</span> StringBad &amp;);</span><br></pre></td></tr></table></figure>
<p>当使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为<strong>复制构造函数</strong>，因为它创建对象的一个副本）。自动生成的构造函数不知道需要更新静态变量<code>num_string</code>，因此会将计数方案搞乱。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。</p>
<h4 id="10-1-2-复制构造函数"><a href="#10-1-2-复制构造函数" class="headerlink" title="10.1.2 复制构造函数"></a>10.1.2 复制构造函数</h4><p>C++自动为类提供下面的成员函数：</p>
<ul>
<li>默认构造函数，如果没有定义构造函数；</li>
<li>默认析构函数，如果没有定义；</li>
<li>复制构造函数，如果没有定义；</li>
<li>赋值运算符的重载函数，如果没有定义；</li>
<li>地址运算符的重载函数，如果没有定义；</li>
</ul>
<p>复制构造函数用于将一个对象复制（浅复制）到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递参数，按值传递实际上是将实参复制一份给形参，即创建实参的一个副本），而不是常规的赋值过程中。</p>
<p>类的复制构造函数原型通常如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Class_name</span>(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<p>调用时机：新建一个对象并将其<strong>初始化</strong>为同类现有对象时，复制构造函数都将被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设motto对象已被创建，以下情形都将调用复制构造函数</span></span><br><span class="line"><span class="function">StringBad <span class="title">ditto</span><span class="params">(motto)</span></span>;</span><br><span class="line">String metto = motto;</span><br><span class="line">StringBad also = <span class="built_in">StringBad</span>(motto);</span><br><span class="line">StringBad * pStringBad = <span class="keyword">new</span> <span class="built_in">StringBad</span>(motto);</span><br></pre></td></tr></table></figure>
<p>例如，上面的程序清单中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">callme2</span>(headline2);</span><br></pre></td></tr></table></figure>
<p>程序将使用复制构造函数初始化<code>sb</code>，即函数<code>callme2</code>的形参。</p>
<p>由于按值传递对象将调用复制构造函数，因此应该<strong>按引用传递对象</strong>。这样可以节省调用构造函数的时间以及存储新对象的空间。</p>
<p>注意：隐式实现（编译器自动生成）的复制构造函数的复制是<strong>浅复制</strong>，或者说是<strong>按位复制内存</strong>。具体来说，就是将 sports 所在内存中的数据按照二进制位（Bit）复制到 sailor 所在的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StringBad sailor = sports;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line">StringBad sailor;</span><br><span class="line">sailor.str = sports.str;</span><br><span class="line">sailor.len = sports.len;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230106120209739.png" alt="image-20230106120209739"></p>
<blockquote>
<p>程序出现的问题</p>
</blockquote>
<p>对象计数<code>num_strings</code>出现了负值，原因在于<code>callme2</code>使用了按值传递，而默认复制构造函数没有操作对象计数。</p>
<p>解决办法是显式实现一个复制构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="keyword">const</span> StringBad &amp; s) &#123;</span><br><span class="line">    num_strings++;</span><br><span class="line">    <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，执行结果第一次出现乱码的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">headline2:Dü°</span><br></pre></td></tr></table></figure>
<p>原因在于：按值传递时，出现了浅复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">callme2</span>(headline2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callme2</span><span class="params">(StringBad sb)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;String passed by value:\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;    \&quot;&quot;</span> &lt;&lt; sb &lt;&lt; <span class="string">&quot;\&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于：</span></span><br><span class="line">StringBad sb = headline2;</span><br><span class="line">sb.str = headline2.str;</span><br><span class="line">sb.len = headline2.len;</span><br></pre></td></tr></table></figure>
<p>sb对象和headline2对象的字符指针str均指向同一个内存地址。当<code>callme2</code>返回时，函数栈中的sb对象销毁，调用析构函数，释放该字符指针指向的内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] str; <span class="comment">// 即：delete [] sb.str;</span></span><br></pre></td></tr></table></figure>
<p>程序回到<code>main</code>函数的代码块：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;headline2: &quot;</span> &lt;&lt; headline2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>此时，headline2的字符指针指向的内存是被释放的内存，所以出现乱码。此外，退出代码块时，headline2被销毁，调用析构函数，再次释放已经释放的内存，还可能导致程序异常终止。</p>
<blockquote>
<p>问题的解决</p>
</blockquote>
<p><strong>如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深复制</strong>，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅复制足以。</p>
<p>所以在复制构造函数中使用<strong>深复制</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="keyword">const</span> StringBad &amp; st) &#123;</span><br><span class="line">    num_strings++;</span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>]; <span class="comment">// 新开辟内存</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, st.str); <span class="comment">// 将原始对象str的内容复制到该对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230106123617521.png" alt="image-20230106123617521"></p>
<h4 id="10-1-3-赋值运算符"><a href="#10-1-3-赋值运算符" class="headerlink" title="10.1.3 赋值运算符"></a>10.1.3 赋值运算符</h4><p>ANSI C允许结构赋值，而C++允许类对象赋值，这是通过<strong>自动为类重载赋值运算符</strong>实现的。这种运算符的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> Class_name &amp;);</span><br></pre></td></tr></table></figure>
<p>将已有的对象赋给另一个对象（注意不是在初始化时，否则调用复制构造函数）时，将使用重载的赋值运算符，隐式实现的赋值运算符也是浅复制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringBad knot;</span><br><span class="line">knot = headline1;</span><br></pre></td></tr></table></figure>
<p>为headline1调用析构函数时，显示乱码的问题和复制构造函数的浅复制问题一样。</p>
<blockquote>
<p>问题的解决</p>
</blockquote>
<p>解决办法是显式实现赋值运算符的重载，并提供深度复制。</p>
<p>注意点：</p>
<ul>
<li>由于复制对象可能引用了以前分配的数据，因此需要使用<code>delete</code>来释放</li>
<li>函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内存操作可能删除对象的内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringBad &amp; StringBad::StringBad=(<span class="keyword">const</span> StringBad &amp; st) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;st) &#123; <span class="comment">// 若是自己给自己赋值，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] str; <span class="comment">// 释放之前分配的内存</span></span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-2-改进后的新String类"><a href="#10-2-改进后的新String类" class="headerlink" title="10.2 改进后的新String类"></a>10.2 改进后的新String类</h3><p>现在将StringBad类重命名为String类，并新增以下方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span><span class="keyword">const</span></span>&#123; <span class="keyword">return</span> len;&#125;</span><br><span class="line"><span class="comment">// 比较两个字符串大小</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp;st,<span class="keyword">const</span> String &amp;st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> String &amp;st1,<span class="keyword">const</span> String &amp;st2);</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;st,<span class="keyword">const</span> String &amp;st2);</span><br><span class="line"><span class="comment">// 输入字符串</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">operator</span>&gt;&gt;(istream&amp;is,String&amp;st);</span><br><span class="line"><span class="comment">// 根据索引返回字符</span></span><br><span class="line"><span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// 返回num_strings，静态类成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-1-修改后的默认构造函数"><a href="#10-2-1-修改后的默认构造函数" class="headerlink" title="10.2.1 修改后的默认构造函数"></a>10.2.1 修改后的默认构造函数</h4><p>修改后的默认构造函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>() &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，析构函数中的释放方式为：<code>delete[]</code>，因此必须以<code>new[]</code>的方式来初始化指针或空指针。</p>
<p>上面的代码也可以修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>() &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    str = <span class="number">0</span>; <span class="comment">// 设置空指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在C++98中，字面值0可以表示数值0，也可以表示空指针（或者使用宏<code>NULL</code>表示，它的本质也是常量值0）。C++11中引入了新的关键字<code>nullptr</code>来表示空指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="literal">nullptr</span>; <span class="comment">// 也是可行的方式</span></span><br></pre></td></tr></table></figure>
<p>注：<strong>空指针指向0，大多数系统中都将0作为不被使用的地址</strong></p>
<h4 id="10-2-2-比较成员函数"><a href="#10-2-2-比较成员函数" class="headerlink" title="10.2.2 比较成员函数"></a>10.2.2 比较成员函数</h4><p>使用库函数<code>strcmp</code>来比较：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp; st1, <span class="keyword">const</span> String &amp; st2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(std::<span class="built_in">strcmp</span>(st1.str, st2.str) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以简化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp; st1, <span class="keyword">const</span> String &amp; st2)&#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">strcmp</span>(st1.str, st2.str) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理对<code>operator&gt;</code>和<code>operator==</code>的实现一致。</p>
<p>使用：假设answe是String类对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">&quot;love&quot;</span> == answer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将被转换为：</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="string">&quot;love&quot;</span>, answer));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将love通过构造函数String(const char * s)隐式转换：</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">operator</span>==(<span class="built_in">String</span>(<span class="string">&quot;love&quot;</span>), answer);</span><br></pre></td></tr></table></figure>
<h4 id="10-2-3-中括号访问字符"><a href="#10-2-3-中括号访问字符" class="headerlink" title="10.2.3 中括号访问字符"></a>10.2.3 中括号访问字符</h4><p>可以使用<code>operator[]()</code>来重载该运算符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则使用时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">opera</span><span class="params">(<span class="string">&quot;The Magic Flute&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> c = opera[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// C++将查找名称与特征标与此相同的方法：</span></span><br><span class="line">String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line"><span class="comment">// 然后替换为：</span></span><br><span class="line"><span class="keyword">char</span> c = opera.<span class="keyword">operator</span>[](<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 即：</span></span><br><span class="line"><span class="keyword">char</span> c = opera.str[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>将类型声明为<code>char &amp;</code>，便可以对特定元素赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">opera[<span class="number">0</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"><span class="comment">// 替换为</span></span><br><span class="line">opera.<span class="keyword">operator</span>[](<span class="number">0</span>) = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际上左侧返回的是opera.str[0]的引用，即为：</span></span><br><span class="line">opera.str[<span class="number">0</span>] = <span class="string">&#x27;r&#x27;</span>;</span><br></pre></td></tr></table></figure>
<hr>
<p>如果有常量对象：<code>const String answer(futile);</code>，则只有上述的重载定义时，下面的语句会报错：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; answer[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>原因在于answer是常量，<code>String::operator[](int i)</code>方法无法保证是否会修改原始数据，因此需要额外提供一份针对const对象的重载定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-4-静态类成员函数"><a href="#10-2-4-静态类成员函数" class="headerlink" title="10.2.4 静态类成员函数"></a>10.2.4 静态类成员函数</h4><p>可以将类的成员函数设置为静态的（<code>static</code>），此时对该函数有一定的限制：</p>
<ul>
<li>不能通过对象调用该函数</li>
<li>静态成员函数不能使用类中的非静态数据和this指针</li>
<li>静态类成员函数只能使用类中的静态数据</li>
</ul>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num_strings &#125;; <span class="comment">// inline</span></span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = String::<span class="built_in">HowMany</span>();</span><br></pre></td></tr></table></figure>
<h4 id="10-2-5-进一步重载赋值运算符"><a href="#10-2-5-进一步重载赋值运算符" class="headerlink" title="10.2.5 进一步重载赋值运算符"></a>10.2.5 进一步重载赋值运算符</h4><p>假设要讲一个常规字符串复制到String对象中，利用现有的String类，代码为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String name;</span><br><span class="line"><span class="keyword">char</span> temp[<span class="number">40</span>];</span><br><span class="line">cin.<span class="built_in">getline</span>(temp, <span class="number">40</span>);</span><br><span class="line">name = temp;</span><br></pre></td></tr></table></figure>
<p>最后一条语句的执行流程：</p>
<ul>
<li>首先使用<code>String(const char *)</code>构造函数将字符数组temp隐式转换为String类的临时对象，即<code>String t(temp)</code>；</li>
<li>使用赋值运算符的重载<code>String &amp; String::operator=(const String &amp;)</code>，深复制临时对象<code>t</code>到<code>name</code>对象中</li>
<li>临时对象<code>t</code>释放，并调用析构函数</li>
</ul>
<p>为了提高处理效率，对赋值运算符进行重载，使得能够直接使用常规的字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-2-6-修改后的String代码"><a href="#10-2-6-修改后的String代码" class="headerlink" title="10.2.6 修改后的String代码"></a>10.2.6 修改后的String代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.h -- fixed and augmented string class definition</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STRING1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STRING1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::ostream;</span><br><span class="line"><span class="keyword">using</span> std::istream;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> * str;             <span class="comment">// pointer to string</span></span><br><span class="line">    <span class="keyword">int</span> len;                <span class="comment">// length of string</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num_strings; <span class="comment">// number of objects</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CINLIM = <span class="number">80</span>;  <span class="comment">// cin input limit</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// constructors and other methods</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s); <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">String</span>();               <span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="keyword">const</span> String &amp;); <span class="comment">// 复制构造函数</span></span><br><span class="line">    ~<span class="built_in">String</span>();              <span class="comment">// destructor</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> len; &#125;</span><br><span class="line">	<span class="comment">// 重载的运算符 </span></span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp;);</span><br><span class="line">    String &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> *);</span><br><span class="line">    <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">	<span class="comment">// 重载的友元运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp;st, <span class="keyword">const</span> String &amp;st2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2);</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;st, <span class="keyword">const</span> String &amp;st2);</span><br><span class="line">    <span class="keyword">friend</span> ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> String &amp; st);</span><br><span class="line">    <span class="keyword">friend</span> istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st);</span><br><span class="line">	<span class="comment">// 静态成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">HowMany</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// string1.cpp -- String class methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span>                 <span class="comment">// string.h for some</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span>               <span class="comment">// includes &lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initializing static class member</span></span><br><span class="line"><span class="keyword">int</span> String::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static method</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">String::HowMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num_strings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class methods</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;   <span class="comment">// construct String from C string</span></span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);          <span class="comment">// set size</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];       <span class="comment">// allot storage</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);           <span class="comment">// initialize pointer</span></span><br><span class="line">    num_strings++;                 <span class="comment">// set object count</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>() &#123;                 <span class="comment">// default constructor</span></span><br><span class="line">    len = <span class="number">4</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>];</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;                 <span class="comment">// default string</span></span><br><span class="line">    num_strings++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    num_strings++;             <span class="comment">// handle static member update</span></span><br><span class="line">    len = st.len;              <span class="comment">// same length</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span> [len + <span class="number">1</span>];  <span class="comment">// allot space</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, st.str);  <span class="comment">// copy string to new location</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::~<span class="built_in">String</span>() &#123;                   <span class="comment">// necessary destructor</span></span><br><span class="line"></span><br><span class="line">    --num_strings;                    <span class="comment">// required</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;                    <span class="comment">// required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded operator methods    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign a String to a String</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// assign a C string to a String</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">char</span> * s) &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read-write char access for non-const String</span></span><br><span class="line"><span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read-only char access for const String</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overloaded operator friends</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="keyword">return</span> (std::<span class="built_in">strcmp</span>(st1.str, st2.str) &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="keyword">return</span> st2 &lt; st1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> String &amp;st1, <span class="keyword">const</span> String &amp;st2) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (std::<span class="built_in">strcmp</span>(st1.str, st2.str) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// simple String output</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; os, <span class="keyword">const</span> String &amp; st) &#123;</span><br><span class="line">    os &lt;&lt; st.str;</span><br><span class="line">    <span class="keyword">return</span> os; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// quick and dirty String input</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; is, String &amp; st) &#123;</span><br><span class="line">    <span class="keyword">char</span> temp[String::CINLIM];</span><br><span class="line">    is.<span class="built_in">get</span>(temp, String::CINLIM);</span><br><span class="line">    <span class="keyword">if</span> (is)</span><br><span class="line">        st = temp;</span><br><span class="line">    <span class="keyword">while</span> (is &amp;&amp; is.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">return</span> is; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-构造函数中new的注意事项"><a href="#10-3-构造函数中new的注意事项" class="headerlink" title="10.3 构造函数中new的注意事项"></a>10.3 构造函数中new的注意事项</h3><p>使用new初始化对象中的指针成员时应当特别小心，以下是一些注意点：</p>
<ul>
<li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。new 和delete必须相互兼容。new 对应于delete，<code>new[]</code>对应于<code>delete[]</code></li>
<li>如果有多个构造函数，则必须以相同的方式使用 new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用 new 初始化指针，而在另一个构造函数中将指针初始化为空（置为0、NULL或nullptr之一即可），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。</li>
<li>应定义一个复制构造函数，通过<strong>深度复制</strong>将一个对象初始化为另一个对象。</li>
<li>应定义一个赋值运算符，通过<strong>深度复制</strong>将一个对象复制为另一个对象。</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>在之前的String类中，有一个<code>char *</code>的成员str：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:	</span><br><span class="line">	<span class="keyword">char</span> * str;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>对应的析构函数为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的构造函数代码是错误的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>() &#123;</span><br><span class="line">    str = <span class="string">&quot;default string&quot;</span>; <span class="comment">// no new</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *) &#123;</span><br><span class="line">    len = <span class="built_in">strlen</span>(s);</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>; <span class="comment">// no []</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str, s); <span class="comment">// no room for str</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个构造函数没有使用new来初始化str，对不是使用new初始化的指针使用delete时，结果将是不确定的，可以将其改造为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>() &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1</span>]; <span class="comment">// use new with []</span></span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String::<span class="built_in">String</span>() &#123;</span><br><span class="line">    len = <span class="number">0</span>;</span><br><span class="line">    str = <span class="number">0</span>; <span class="comment">// 或者 str = NULL; str = nullptr;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个构造函数使用了new，但是分配的内存量和格式不正确。</p>
<p>最后析构函数也有要求：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>() &#123;</span><br><span class="line">    <span class="keyword">delete</span> str; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数创建的是一个字符数组，因此析构函数应该删除一个数组。</p>
<h3 id="10-4-使用指向对象的指针"><a href="#10-4-使用指向对象的指针" class="headerlink" title="10.4 使用指向对象的指针"></a>10.4 使用指向对象的指针</h3><h4 id="10-4-1-程序示例"><a href="#10-4-1-程序示例" class="headerlink" title="10.4.1 程序示例"></a>10.4.1 程序示例</h4><p>以下代码执行效果：让用户输入10句以内的字符串，程序比较打印出字符串，然后打印出长度最小和排列顺序最前的字符串，最后随机打印出用户输入的一条字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sayings2.cpp -- using pointers to objects</span></span><br><span class="line"><span class="comment">// compile with string1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>      <span class="comment">// (or stdlib.h) for rand(), srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span>        <span class="comment">// (or time.h) for time()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string1.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxLen = <span class="number">81</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    String name;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Hi, what&#x27;s your name?\n&gt;&gt; &quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot;, please enter up to &quot;</span> &lt;&lt; ArSize</span><br><span class="line">         &lt;&lt; <span class="string">&quot; short sayings &lt;empty line to quit&gt;:\n&quot;</span>;</span><br><span class="line">    String sayings[ArSize];</span><br><span class="line">    <span class="keyword">char</span> temp[MaxLen];               <span class="comment">// temporary string storage</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ArSize; i++) &#123;</span><br><span class="line">        cout &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        cin.<span class="built_in">get</span>(temp, MaxLen);</span><br><span class="line">        <span class="keyword">while</span> (cin &amp;&amp; cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!cin || temp[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) <span class="comment">// empty line?</span></span><br><span class="line">            <span class="keyword">break</span>;                   <span class="comment">// i not incremented</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sayings[i] = temp;       <span class="comment">// overloaded assignment</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> total = i;                   <span class="comment">// total # of lines read</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (total &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Here are your sayings:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; total; i++)</span><br><span class="line">            cout &lt;&lt; sayings[i] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// use pointers to keep track of shortest, first strings</span></span><br><span class="line">        String * shortest = &amp;sayings[<span class="number">0</span>]; <span class="comment">// initialize to first object</span></span><br><span class="line">        String * first = &amp;sayings[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; total; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sayings[i].<span class="built_in">length</span>() &lt; shortest-&gt;<span class="built_in">length</span>())</span><br><span class="line">                shortest = &amp;sayings[i];</span><br><span class="line">            <span class="keyword">if</span> (sayings[i] &lt; *first)     <span class="comment">// compare values</span></span><br><span class="line">                first = &amp;sayings[i];     <span class="comment">// assign address</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest saying:\n&quot;</span> &lt;&lt; * shortest &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;First alphabetically:\n&quot;</span> &lt;&lt; * first &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> choice = <span class="built_in">rand</span>() % total; <span class="comment">// 随机获取下标</span></span><br><span class="line">    	<span class="comment">// 使用new来初始化String</span></span><br><span class="line">        String * favorite = <span class="keyword">new</span> <span class="built_in">String</span>(sayings[choice]);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;My favorite saying:\n&quot;</span> &lt;&lt; *favorite &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 释放对象占用的内存</span></span><br><span class="line">        <span class="keyword">delete</span> favorite;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Not much to say, eh?\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10-4-2-new和delete"><a href="#10-4-2-new和delete" class="headerlink" title="10.4.2 new和delete"></a>10.4.2 new和delete</h4><p>程序在两个层次上使用了new和delete。</p>
<p>首先，它使用 new 为创建的每一个对象的成员字符串分配存储空间，这是在构造函数中进行的，因此析构函数使用 delete 来释放这些内存。因为字符串是一个字符数组，所以析构函数使用的是带中括号的 delete，这样，当对象被释放时，用于存储字符串内容的内存将被自动释放。</p>
<p>其次，上述代码使用new来为整个对象分配内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String * favorite = <span class="keyword">new</span> <span class="built_in">String</span>(sayings[choice]);</span><br></pre></td></tr></table></figure>
<p>即：为保存字符串地址的str指针和len成员分配内存。释放对象的内存时，由于对象是单个的，因此使用delete删除它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> favorite;</span><br></pre></td></tr></table></figure>
<p>注意：这里只会释放保存str指针和len成员的内存，并不释放str指向的内存，后者由析构函数来完成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109101838601.png" alt="image-20230109101838601"></p>
<p>析构函数调用的时机参见<code>8.2.4小节</code></p>
<p>使用new创建对象的过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109103023279.png" alt="image-20230109103023279"></p>
<h4 id="10-4-3-小结"><a href="#10-4-3-小结" class="headerlink" title="10.4.3 小结"></a>10.4.3 小结</h4><p>使用对象的指针时，有以下动作：</p>
<ul>
<li>使用常规表示法来声明指向对象的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String * glamour;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以将指针初始化为指向已有的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String * first = &amp;sayings[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用new初始化指针，这将创建一个新的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String * favorite = <span class="keyword">new</span> <span class="built_in">String</span>(sayings[choice]);</span><br></pre></td></tr></table></figure>
<ul>
<li>对类使用new将调用对应的构造函数来初始化新创建的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String * gleep = <span class="keyword">new</span> String;</span><br><span class="line">String * glop = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109102918883.png" alt="image-20230109102918883"></p>
<ul>
<li>可以使用<code>-&gt;</code>通过指针访问类方法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String * first = &amp;sayings[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(first-&gt;<span class="built_in">length</span>() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过<code>*</code>解引用指针获取对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String * first = &amp;sayings[<span class="number">0</span>];</span><br><span class="line">String * second = &amp;sayings[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(*second &lt; *first) &#123; <span class="comment">// &lt;运算符重载比较两个字符串对象</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-类继承"><a href="#11-类继承" class="headerlink" title="11 类继承"></a>11 类继承</h2><h3 id="11-1-问题引入"><a href="#11-1-问题引入" class="headerlink" title="11.1 问题引入"></a>11.1 问题引入</h3><p>从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。</p>
<h4 id="11-1-1-基类"><a href="#11-1-1-基类" class="headerlink" title="11.1.1 基类"></a>11.1.1 基类</h4><blockquote>
<p>基类示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tabtenn0.h -- a table-tennis base class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN0_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="comment">// simple base class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string firstname;</span><br><span class="line">    string lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TableTennisPlayer</span> (<span class="keyword">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tabtenn0.cpp -- simple base-class methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::<span class="built_in">TableTennisPlayer</span> (<span class="keyword">const</span> string &amp; fn, </span><br><span class="line">    <span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht) : <span class="built_in">firstname</span>(fn),</span><br><span class="line">	    <span class="built_in">lastname</span>(ln), <span class="built_in">hasTable</span>(ht) &#123;&#125; <span class="comment">// 成员初始化列表语法</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usett0.cpp -- using a base class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Chuck&quot;</span>, <span class="string">&quot;Blizzard&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player2</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    player1.<span class="built_in">Name</span>();</span><br><span class="line">    <span class="keyword">if</span> (player1.<span class="built_in">HasTable</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line">    player2.<span class="built_in">Name</span>();</span><br><span class="line">    <span class="keyword">if</span> (player2.<span class="built_in">HasTable</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: has a table&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化对象时将C-风格的字符串作为参数，但类的构造函数是将string作为参数，原因在于string类有一个<code>const char *</code>作为参数的构造函数，通过隐式转换将其转换为string对象。</p>
<blockquote>
<p>补充：成员初始化列表</p>
</blockquote>
<p>在构造函数中对每一个成员进行初始化。方式有两种：</p>
<ul>
<li>使用初始化列表</li>
<li>在构造函数体中进行赋值操作</li>
</ul>
<p>一个好的原则是，能使用初始化列表的时候尽量使用初始化列表。</p>
<hr>
<ul>
<li>赋值操作：先无参初始化，然后用参数赋值（默认构造+赋值重载）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 不推荐的做法</span></span><br><span class="line">    <span class="built_in">Entry</span>(<span class="keyword">int</span> num, <span class="keyword">const</span> std::string &amp; address, <span class="keyword">const</span> std::string &amp; name)&#123;  <span class="comment">// 先调用无参构造函数，然后调用赋值运算符</span></span><br><span class="line">        m_num = num;   </span><br><span class="line">        m_address = address; <span class="comment">// 不是初始化而是赋值</span></span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_num;</span><br><span class="line">    std::string m_address;</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>过程（以<code>m_address</code>为例）：首先为<code>m_address</code>调用string类的默认构造函数，进入构造函数体中，再调用赋值运算符的重载，将<code>m_address</code>设置为<code>address</code>。</p>
<p>实际上执行的语句为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">m_address</span><span class="params">()</span></span>; <span class="comment">// 初始化</span></span><br><span class="line">m_address = address; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>初始化列表：直接以参数初始化（复制构造）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 推荐</span></span><br><span class="line">    <span class="built_in">Entry</span>(<span class="keyword">int</span> num, <span class="keyword">const</span> std::string &amp; address, <span class="keyword">const</span> std::string &amp; name)   : <span class="built_in">m_num</span>(num),</span><br><span class="line">          <span class="built_in">m_address</span>(address),</span><br><span class="line">          <span class="built_in">m_name</span>(name)&#123;   <span class="comment">// 初始化列表调用的是复制构造函数</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_num;</span><br><span class="line">    std::string m_address;</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>成员初始化列表器列表是以<code>:</code>开头，后跟一系列以<code>,</code>分隔的初始化字段。<strong>使用初始化列表少了一次调用默认构造函数的过程</strong>。</p>
<p>过程：先调用<code>m_address、m_name</code>这些成员的<strong>复制构造函数</strong>初始化成员变量，然后进入Entry构造函数体中，在这里面是空的，什么也不干。</p>
<p>实际执行的语句为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String m_address = address;</span><br></pre></td></tr></table></figure>
<p>这里调用string类的复制构造函数，传入<code>address</code>为参数，复制到<code>m_address</code>中。</p>
<h4 id="11-1-2-派生类"><a href="#11-1-2-派生类" class="headerlink" title="11.1.2 派生类"></a>11.1.2 派生类</h4><p>从<code>TableTennisPlayer</code>派生一个类<code>RatedPlayer</code>表示成员在比赛中的得分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>public</code>表示公有派生。使用公有派生，基类的公有成员称为派生类的公有成员；基类的私有部分也会成为派生类的一部分，但只能通过基类的公有方法和保护方法访问。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109111243108.png" alt="image-20230109111243108"></p>
<p>派生类需要自己的构造函数，根据需要添加额外的成员和方法。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RatedPlayer</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">RatedPlayer</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123;rating = r;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="11-1-3-构造函数"><a href="#11-1-3-构造函数" class="headerlink" title="11.1.3 构造函数"></a>11.1.3 构造函数</h4><p>派生类构造函数必须使用基类构造函数。</p>
<p>创建派生类对象时，程序首先创建基类对象。从概念上说，这意味着基类对象应当在程序进入派生类构造函数之前被创建。C++使用成员初始化列表语法来完成这种工作。</p>
<p>例如，下面是第一个<code>RatedPlayer</code>构造函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatedPlayer</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> string &amp; fn,<span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(fn, ln, ht) &#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>执行过程：RealPlayer构造函数将把实参<code>&quot;Mallory&quot;,&quot;Duck&quot;,true</code>赋给形参<code>fn,ln,ht</code>，然后将这些参数作为实参传递给 <code>TableTennisPlayer</code> 构造函数，后者将创建一个嵌套 TableTennisPlayer 对象，并将数据”Mallory”、”Duck”和true存储在该对象中。然后，程序进入RealPlayer构造函数体，完成RealPlayer对象的创建，并将参数r的值赋给rating成员。</p>
<p>如果省略成员初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatedPlayer</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> string &amp; fn,<span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht)  <span class="comment">// : TableTennisPlayer()</span></span><br><span class="line">&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时程序将使用基类的默认构造函数。</p>
<p>对于第二个构造函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RatedPlayer</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> string &amp; fn,<span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(tp) &#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于tp的类型为<code>TableTemnisPlayer&amp;</code>，因此将调用基类的复制构造函数。基类没有定义复制构造函数，将使用默认提供的。在这种情况下，执行成员复制的隐式复制构造函数是合适的，因为这个类没有使用动态内存分配（string 成员确实使用了动态内存分配，但前面说过，成员复制将使用string类的复制构造函数来复制string成员）。</p>
<h4 id="11-1-4-使用派生类"><a href="#11-1-4-使用派生类" class="headerlink" title="11.1.4 使用派生类"></a>11.1.4 使用派生类</h4><p>要使用派生类，程序必须要能够访问基类声明。示例代码将这两种类的声明置于同一个头文件中。也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tabtenn1.h -- a table-tennis base class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TABTENN1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TableTennisPlayer</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string firstname;</span><br><span class="line">    string lastname;</span><br><span class="line">    <span class="keyword">bool</span> hasTable;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TableTennisPlayer</span> (<span class="keyword">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                       <span class="keyword">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasTable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hasTable; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetTable</span><span class="params">(<span class="keyword">bool</span> v)</span> </span>&#123; hasTable = v; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RatedPlayer</span> :</span> <span class="keyword">public</span> TableTennisPlayer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rating;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RatedPlayer</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">const</span> string &amp; fn = <span class="string">&quot;none&quot;</span>,</span><br><span class="line">                 <span class="keyword">const</span> string &amp; ln = <span class="string">&quot;none&quot;</span>, <span class="keyword">bool</span> ht = <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">RatedPlayer</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp);</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">Rating</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rating; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRating</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> r)</span> </span>&#123;rating = r;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tabtenn1.cpp -- simple base-class methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">TableTennisPlayer::<span class="built_in">TableTennisPlayer</span> (<span class="keyword">const</span> string &amp; fn, </span><br><span class="line">    <span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht) : <span class="built_in">firstname</span>(fn),</span><br><span class="line">	    <span class="built_in">lastname</span>(ln), <span class="built_in">hasTable</span>(ht) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TableTennisPlayer::Name</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; lastname &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; firstname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类构造方法</span></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> string &amp; fn,</span><br><span class="line">     <span class="keyword">const</span> string &amp; ln, <span class="keyword">bool</span> ht) : <span class="built_in">TableTennisPlayer</span>(fn, ln, ht)&#123;</span><br><span class="line">    rating = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RatedPlayer::<span class="built_in">RatedPlayer</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> r, <span class="keyword">const</span> TableTennisPlayer &amp; tp)</span><br><span class="line">    : <span class="built_in">TableTennisPlayer</span>(tp), <span class="built_in">rating</span>(r)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usett1.cpp -- using base class and derived class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tabtenn1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line">    <span class="comment">// 基类对象</span></span><br><span class="line">    <span class="function">TableTennisPlayer <span class="title">player1</span><span class="params">(<span class="string">&quot;Tara&quot;</span>, <span class="string">&quot;Boomdea&quot;</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 派生类对象</span></span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer1</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    rplayer1.<span class="built_in">Name</span>();          <span class="comment">// 派生类对象使用基类的方法</span></span><br><span class="line">    <span class="keyword">if</span> (rplayer1.<span class="built_in">HasTable</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: has a table.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line">    player1.<span class="built_in">Name</span>();           <span class="comment">// 基类对象使用基类的方法</span></span><br><span class="line">    <span class="keyword">if</span> (player1.<span class="built_in">HasTable</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: has a table&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;: hasn&#x27;t a table.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer1.<span class="built_in">Name</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer1.<span class="built_in">Rating</span>() &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// 使用基类对象初始化派生类对象</span></span><br><span class="line">    <span class="function">RatedPlayer <span class="title">rplayer2</span><span class="params">(<span class="number">1212</span>, player1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span>;</span><br><span class="line">    rplayer2.<span class="built_in">Name</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;; Rating: &quot;</span> &lt;&lt; rplayer2.<span class="built_in">Rating</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230109194518459.png" alt="image-20230109194518459"></p>
<h4 id="11-1-5-派生类和基类的特殊关系"><a href="#11-1-5-派生类和基类的特殊关系" class="headerlink" title="11.1.5 派生类和基类的特殊关系"></a>11.1.5 派生类和基类的特殊关系</h4><ul>
<li>派生类可以使用基类的公有方法</li>
<li>基类指针（和引用）可以在不进行显式类型转换的情况下指向（引用）派生类对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类对象</span></span><br><span class="line"><span class="function">RatedPlayer <span class="title">rp</span><span class="params">(<span class="number">1140</span>, <span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">TatbleTennisPlayer &amp; rt = rp; <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">TatbleTennisPlayer * pt = rp;</span><br><span class="line">rt.<span class="built_in">Name</span>();</span><br><span class="line">pt-&gt;<span class="built_in">Name</span>();</span><br></pre></td></tr></table></figure>
<p>然而基类指针或引用只能调用基类方法，不能调用派生类的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rt.<span class="built_in">ResetRanking</span>(); <span class="comment">// error!</span></span><br><span class="line">pt-&gt;<span class="built_in">ResetRanking</span>(); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不可以将基类对象或引用赋给派生类引用和指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 派生类对象</span></span><br><span class="line"><span class="function">TatbleTennisPlayer <span class="title">player</span><span class="params">(<span class="string">&quot;Mallory&quot;</span>, <span class="string">&quot;Duck&quot;</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">RatedPlayer &amp; rr = player; <span class="comment">// error!</span></span><br><span class="line">RatedPlayer * pr = player; </span><br></pre></td></tr></table></figure>
<h3 id="11-2-多态公有继承"><a href="#11-2-多态公有继承" class="headerlink" title="11.2 多态公有继承"></a>11.2 多态公有继承</h3><p>RatedPlayer继承示例很简单：派生类对象使用基类的方法，而未做任何修改。然而，可能会遇到这样的情况，即希望同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应取决于调用该方法的对象。这种较复杂的行为称为多态——具有多种形态，即同一个方法的行为随上下文而异。</p>
<p>有两种重要的机制可用于实现多态公有继承：</p>
<ul>
<li>在派生类中重新定义基类的方法</li>
<li>使用虚方法</li>
</ul>
<blockquote>
<p>代码示例</p>
</blockquote>
<p>一个类用于表示基本支票账户<code>Brass Account</code>，另一个类用于表示代表 <code>Brass Plus</code> 支票账户，它添加了透支保护特性。也就是说，如果用户签出一张超出其存款余额的支票但是超出的数额并不是很大，银行将支付这张支票，对超出的部分收取额外的费用，并追加罚款。可以根据要保存的数据以及允许执行的操作来确定这两种账户的特征。</p>
<p><code>Brass Account</code>支票账户的信息：</p>
<ul>
<li>客户姓名</li>
<li>账号</li>
<li>当前结余</li>
</ul>
<p>执行的操作：</p>
<ul>
<li>创建账户</li>
<li>存款</li>
<li>取款</li>
<li>显示账户信息</li>
</ul>
<p><code>Brass Plus</code>提供的额外信息：</p>
<ul>
<li>透支上限，默认500元</li>
<li>透支贷款利率，默认<code>11.125%</code></li>
<li>当前的透支总额</li>
</ul>
<p>不新增操作，但是有对两种操作的不同实现：</p>
<ul>
<li>取款操作，必须考虑透支保护</li>
<li>显示操作必须显示<code>Brass Plus</code>账户的其他信息</li>
</ul>
<hr>
<blockquote>
<p>类的声明</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brass.h  -- bank account classes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BRASS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BRASS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// Brass Account Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 客户姓名</span></span><br><span class="line">    std::string fullName;</span><br><span class="line">    <span class="comment">// 账号</span></span><br><span class="line">    <span class="keyword">long</span> acctNum;</span><br><span class="line">    <span class="comment">// 结余</span></span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Brass</span>(<span class="keyword">const</span> std::string &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>, <span class="keyword">double</span> bal = <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">// 放贷</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span></span>;</span><br><span class="line">    <span class="comment">// 虚方法</span></span><br><span class="line">    <span class="comment">// 提款</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Balance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Brass</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Brass Plus Account Class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrassPlus</span> :</span> <span class="keyword">public</span> Brass &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 透支上限</span></span><br><span class="line">    <span class="keyword">double</span> maxLoan;</span><br><span class="line">    <span class="comment">// 透支的贷款利率</span></span><br><span class="line">    <span class="keyword">double</span> rate;</span><br><span class="line">    <span class="comment">// 透支总额</span></span><br><span class="line">    <span class="keyword">double</span> owesBank;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BrassPlus</span>(<span class="keyword">const</span> std::string &amp; s = <span class="string">&quot;Nullbody&quot;</span>, <span class="keyword">long</span> an = <span class="number">-1</span>, <span class="keyword">double</span> bal = <span class="number">0.0</span>, <span class="keyword">double</span> ml = <span class="number">500</span>, <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="built_in">BrassPlus</span>(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml = <span class="number">500</span>, <span class="keyword">double</span> r = <span class="number">0.11125</span>);</span><br><span class="line">    <span class="comment">// 虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">ViewAcct</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 提款</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetMax</span><span class="params">(<span class="keyword">double</span> m)</span> </span>&#123; maxLoan = m; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetRate</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123; rate = r; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ResetOwes</span><span class="params">()</span> </span>&#123; owesBank = <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>两个类在声明<code>ViewAcct()</code>和<code>Withdraw()</code>时使用了关键字<code>virtual</code>，这些方法被称为<strong>虚方法（虚函数）</strong>。</p>
<p>对于虚方法，如果方法是通过引用或指针而不是对象调用的，它将确定使用哪一种方法：</p>
<ul>
<li>如果没有使用virtual，程序将根据引用类型或指针类型选择方法</li>
<li>如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法</li>
</ul>
<p>例如，如果<code>ViewAcct()</code>不是虚的，则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;Dominic Banker&quot;</span>, <span class="number">11224</span>, <span class="number">4183.45</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;Dorothy Banker&quot;</span>, <span class="number">12118</span>, <span class="number">2592.00</span>)</span></span>;</span><br><span class="line">Brass &amp; b1_ref = dom;</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">b1_ref.<span class="built_in">ViewAcct</span>(); <span class="comment">// 调用Brass::ViewAcct()</span></span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>(); <span class="comment">// 调用Brass::ViewAcct()，因为b2_ref的引用类型是Brass</span></span><br></pre></td></tr></table></figure>
<p>如果<code>ViewAcct()</code>是虚的，则：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Brass <span class="title">dom</span><span class="params">(<span class="string">&quot;Dominic Banker&quot;</span>, <span class="number">11224</span>, <span class="number">4183.45</span>)</span></span>;</span><br><span class="line"><span class="function">BrassPlus <span class="title">dot</span><span class="params">(<span class="string">&quot;Dorothy Banker&quot;</span>, <span class="number">12118</span>, <span class="number">2592.00</span>)</span></span>;</span><br><span class="line">Brass &amp; b1_ref = dom;</span><br><span class="line">Brass &amp; b2_ref = dot;</span><br><span class="line">b1_ref.<span class="built_in">ViewAcct</span>(); <span class="comment">// 调用Brass::ViewAcct()</span></span><br><span class="line">b2_ref.<span class="built_in">ViewAcct</span>(); <span class="comment">// 调用BrassPlus::ViewAcct()，因为b2_ref引用的对象是BrassPlus类型的对象</span></span><br></pre></td></tr></table></figure>
<p>总结：在基类中应当将派生类会重新定义的方法声明为虚方法，在派生类中这些方法会自动成为虚方法，派生类中的<code>virtual</code>可有可无，但建议写上。</p>
<blockquote>
<p>类的实现</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// brass.cpp -- bank account class methods</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;brass.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">// formatting stuff</span></span><br><span class="line"><span class="keyword">typedef</span> std::ios_base::fmtflags format;</span><br><span class="line"><span class="keyword">typedef</span> std::streamsize precis;</span><br><span class="line"><span class="function">format <span class="title">setFormat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(format f, precis p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Brass methods</span></span><br><span class="line">Brass::<span class="built_in">Brass</span>(<span class="keyword">const</span> string &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal) &#123;</span><br><span class="line">    fullName = s;</span><br><span class="line">    acctNum = an;</span><br><span class="line">    balance = bal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::Deposit</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Negative deposit not allowed; &quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;deposit is cancelled.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        balance += amt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set up ###.## format</span></span><br><span class="line">    format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">    precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 错误判断</span></span><br><span class="line">    <span class="keyword">if</span> (amt &lt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Withdrawal amount must be positive; &quot;</span></span><br><span class="line"></span><br><span class="line">             &lt;&lt; <span class="string">&quot;withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (amt &lt;= balance) <span class="comment">// 提款金额小于余额，则余额相减</span></span><br><span class="line">        balance -= amt;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 提款金额大于余额，报错</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Withdrawal amount of $&quot;</span> &lt;&lt; amt</span><br><span class="line">             &lt;&lt; <span class="string">&quot; exceeds your balance.\n&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;Withdrawal canceled.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">restore</span>(initialState, prec);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Brass::Balance</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brass::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">     <span class="comment">// set up ###.## format</span></span><br><span class="line">    format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">    precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Client: &quot;</span> &lt;&lt; fullName &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Account Number: &quot;</span> &lt;&lt; acctNum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Balance: $&quot;</span> &lt;&lt; balance &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">restore</span>(initialState, prec); <span class="comment">// Restore original format</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BrassPlus Methods</span></span><br><span class="line">BrassPlus::<span class="built_in">BrassPlus</span>(<span class="keyword">const</span> string &amp; s, <span class="keyword">long</span> an, <span class="keyword">double</span> bal,</span><br><span class="line">           <span class="keyword">double</span> ml, <span class="keyword">double</span> r) : <span class="built_in">Brass</span>(s, an, bal) &#123;</span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BrassPlus::<span class="built_in">BrassPlus</span>(<span class="keyword">const</span> Brass &amp; ba, <span class="keyword">double</span> ml, <span class="keyword">double</span> r)</span><br><span class="line">           : <span class="built_in">Brass</span>(ba) &#123;  <span class="comment">// uses implicit copy constructor</span></span><br><span class="line">    maxLoan = ml;</span><br><span class="line">    owesBank = <span class="number">0.0</span>;</span><br><span class="line">    rate = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redefine how ViewAcct() works</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::ViewAcct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set up ###.## format</span></span><br><span class="line">    format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">    precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="comment">// 调用基类的公有方法来展示基类中的私有成员</span></span><br><span class="line">    Brass::<span class="built_in">ViewAcct</span>();   <span class="comment">// display base portion</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum loan: $&quot;</span> &lt;&lt; maxLoan &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Owed to bank: $&quot;</span> &lt;&lt; owesBank &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">3</span>);  <span class="comment">// ###.### format</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Loan Rate: &quot;</span> &lt;&lt; <span class="number">100</span> * rate &lt;&lt; <span class="string">&quot;%\n&quot;</span>;</span><br><span class="line">    <span class="built_in">restore</span>(initialState, prec); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// redefine how Withdraw() works</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BrassPlus::Withdraw</span><span class="params">(<span class="keyword">double</span> amt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set up ###.## format</span></span><br><span class="line">    format initialState = <span class="built_in">setFormat</span>();</span><br><span class="line">    precis prec = cout.<span class="built_in">precision</span>(<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类使用基类的方法</span></span><br><span class="line">    <span class="keyword">double</span> bal = <span class="built_in">Balance</span>(); <span class="comment">// 即Brass::Balance();</span></span><br><span class="line">    <span class="keyword">if</span> (amt &lt;= bal) <span class="comment">// 提款金额小于余额，则调用基类的提款方法</span></span><br><span class="line">        Brass::<span class="built_in">Withdraw</span>(amt);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( amt &lt;= bal + maxLoan - owesBank) &#123;</span><br><span class="line">        <span class="keyword">double</span> advance = amt - bal;</span><br><span class="line">        owesBank += advance * (<span class="number">1.0</span> + rate);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Bank advance: $&quot;</span> &lt;&lt; advance &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Finance charge: $&quot;</span> &lt;&lt; advance * rate &lt;&lt; endl;</span><br><span class="line">        <span class="comment">// 调用基类的放贷方法</span></span><br><span class="line">        <span class="built_in">Deposit</span>(advance);</span><br><span class="line">        Brass::<span class="built_in">Withdraw</span>(amt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Credit limit exceeded. Transaction cancelled.\n&quot;</span>;</span><br><span class="line">    <span class="built_in">restore</span>(initialState, prec); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">format <span class="title">setFormat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set up ###.## format</span></span><br><span class="line">    <span class="keyword">return</span> cout.<span class="built_in">setf</span>(std::ios_base::fixed, </span><br><span class="line">                std::ios_base::floatfield);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restore</span><span class="params">(format f, precis p)</span> </span>&#123;</span><br><span class="line">    cout.<span class="built_in">setf</span>(f, std::ios_base::floatfield);</span><br><span class="line">    cout.<span class="built_in">precision</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usebrass1.cpp -- testing bank account classes</span></span><br><span class="line"><span class="comment">// compile with brass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;brass.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建类的对象</span></span><br><span class="line">    <span class="function">Brass <span class="title">Piggy</span><span class="params">(<span class="string">&quot;Porcelot Pigg&quot;</span>, <span class="number">381299</span>, <span class="number">4000.00</span>)</span></span>;</span><br><span class="line">    <span class="function">BrassPlus <span class="title">Hoggy</span><span class="params">(<span class="string">&quot;Horatio Hogg&quot;</span>, <span class="number">382288</span>, <span class="number">3000.00</span>)</span></span>;</span><br><span class="line">    Piggy.<span class="built_in">ViewAcct</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    Hoggy.<span class="built_in">ViewAcct</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Depositing $1000 into the Hogg Account:\n&quot;</span>;</span><br><span class="line">    Hoggy.<span class="built_in">Deposit</span>(<span class="number">1000.00</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;New balance: $&quot;</span> &lt;&lt; Hoggy.<span class="built_in">Balance</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Withdrawing $4200 from the Pigg Account:\n&quot;</span>;</span><br><span class="line">    Piggy.<span class="built_in">Withdraw</span>(<span class="number">4200.00</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Pigg account balance: $&quot;</span> &lt;&lt; Piggy.<span class="built_in">Balance</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Withdrawing $4200 from the Hogg Account:\n&quot;</span>;</span><br><span class="line">    Hoggy.<span class="built_in">Withdraw</span>(<span class="number">4200.00</span>);</span><br><span class="line">    Hoggy.<span class="built_in">ViewAcct</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试2</p>
</blockquote>
<p>在测试1中，方法是通过对象（而不是指针或引用）调用的，没有使用虚方法特性。</p>
<p>下面来看一个使用了虚方法的例子。假设要同时管理 Brass和 BrassPlus 账户，如果能使用同一个数组来保存 Brss 和BrassPlus对象，将很有帮助，但这是不可能的。数组中所有元素的类型必须相同，而Brass和BrassPlus 是不同的类型。然而，可以创建指向 Brass 的指针数组。这样，每个元素的类型都相同，但由于使用的是公有继承模型，因此 Brass指针既可以指向 Brass 对象，也可以指向 BrassPlus对象。因此，可以使用一个数组来表示多种类型的对象。<strong>这就是多态性</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usebrass2.cpp -- polymorphic example</span></span><br><span class="line"><span class="comment">// compile with brass.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;brass.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> CLIENTS = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">using</span> std::cin;</span><br><span class="line">   <span class="keyword">using</span> std::cout;</span><br><span class="line">   <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line">   Brass * p_clients[CLIENTS];</span><br><span class="line">   std::string temp;</span><br><span class="line">   <span class="keyword">long</span> tempnum;</span><br><span class="line">   <span class="keyword">double</span> tempbal;</span><br><span class="line">   <span class="keyword">char</span> kind;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++) &#123;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Enter client&#x27;s name: &quot;</span>;</span><br><span class="line">       <span class="built_in">getline</span>(cin,temp);</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Enter client&#x27;s account number: &quot;</span>;</span><br><span class="line">       cin &gt;&gt; tempnum;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Enter opening balance: $&quot;</span>;</span><br><span class="line">       cin &gt;&gt; tempbal;</span><br><span class="line">       cout &lt;&lt; <span class="string">&quot;Enter 1 for Brass Account or &quot;</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot;2 for BrassPlus Account: &quot;</span>;</span><br><span class="line">       <span class="keyword">while</span> (cin &gt;&gt; kind &amp;&amp; (kind != <span class="string">&#x27;1&#x27;</span> &amp;&amp; kind != <span class="string">&#x27;2&#x27;</span>))</span><br><span class="line">           cout &lt;&lt;<span class="string">&quot;Enter either 1 or 2: &quot;</span>;</span><br><span class="line">       <span class="keyword">if</span> (kind == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">           p_clients[i] = <span class="keyword">new</span> <span class="built_in">Brass</span>(temp, tempnum, tempbal);</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">double</span> tmax, trate;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;Enter the overdraft limit: $&quot;</span>;</span><br><span class="line">           cin &gt;&gt; tmax;</span><br><span class="line">           cout &lt;&lt; <span class="string">&quot;Enter the interest rate &quot;</span></span><br><span class="line">                &lt;&lt; <span class="string">&quot;as a decimal fraction: &quot;</span>;</span><br><span class="line">           cin &gt;&gt; trate;</span><br><span class="line">           p_clients[i] = <span class="keyword">new</span> <span class="built_in">BrassPlus</span>(temp, tempnum, tempbal,</span><br><span class="line">                                        tmax, trate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       p_clients[i]-&gt;<span class="built_in">ViewAcct</span>();</span><br><span class="line">       cout &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line">              </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENTS; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">delete</span> p_clients[i];  <span class="comment">// free memory</span></span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Done.\n&quot;</span>;         </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果数组成员指向的是 <code>Brass</code> 对象，则调用 <code>Brass::ViewAcct</code>；如果指向的是 <code>BrassPlus</code> 对象，则调用<code>BrassPlus::ViewAcct</code>。如果<code>Brass::ViewAcct</code>不被声明为虚的，则在任何情况下都将调用<code>Brass::ViewAcct</code>。</p>
<h3 id="11-3-静态联编和动态联编"><a href="#11-3-静态联编和动态联编" class="headerlink" title="11.3 静态联编和动态联编"></a>11.3 静态联编和动态联编</h3><p>程序调用函数时，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用解释为执行特定的函数代码块被称为<code>函数名联编（binding）</code>。</p>
<p>在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。在C++中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。</p>
<ul>
<li>静态联编：编译阶段就将函数实现与函数调用关联起来；在编译过程中进行联编被称为<strong>静态联编</strong>（static binding），又称为早期联编（early binding）。然而，虚函数使这项工作变得更困难。正如在上面的程序所示的那样，使用哪一个函数是不能在编译时确定的，因为编译器不知道用户将选择哪种类型的对象。</li>
<li>动态联编：在程序执行阶段才将函数实现和调用关联；编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</li>
</ul>
<p>注意：动态联编是针对C++的多态，C语言全部都是静态联编；</p>
<h4 id="11-3-1-指针和引用类型的兼容性"><a href="#11-3-1-指针和引用类型的兼容性" class="headerlink" title="11.3.1 指针和引用类型的兼容性"></a>11.3.1 指针和引用类型的兼容性</h4><p> 通常，C++不允许将一种类型的地址赋给另一种类型的指针，也不允许一种类型的引用指向另一种类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">int</span> * pi = &amp;x; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">long</span> &amp; rl = x; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>然而，指向基类的引用或指针可以引用或指向派生类对象，且不必进行显式类型转换，这种转换称为<strong>向上强制转换</strong>（<code>upcasting</code>）。该规则是<code>is-a</code>关系的一部分（<code>BrassPlus is a Brass.</code>）：派生类对象都是基类对象，因为它继承了基类对象的所有数据成员和方法，所以对基类对象执行的任何操作，都适用于派生类对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BrassPlus <span class="title">dilly</span><span class="params">(<span class="string">&quot;Annie Dill&quot;</span>, <span class="number">493222</span>, <span class="number">2000</span>)</span></span>;</span><br><span class="line">Brass * pb = &amp;dilly; <span class="comment">// valid</span></span><br><span class="line">Brass &amp; rb = dilly; <span class="comment">// valid</span></span><br></pre></td></tr></table></figure>
<p>相反的过程则不行（向下强制转换）（<code>Brass is not a BrassPlus.</code>）。</p>
<p>向上强转使得基类的指针或引用可以同时指向基类或派生类的对象，此时使用该指针或引用调用方法，编译器无法知道该方法是基类还是派生类的方法，因此需要动态联编，C++使用虚成员函数来满足这种需求。</p>
<h4 id="11-3-2-虚成员函数和动态联编"><a href="#11-3-2-虚成员函数和动态联编" class="headerlink" title="11.3.2 虚成员函数和动态联编"></a>11.3.2 虚成员函数和动态联编</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BrassPlus ophelia;</span><br><span class="line">Brass * bp;</span><br><span class="line">bp = &amp;ophelia;</span><br><span class="line">bp-&gt;<span class="built_in">ViewAcct</span>(); <span class="comment">// 哪个类的ViewAcct方法？</span></span><br></pre></td></tr></table></figure>
<p>正如前面介绍的，如果在基类中没有将ViewAcct声明为虚的，则<code>bp-&gt;ViewAcct</code>将根据指针类型（Brass<em>）调用<code>Brass::ViewAcct</code>。指针类型在编译时已知，因此编译器在编译时，可以将ViewAcct关联到<code>Brass：ViewAcct</code>。总之，<em>*编译器对非虚方法使用静态联编</em></em>。</p>
<p>然而，如果在基类中将ViewAcct声明为虚的，则<code>bp-&gt;ViewAcct</code>根据对象类型（BrassPlus）调用<code>BrassPlus::ViewAcct</code>。在这个例子中，对象类型为BrassPlus，但通常只有在运行程序时才能确定对象的类型。所以编译器生成的代码将在程序执行时，根据对象类型将ViewAcct关联到<code>Brass::ViewAcct</code>或<code>BrassPlus::ViewAcct</code>。总之，<strong>编译器对虚方法使用动态联编</strong>。</p>
<p>总结：编译看左边（指针或引用类型），运行看右边（实际指向的对象类型）。这就是多态性的体现。</p>
<blockquote>
<p>虚函数实现原理</p>
</blockquote>
<p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（<code>virtual function table，vtbl</code>）。</p>
<p>虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址：如果派生类没有重新定义虚函数，该 <code>vtbl</code> 将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img21/image-20230110120340141.png" alt="image-20230110120340141"></p>
<p>调用虚函数时，程序将查看存储在对象中的 <code>vtbl</code> 地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。</p>
<p>总之，使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>
<ul>
<li>每个对象都将增大，增大量为存储地址的空间；</li>
<li>对于每个类，编译器都创建一个虚函数地址表（数组）；</li>
<li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</li>
</ul>
<p>虽然非虚函数的效率比虚函数稍高，但不具备动态联编功能。</p>
<h4 id="11-3-3-虚函数的注意事项"><a href="#11-3-3-虚函数的注意事项" class="headerlink" title="11.3.3 虚函数的注意事项"></a>11.3.3 虚函数的注意事项</h4><ul>
<li>构造函数不能是虚函数</li>
<li>析构函数应当是虚函数，通常应该给基类提供一个虚析构函数，即使它不需要析构函数</li>
</ul>
<p>例如，<code>Employee</code>是基类，<code>Singer</code>是派生类，并添加了一个<code>char *</code>成员，该成员指向由new分配的内存，当<code>Singer</code>对象过期时，必须调用<code>~Singer()</code>析构函数来释放内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Employee * pe = <span class="keyword">new</span> Singer;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">delete</span> pe; <span class="comment">// 释放pe对象</span></span><br></pre></td></tr></table></figure>
<p>如果使用默认的静态联编，delete 语句将调用<code>~Employee</code>析构函数。这将释放由 Singer 对象中的Employee部分指向的内存，但不会释放新的类成员指向的内存。</p>
<p>但如果析构函数是虚的，则上述代码将先调用<code>~Singer</code>析构函数释放由 Singer 组件指向的内存，然后，调用<code>~Employec</code>析构函数来释放由 Employee 组件指向的内存。</p>
<p>这意味着，即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供<strong>虚析构函数</strong>，即使它不执行任何操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">BaseClass</span>() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>友元不能是虚函数，因为友元不是类的成员函数</li>
<li>重新定义将隐藏方法</li>
</ul>
<p>假设有如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span> :</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hovel trump;</span><br><span class="line">trump.<span class="built_in">showperks</span>(); <span class="comment">// valid</span></span><br><span class="line">trump.<span class="built_in">showperks</span>(<span class="number">5</span>); <span class="comment">// invalid，不能调基类的方法，因为被隐藏了</span></span><br></pre></td></tr></table></figure>
<p>新定义将<code>showperks</code>定义为一个不接受任何参数的函数。重新定义不会生成函数的两个重载版本，而是<strong>隐藏了接受一个 int 参数的基类版本</strong>。总之，重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。</p>
<p>经验规则：</p>
<ul>
<li>如果重新定义继承的方法，应该确保与原来的原型完全相同</li>
</ul>
<p>该条规则有一个例外。如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针，这种特性被称为<strong>返回类型协变</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Dwelling &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span> :</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Hovel &amp; <span class="title">build</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>; <span class="comment">// 不会隐藏基类的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果基类声明被重载了，应在派生类中重新定义所有的基类版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dwelling</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hovel</span> :</span> <span class="keyword">public</span> Dwelling &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showperks</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-4-protected保护访问控制"><a href="#11-4-protected保护访问控制" class="headerlink" title="11.4 protected保护访问控制"></a>11.4 protected保护访问控制</h3><p>private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的对象可以直接访问基类的保护成员，但不能直接访问基类的私有成员。因此，对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Brass</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总结：最好对类的成员数据采用私有访问控制，不要使用保护访问控制。对类的成员方法可以使用保护访问机制。</p>
<h3 id="11-5-抽象基类"><a href="#11-5-抽象基类" class="headerlink" title="11.5 抽象基类"></a>11.5 抽象基类</h3><p>抽象基类（<code>abstract base class, ABC</code>）是将一些共性保存的类，例如一些共同的成员数据和方法，有些方法还需要派生类进行改写，这些方法通过<strong>纯虚函数</strong>提供未实现的方法，纯虚函数声明的结尾处为<code>= 0</code>，纯虚函数没有定义，只有声明。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseEllipse</span> &#123;</span> <span class="comment">// 纯虚函数表明了此类为抽象基类</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Area</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类是抽象基类的充分必要条件是该类至少有一个纯虚函数。</p>
<p>不能创建抽象基类的对象，抽象基类只能用作基类，并派生出子类。</p>
<h3 id="11-6-继承和动态内存分配"><a href="#11-6-继承和动态内存分配" class="headerlink" title="11.6 继承和动态内存分配"></a>11.6 继承和动态内存分配</h3><p>暂略</p>
<h2 id="12-代码重用"><a href="#12-代码重用" class="headerlink" title="12 代码重用"></a>12 代码重用</h2><p>本章将介绍其他方法实现代码重用。</p>
<ul>
<li>组合：使用这样的类成员——本身是另一个类的对象。这种方法称为包含（containment）、组合（composition）或层次化（layering）。</li>
<li>使用私有或保护继承。通常，包含、私有继承和保护继承用于实现<code>has-a</code>关系，即新的类将包含另一个类的对象。例如，HomeTheater类可能包含一个BluRayPlayer对象。</li>
<li>多重继承使得能够使用两个或更多的基类派生出新的类，将基类的功能组合在一起。</li>
<li>类模板使我们能够使用通用术语定义类，然后使用模板来创建针对特定类型定义的特殊类。例如，可以定义一个通用的栈模板，然后使用该模板创建一个用于表示int值栈的类和一个用于表示double值栈的类，甚至可以创建一个这样的类，即用于表示由栈组成的栈。</li>
</ul>
<h3 id="12-1-包含对象成员的类"><a href="#12-1-包含对象成员的类" class="headerlink" title="12.1 包含对象成员的类"></a>12.1 包含对象成员的类</h3><h3 id="12-2-私有继承"><a href="#12-2-私有继承" class="headerlink" title="12.2 私有继承"></a>12.2 私有继承</h3><h3 id="12-3-多重继承"><a href="#12-3-多重继承" class="headerlink" title="12.3 多重继承"></a>12.3 多重继承</h3><h3 id="12-4-类模板"><a href="#12-4-类模板" class="headerlink" title="12.4 类模板"></a>12.4 类模板</h3><h4 id="12-4-1-定义类模板"><a href="#12-4-1-定义类模板" class="headerlink" title="12.4.1 定义类模板"></a>12.4.1 定义类模板</h4><p>原来的类声明如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> Item;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>MAX = <span class="number">10</span>&#125;;</span><br><span class="line">    Item items[MAX];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Item &amp; item)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>采用模板时，将使用模板定义替换Stack声明，使用模板成员函数替换Stack的成员函数。和模板函数一样，模板类以下面这样的代码开头：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span> <span class="comment">// Type为类型参数，可以看成变量，但赋给它们的不能是数字，只能是类型</span></span><br></pre></td></tr></table></figure>
<p>关键字<code>template</code>告诉编译器，将要定义一个模板。尖括号中的内容相当于<strong>函数的参数列表</strong>。可以把关键字class看作是变量的类型名，该变量接受类型作为其值，把<code>Type</code>看作是该变量的名称，被称为类型参数。</p>
<p>这里使用class并不意味着Type必须是一个类；而只是表明Type是一个通用的类型说明符，在使用模板时，将使用实际的类型替换它。较新的C++实现允许在这种情况下使用不太容易混淆的关键字 <code>typename</code> 代替class：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用自己的泛型名代替Type，其命名规则与其他标识符相同。当前流行的选项包括<code>T</code>和<code>Type</code>。当模板被调用时，Type将被具体的类型值（如int或string）取代。</p>
<ul>
<li>在模板定义中，可以使用泛型名来标识要存储在栈中的类型。对于Stack来说，这意味着应将声明中所有的typedef标识符Item 替换为Type。例如，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Item items[MAX];</span><br><span class="line"><span class="comment">// 修改为</span></span><br><span class="line">Type items[MAX];</span><br></pre></td></tr></table></figure>
<ul>
<li>可以使用模板成员函数替换原有类的类方法。<strong>每个函数头都将以相同的模板声明打头</strong>：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>需将类限定符从<code>Stack::</code>改为<code>Stack&lt;Type&gt;::</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Stack::push</span><span class="params">(<span class="keyword">const</span> Item &amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改为：</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;T&gt;::<span class="built_in">push</span>(<span class="keyword">const</span> T &amp; item) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改后的代码</p>
</blockquote>
<p>模板的具体实现——如用来处理string对象的栈类——被称为<strong>实例化</strong>（instantiation）或具体化（specialization）。</p>
<p>不能将模板成员函数放在独立的实现文件中。由于模板不是函数，它们不能单独编译。模板必须与特定的模板实例化请求一起使用。为此，最简单的方法是将所有模板信息放在一个头文件中，并在要使用这些模板的文件中包含该头文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stacktp.h -- a stack template</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STACKTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STACKTP_H_</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>MAX = <span class="number">10</span>&#125;;    <span class="comment">// constant specific to class</span></span><br><span class="line">    Type items[MAX];    <span class="comment">// holds stack items</span></span><br><span class="line">    <span class="keyword">int</span> top;            <span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Type &amp; item)</span></span>; <span class="comment">// add item to stack</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Type &amp; item)</span></span>;        <span class="comment">// pop top into item</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line">Stack&lt;Type&gt;::<span class="built_in">Stack</span>() &#123;</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">isempty</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> top == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">isfull</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">push</span>(<span class="keyword">const</span> Type &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; MAX) &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">pop</span>(Type &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="12-4-2-使用模板类"><a href="#12-4-2-使用模板类" class="headerlink" title="12.4.2 使用模板类"></a>12.4.2 使用模板类</h4><p>仅在程序包含模板并不能生成模板类，而必须请求实例化。为此，需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛型名。例如，下面的代码创建两个栈，一个用于存储int，另一个用于存储string对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">int</span>&gt; kernels;</span><br><span class="line">Stack&lt;string&gt; colonels;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试程序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stacktem.cpp -- testing the template stack class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stacktp.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack&lt;std::string&gt; st;   <span class="comment">// create an empty stack</span></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    std::string po;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter A to add a purchase order,\n&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;P to process a PO, or Q to quit.\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch &amp;&amp; std::<span class="built_in">toupper</span>(ch) != <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!std::<span class="built_in">isalpha</span>(ch)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\a&#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: cout &lt;&lt; <span class="string">&quot;Enter a PO number to add: &quot;</span>;</span><br><span class="line">                      cin &gt;&gt; po;</span><br><span class="line">                      <span class="keyword">if</span> (st.<span class="built_in">isfull</span>())</span><br><span class="line">                          cout &lt;&lt; <span class="string">&quot;stack already full\n&quot;</span>;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                          st.<span class="built_in">push</span>(po);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>: <span class="keyword">if</span> (st.<span class="built_in">isempty</span>())</span><br><span class="line">                          cout &lt;&lt; <span class="string">&quot;stack already empty\n&quot;</span>;</span><br><span class="line">                      <span class="keyword">else</span> &#123;</span><br><span class="line">                          st.<span class="built_in">pop</span>(po);</span><br><span class="line">                          cout &lt;&lt; <span class="string">&quot;PO #&quot;</span> &lt;&lt; po &lt;&lt; <span class="string">&quot; popped\n&quot;</span>;</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Please enter A to add a purchase order,\n&quot;</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;P to process a PO, or Q to quit.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-4-3-指针类模板"><a href="#12-4-3-指针类模板" class="headerlink" title="12.4.3 指针类模板"></a>12.4.3 指针类模板</h4><p>以刚才的模板类为例，如果传入<code>char *</code>为类型参数，则可能发生错误</p>
<blockquote>
<p>代码示例1</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试程序</span></span><br><span class="line">Stack&lt;<span class="keyword">char</span> *&gt; st;</span><br><span class="line"><span class="keyword">char</span> * po;</span><br></pre></td></tr></table></figure>
<p>这旨在用 char指针而不是string 对象来接收键盘输入。这种方法很快就失败了，因为仅仅创建指针，没有创建用于保存输入字符串的空间（程序将通过编译，但在cin试图将输入保存在某些不合适的内存单元中时崩溃）。</p>
<blockquote>
<p>代码示例2</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">char</span> *&gt; st;</span><br><span class="line"><span class="keyword">char</span> po[<span class="number">40</span>];</span><br></pre></td></tr></table></figure>
<p>这为输入的字符串分配了空间。另外，po的类型为char*，因此可以被放在栈中。但数组完全与<code>pop</code>方法的假设相冲突：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">pop</span>(Type &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top]; <span class="comment">// 这里的item为数组名</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，引用变量item必须引用某种类型的左值，而不是数组名。其次，代码假设可以给item赋值。即使item能够引用数组，也不能为数组名赋值。因此这种方法失败了。</p>
<blockquote>
<p>代码示例3</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="keyword">char</span> *&gt; st;</span><br><span class="line"><span class="keyword">char</span> * po = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">40</span>];</span><br></pre></td></tr></table></figure>
<p>这为输入的字符串分配了空间。另外，po是变量（指针），因此与pop的代码兼容。然而，这里将会遇到最基本的问题：只有一个 po 变量，该变量总是指向相同的内存单元。确实，在每当读取新字符串时，内存的内容都将发生改变，但每次执行压入操作时，加入到栈中的的地址都相同。因此，对栈执行弹出操作时，得到的地址总是相同的，它总是指向读入的最后一个字符串。具体地说，栈并没有保存每一个新字符串，因此没有任何用途。</p>
<hr>
<p>使用指针栈的方法之一是，让调用程序提供一个指针数组，其中每个指针都指向不同的字符串。把这些指针放在栈中是有意义的，因为每个指针都将指向不同的字符串。注意，创建不同指针是调用程序的职责，而不是栈的职责。栈的任务是管理指针，而不是创建指针。</p>
<blockquote>
<p>修改后的程序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stcktp1.h -- modified Stack template</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STCKTP1_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STCKTP1_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>SIZE = <span class="number">10</span>&#125;;    <span class="comment">// default size</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">    Type * items;       <span class="comment">// holds stack items</span></span><br><span class="line">    <span class="keyword">int</span> top;            <span class="comment">// index for top stack item</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(<span class="keyword">int</span> ss = SIZE)</span></span>;</span><br><span class="line">    <span class="built_in">Stack</span>(<span class="keyword">const</span> Stack &amp; st);</span><br><span class="line">    ~<span class="built_in">Stack</span>() &#123; <span class="keyword">delete</span> [] items; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isempty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isfull</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top == stacksize; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> Type &amp; item)</span></span>;   <span class="comment">// add item to stack</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(Type &amp; item)</span></span>;          <span class="comment">// pop top into item</span></span><br><span class="line">    Stack &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Stack &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line">Stack&lt;Type&gt;::<span class="built_in">Stack</span>(<span class="keyword">int</span> ss) : <span class="built_in">stacksize</span>(ss), <span class="built_in">top</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    items = <span class="keyword">new</span> Type [stacksize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line">Stack&lt;Type&gt;::<span class="built_in">Stack</span>(<span class="keyword">const</span> Stack &amp; st) &#123;</span><br><span class="line">    stacksize = st.stacksize;</span><br><span class="line">    top = st.top;</span><br><span class="line">    items = <span class="keyword">new</span> Type [stacksize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">        items[i] = st.items[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">push</span>(<span class="keyword">const</span> Type &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; stacksize) &#123;</span><br><span class="line">        items[top++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> Stack&lt;Type&gt;::<span class="built_in">pop</span>(Type &amp; item) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line">Stack&lt;Type&gt; &amp; Stack&lt;Type&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> Stack&lt;Type&gt; &amp; st) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] items;</span><br><span class="line">    stacksize = st.stacksize;</span><br><span class="line">    top = st.top;</span><br><span class="line">    items = <span class="keyword">new</span> Type [stacksize];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">        items[i] = st.items[i];</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试程序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stkoptr1.cpp -- testing stack of pointers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span>     <span class="comment">// for rand(), srand()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span>       <span class="comment">// for time()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stcktp1.h&quot;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Num = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">srand</span>(std::<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// randomize rand()</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Please enter stack size: &quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">    std::cin &gt;&gt; stacksize;</span><br><span class="line"><span class="comment">// create an empty stack with stacksize slots</span></span><br><span class="line">    <span class="function">Stack&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; <span class="title">st</span><span class="params">(stacksize)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// in basket</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * in[Num] = &#123;</span><br><span class="line">            <span class="string">&quot; 1: Hank Gilgamesh&quot;</span>, <span class="string">&quot; 2: Kiki Ishtar&quot;</span>,</span><br><span class="line">            <span class="string">&quot; 3: Betty Rocker&quot;</span>, <span class="string">&quot; 4: Ian Flagranti&quot;</span>,</span><br><span class="line">            <span class="string">&quot; 5: Wolfgang Kibble&quot;</span>, <span class="string">&quot; 6: Portia Koop&quot;</span>,</span><br><span class="line">            <span class="string">&quot; 7: Joy Almondo&quot;</span>, <span class="string">&quot; 8: Xaverie Paprika&quot;</span>,</span><br><span class="line">            <span class="string">&quot; 9: Juan Moore&quot;</span>, <span class="string">&quot;10: Misha Mache&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"> <span class="comment">// out basket</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * out[Num];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nextin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (processed &lt; Num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st.<span class="built_in">isempty</span>())</span><br><span class="line">            st.<span class="built_in">push</span>(in[nextin++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">isfull</span>())</span><br><span class="line">            st.<span class="built_in">pop</span>(out[processed++]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">rand</span>() % <span class="number">2</span>  &amp;&amp; nextin &lt; Num)   <span class="comment">// 50-50 chance</span></span><br><span class="line">            st.<span class="built_in">push</span>(in[nextin++]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            st.<span class="built_in">pop</span>(out[processed++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Num; i++)</span><br><span class="line">        std::cout &lt;&lt; out[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bye\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-4-4-数组模板和非类型参数"><a href="#12-4-4-数组模板和非类型参数" class="headerlink" title="12.4.4 数组模板和非类型参数"></a>12.4.4 数组模板和非类型参数</h4><p>模板常用作<strong>容器类</strong>，这是因为类型参数的概念非常适合于将相同的存储方案用于不同的类型。为容器类提供可重用代码是引入模板的主要动机。</p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arraytp.h  -- Array Template</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ARRAYTP_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARRAYTP_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTP</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T ar[n];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ArrayTP</span>() &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ArrayTP</span><span class="params">(<span class="keyword">const</span> T &amp; v)</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> T &amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> i);</span><br><span class="line">    <span class="keyword">virtual</span> T <span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br><span class="line">ArrayTP&lt;T,n&gt;::<span class="built_in">ArrayTP</span>(<span class="keyword">const</span> T &amp; v) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        ar[i] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br><span class="line">T &amp; ArrayTP&lt;T,n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">            &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br><span class="line">T ArrayTP&lt;T,n&gt;::<span class="keyword">operator</span>[](<span class="keyword">int</span> i) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error in array limits: &quot;</span> &lt;&lt; i</span><br><span class="line">            &lt;&lt; <span class="string">&quot; is out of range\n&quot;</span>;</span><br><span class="line">        std::<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ar[i]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>模板头为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">n</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>关键字class指出T为类型参数，int指出n的类型为int。这种参数（指定特殊的类型而不是用作泛型名）称为<strong>非类型</strong>（non-type）或表达式（expression）参数。假设有下面的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">12</span>&gt; eggweights;</span><br></pre></td></tr></table></figure>
<p>这将导致编译器定义名为 <code>ArrayTP&lt;double，12&gt;</code>的类，并创建一个类型为 <code>ArrayTP&lt;double，12&gt;</code>的eggweight对象。定义类时，编译器将使用double替换T，使用12替换n。</p>
<p>非类型参数的限制：</p>
<ul>
<li>可以使用整型、枚举、引用或指针，值必须是常量表达式</li>
<li>模板代码不能修改参数的值，不能使用参数的地址</li>
</ul>
<p>缺点：每种数组大小都将生成自己的模板，也就是说，下面的声明将生成两个独立的类声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">12</span>&gt; eggweights;</span><br><span class="line">ArrayTP&lt;<span class="keyword">double</span>, <span class="number">13</span>&gt; donuts;</span><br></pre></td></tr></table></figure>
<h4 id="12-4-5-模板多功能性"><a href="#12-4-5-模板多功能性" class="headerlink" title="12.4.5 模板多功能性"></a>12.4.5 模板多功能性</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/img/C++.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="/img/stl.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++标准模板库学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/11/%E6%97%A5%E8%AF%AD%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/"><img class="next-cover" src="/img/bunpo.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">日语其他语法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/09/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="C++标准模板库学习笔记"><img class="cover" src="/img/stl.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">C++标准模板库学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">C++学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IDE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-text">1 IDE环境搭建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-text">2 快速开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C-%E7%A8%8B%E5%BA%8F"><span class="toc-text">2.1 一个简单的C++程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%88%9D%E8%AF%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">2.2 初识输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.2.1 标准输入与输出对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.2.2 程序实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">2.3 控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-while"><span class="toc-text">2.3.1 while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-for"><span class="toc-text">2.3.2 for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-if"><span class="toc-text">2.3.3 if</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-text">3 变量和基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1 基本内置类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E7%AE%97%E6%9C%AF%E7%B1%BB%E5%9E%8B"><span class="toc-text">3.1.1 算术类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.1.2 类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">4 复合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-text">4.1 命名空间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E5%8E%86%E5%8F%B2"><span class="toc-text">4.1.1 历史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E7%AE%80%E4%BB%8B"><span class="toc-text">4.1.2 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-text">4.1.3 使用语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-using%E5%A3%B0%E6%98%8E"><span class="toc-text">4.1.4 using声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E7%BB%84"><span class="toc-text">4.2 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.3 字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-string%E7%B1%BB"><span class="toc-text">4.4 string类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1-%E7%AE%80%E4%BB%8B%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">4.4.1 简介和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2-%E8%B5%8B%E5%80%BC%E3%80%81%E6%8B%BC%E6%8E%A5%E5%92%8C%E9%99%84%E5%8A%A0"><span class="toc-text">4.4.2 赋值、拼接和附加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3-%E9%95%BF%E5%BA%A6"><span class="toc-text">4.4.3 长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%BB%93%E6%9E%84"><span class="toc-text">4.5 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E8%81%94%E5%90%88"><span class="toc-text">4.6 联合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.7 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E6%8C%87%E9%92%88"><span class="toc-text">4.8 指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-1-%E8%A1%A5%E5%85%85%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">4.8.1 补充和注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-2-new%E5%92%8Cdelete"><span class="toc-text">4.8.2 new和delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-3-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">4.8.3 动态数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF"><span class="toc-text">4.9 指针算术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-1-%E6%95%B0%E7%BB%84%E5%90%8D"><span class="toc-text">4.9.1 数组名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-9-2-%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4.9.2 指针和字符串</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BE%AA%E7%8E%AF"><span class="toc-text">5 循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%88%86%E6%94%AF"><span class="toc-text">6 分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%87%BD%E6%95%B0"><span class="toc-text">7 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">7.1 内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">7.2 引用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E5%88%9B%E5%BB%BA%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">7.2.1 创建引用变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E5%B0%86%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">7.2.2 将引用作为函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-%E5%BC%95%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E7%89%B9%E5%88%AB%E4%B9%8B%E5%A4%84"><span class="toc-text">7.2.3 引用的属性和特别之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-4-%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E3%80%81%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E5%92%8Cconst"><span class="toc-text">7.2.4 临时变量、引用参数和const</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-5-%E5%B0%86%E5%BC%95%E7%94%A8%E7%94%A8%E4%BA%8E%E7%BB%93%E6%9E%84"><span class="toc-text">7.2.5 将引用用于结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-6-%E5%B0%86%E5%BC%95%E7%94%A8%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.2.6 将引用用于类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-7-%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-text">7.2.7 使用引用参数的时机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-text">7.3 默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-text">7.4 函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-text">7.5 函数模板</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="toc-text">8 对象和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text">8.1 基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-text">8.1.1 类的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">8.1.2 访问控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E6%8E%A7%E5%88%B6%E5%AF%B9%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-text">8.1.3 控制对成员的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">8.1.4 实现类成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">8.1.5 使用类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-6-%E5%B0%8F%E7%BB%93"><span class="toc-text">8.1.6 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">8.2 构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.1 声明和定义构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.2 使用构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.3 默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">8.2.4 析构函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-5-%E6%94%B9%E8%BF%9BStock%E7%B1%BB"><span class="toc-text">8.2.5 改进Stock类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-this%E6%8C%87%E9%92%88"><span class="toc-text">8.3 this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-text">8.4 对象数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">8.5 类作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">8.5.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-2-%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%B8%B8%E9%87%8F"><span class="toc-text">8.5.2 作用域为类的常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">8.6 抽象数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">9 类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-text">9.1 运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E6%A6%82%E5%BF%B5%E5%92%8C%E5%BC%95%E5%85%A5"><span class="toc-text">9.1.1 概念和引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-%E5%8A%A0%E6%B3%95%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.1.2 加法运算符重载示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E9%87%8D%E8%BD%BD%E9%99%90%E5%88%B6"><span class="toc-text">9.1.3 重载限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E5%85%B6%E4%BB%96%E9%87%8D%E8%BD%BD%E7%A4%BA%E4%BE%8B"><span class="toc-text">9.1.4 其他重载示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E5%8F%8B%E5%85%83"><span class="toc-text">9.2 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E6%A6%82%E5%BF%B5"><span class="toc-text">9.2.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E5%88%9B%E5%BB%BA%E5%8F%8B%E5%85%83"><span class="toc-text">9.2.2 创建友元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%8B%E5%85%83%EF%BC%9A%E9%87%8D%E8%BD%BD-lt-lt-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">9.2.3 常用的友元：重载&lt;&lt;运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E7%B1%BB%E7%9A%84%E8%87%AA%E5%8A%A8%E5%92%8C%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">9.3 类的自动和强制类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="toc-text">9.3.1 构造函数转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0%E8%BD%AC%E6%8D%A2"><span class="toc-text">9.3.2 转换函数转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">10 类和动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%92%8C%E7%B1%BB"><span class="toc-text">10.1 动态内存和类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-text">10.1.1 问题引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">10.1.2 复制构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-3-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">10.1.3 赋值运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E6%94%B9%E8%BF%9B%E5%90%8E%E7%9A%84%E6%96%B0String%E7%B1%BB"><span class="toc-text">10.2 改进后的新String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">10.2.1 修改后的默认构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-%E6%AF%94%E8%BE%83%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">10.2.2 比较成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-%E4%B8%AD%E6%8B%AC%E5%8F%B7%E8%AE%BF%E9%97%AE%E5%AD%97%E7%AC%A6"><span class="toc-text">10.2.3 中括号访问字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-4-%E9%9D%99%E6%80%81%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">10.2.4 静态类成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%87%8D%E8%BD%BD%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">10.2.5 进一步重载赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-6-%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84String%E4%BB%A3%E7%A0%81"><span class="toc-text">10.2.6 修改后的String代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%ADnew%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">10.3 构造函数中new的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-text">10.4 使用指向对象的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-%E7%A8%8B%E5%BA%8F%E7%A4%BA%E4%BE%8B"><span class="toc-text">10.4.1 程序示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-new%E5%92%8Cdelete"><span class="toc-text">10.4.2 new和delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">10.4.3 小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-text">11 类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-text">11.1 问题引入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-1-%E5%9F%BA%E7%B1%BB"><span class="toc-text">11.1.1 基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-2-%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">11.1.2 派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">11.1.3 构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-4-%E4%BD%BF%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-text">11.1.4 使用派生类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-5-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E5%85%B3%E7%B3%BB"><span class="toc-text">11.1.5 派生类和基类的特殊关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E5%A4%9A%E6%80%81%E5%85%AC%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">11.2 多态公有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">11.3 静态联编和动态联编</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-text">11.3.1 指针和引用类型的兼容性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-2-%E8%99%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">11.3.2 虚成员函数和动态联编</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-3-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">11.3.3 虚函数的注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-protected%E4%BF%9D%E6%8A%A4%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-text">11.4 protected保护访问控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">11.5 抽象基类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6-%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">11.6 继承和动态内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8"><span class="toc-text">12 代码重用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E5%8C%85%E5%90%AB%E5%AF%B9%E8%B1%A1%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB"><span class="toc-text">12.1 包含对象成员的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%E7%A7%81%E6%9C%89%E7%BB%A7%E6%89%BF"><span class="toc-text">12.2 私有继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-text">12.3 多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">12.4 类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-%E5%AE%9A%E4%B9%89%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">12.4.1 定义类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-text">12.4.2 使用模板类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-3-%E6%8C%87%E9%92%88%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-text">12.4.3 指针类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-4-%E6%95%B0%E7%BB%84%E6%A8%A1%E6%9D%BF%E5%92%8C%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-text">12.4.4 数组模板和非类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-5-%E6%A8%A1%E6%9D%BF%E5%A4%9A%E5%8A%9F%E8%83%BD%E6%80%A7"><span class="toc-text">12.4.5 模板多功能性</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">欢迎来到我的个人博客!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>