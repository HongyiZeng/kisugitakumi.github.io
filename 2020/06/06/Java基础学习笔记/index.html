<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java基础学习笔记 | Kisugi Takumi</title><meta name="keywords" content="Java,Java基础"><meta name="author" content="Kisugi Takumi,zenghongyi1@google.com"><meta name="copyright" content="Kisugi Takumi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一次编译，到处运行">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础学习笔记">
<meta property="og:url" content="https://kisugitakumi.github.io/2020/06/06/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Kisugi Takumi">
<meta property="og:description" content="一次编译，到处运行">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kisugitakumi.github.io/img/design.png">
<meta property="article:published_time" content="2020-06-06T03:46:25.000Z">
<meta property="article:modified_time" content="2022-01-19T18:19:49.207Z">
<meta property="article:author" content="Kisugi Takumi">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kisugitakumi.github.io/img/design.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kisugitakumi.github.io/2020/06/06/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Kisugi Takumi","link":"链接: ","source":"来源: Kisugi Takumi","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-20 02:19:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">57</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Kisugi Takumi</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-brain"></i><span> 我的豆瓣</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 书籍</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fab fa-steam-square"></i><span> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/create/"><i class="fa-fw fas fa-user-edit"></i><span> 我的创作</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-kiss-wink-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-06-06T03:46:25.000Z" title="发表于 2020-06-06 11:46:25">2020-06-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-19T18:19:49.207Z" title="更新于 2022-01-20 02:19:49">2022-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/">开发基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Java基础学习笔记"><a href="#Java基础学习笔记" class="headerlink" title="Java基础学习笔记"></a>Java基础学习笔记</h1><h2 id="1-集合"><a href="#1-集合" class="headerlink" title="1 集合"></a>1 集合</h2><h3 id="1-1-集合框架概述"><a href="#1-1-集合框架概述" class="headerlink" title="1.1 集合框架概述"></a>1.1 集合框架概述</h3><p>集合，数组都是对多个数据进行存储的结构，简称Java容器。说明：此时的存储是内存层面的存储，不涉及持久化的存储。</p>
<p>java集合可分为Collection和Map两种体系。</p>
<ol>
<li>Collection接口：单列数据，定义了存取一组对象的方法和集合。</li>
</ol>
<ul>
<li>List：元素有序，可重复的集合</li>
<li>Set：元素无序，不可重复的集合</li>
</ul>
<ol>
<li>Map接口：双列数据，保存具有映射关系Key-Value对的集合。</li>
</ol>
<h4 id="1-1-1-数组的特点"><a href="#1-1-1-数组的特点" class="headerlink" title="1.1.1 数组的特点"></a>1.1.1 数组的特点</h4><blockquote>
<p>数组在存储多个数据方面的特点</p>
</blockquote>
<ol>
<li><p>一旦初始化以后，其长度就确定了</p>
</li>
<li><p>数组一旦定义好，其元素的类型也就确定了，例如String[] arr；Object[] arr等</p>
</li>
</ol>
<blockquote>
<p>数组在存储多个数据方面的缺点</p>
</blockquote>
<ol>
<li><p>一旦初始化后，其长度就无法修改</p>
</li>
<li><p>数组中提供的方法非常有限，对于添加，删除，插入数据等操作非常不便，同时效率不高。</p>
</li>
<li><p>对于获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</p>
</li>
<li><p>数组存储数据的特点：有序，可重复。对于无序，不可重复的需求，数组不能满足。</p>
</li>
</ol>
<h4 id="1-1-2-集合框架"><a href="#1-1-2-集合框架" class="headerlink" title="1.1.2 集合框架"></a>1.1.2 集合框架</h4><p>|——Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​        |——List接口：存储有序的，可重复的数据。“动态数组”</p>
<p>​                |——ArrayList，LinkedList，Vector</p>
<p>​        |——Set接口：存储无序的，不可重复的数据。高中讲的“集合”</p>
<p>​                |——HashSet，LinkedHashSet，TreeSet</p>
<p>|——Map接口：双列集合，用来存储一对一对的数据。 高中讲的“函数”：y = f(x)</p>
<p>​        |——HashMap，LinkedHashMap，TreeMap，Hashtable，Properties</p>
<h3 id="1-2-Collection接口"><a href="#1-2-Collection接口" class="headerlink" title="1.2 Collection接口"></a>1.2 Collection接口</h3><h4 id="1-2-1-Collection接口中的常用方法"><a href="#1-2-1-Collection接口中的常用方法" class="headerlink" title="1.2.1 Collection接口中的常用方法"></a>1.2.1 Collection接口中的常用方法</h4><blockquote>
<p><code>add()</code>，<code>addAll()</code>，<code>clear()</code>，<code>size()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 以实现类ArrayList中的方法为例</span></span><br><span class="line">  Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  <span class="comment">// add(Object e):将元素e添加到集合coll中</span></span><br><span class="line">  coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">  coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">  coll.add(<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// size():获取添加的元素的个数</span></span><br><span class="line">  System.out.println(coll.size());<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// addAll(Collection coll1):将coll1中的元素添加到当前的集合中</span></span><br><span class="line">  Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">  coll1.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">  coll1.add(<span class="keyword">new</span> Date());</span><br><span class="line">  coll.addAll(coll1);</span><br><span class="line">  System.out.println(coll.size());<span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// clear():清空集合中的元素</span></span><br><span class="line">  <span class="comment">// coll.clear();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// isEmpty():判断当前集合是否为空</span></span><br><span class="line">  System.out.println(coll.isEmpty());<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>contains()</code>，<code>containsAll()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> Date());</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">// contains在判断时会调用obj对象所在类的equals方法。通常自定义的类都要重写equals方法。</span></span><br><span class="line">    <span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">    System.out.println(contains);<span class="comment">// true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>)));<span class="comment">// true 判断的是内容，调用的是equals，而不是==</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>)));<span class="comment">// false 如果重写Person类的equals则为true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// containsAll(Collection coll1):判断形参coll1中的所有元素是否都存在与当前集合中</span></span><br><span class="line">    Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Person</code>类中重写的<code>equals</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// idea自动生成的重写Object类里的equals方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是同一个对象，则为真</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 比较对象为空，则为假</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 强转为Person</span></span><br><span class="line">    Person person = (Person) o;</span><br><span class="line">    <span class="comment">// 先比较age字段</span></span><br><span class="line">    <span class="keyword">if</span> (age != person.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 再比较name字段</span></span><br><span class="line">    <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(person.name) : person.name == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>remove()</code>，<code>removeAll()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove(Object obj):移除集合中的指定元素，移除成功返回true，不成功为false</span></span><br><span class="line">    System.out.println(coll.remove(<span class="number">123</span>));<span class="comment">// true 表明已移除</span></span><br><span class="line">    System.out.println(coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">20</span>)));<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeAll():差集：从当前集合中移除coll1中的所有的元素</span></span><br><span class="line">    Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);</span><br><span class="line">    coll.removeAll(coll1);</span><br><span class="line">    System.out.println(coll);<span class="comment">// [Tom, false]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>retainAll()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.retainAll(coll1);<span class="comment">// 获取coll和coll1的交集，并返回给coll</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>equals()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="comment">// 注意ArrayList是有序的，比较时就要判断顺序</span></span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll1.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll1.add(<span class="number">456</span>);</span><br><span class="line">    coll1.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll1.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// equals(Collection coll1):比较当前集合和coll1中的内容和对应顺序是否都一样</span></span><br><span class="line">    System.out.println(coll.equals(coll1));<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>hashCode()</code>，<code>toArray()</code>，<code>Arrays.asList()</code></p>
</blockquote>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// hashCode():返回当前对象的hash值</span></span><br><span class="line">    System.out.println(coll.hashCode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合转换为数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组转换为集合:调用Arrays的静态方法asList()</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>&#125;);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-2-集合元素的遍历"><a href="#1-2-2-集合元素的遍历" class="headerlink" title="1.2.2 集合元素的遍历"></a>1.2.2 集合元素的遍历</h4><p>集合元素的遍历操作，需要使用Iterator接口。</p>
<ul>
<li>设计模式给迭代器模式的定义为：提供一种方法访问一个容器对象中的各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</li>
<li>Collection接口继承了<code>java.lang.Iterable</code>接口，该接口有一个<code>iterator()</code>方法，那么所有实现了Collection接口的集合类都有一个iterator方法，用以返回一个实现了Iterator接口的对象。</li>
<li>Iterator仅用于遍历集合，其本身不具有提供承载对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合。</li>
<li>==集合对象每次调用iterator方法都得到一个全新的迭代器对象==，默认游标都在集合的第一个元素之前。</li>
</ul>
<blockquote>
<p>遍历代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line">    <span class="comment">// 获取集合对象的迭代器</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="comment">// 集合遍历：</span></span><br><span class="line">    <span class="comment">// 方法1：不推荐</span></span><br><span class="line">    <span class="comment">// next():获取游标的下一个元素，游标的初始位置在集合首个元素之前一个位置</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    <span class="comment">// 报异常：NoSuchElementException</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：不推荐</span></span><br><span class="line">    Iterator iterator1 = coll.iterator();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coll.size();i++)&#123;</span><br><span class="line">        System.out.println(iterator1.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：推荐 hasNext()和next()搭配使用</span></span><br><span class="line">    Iterator iterator2 = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">        <span class="comment">// next():1.指针下移 2.将下移以后的位置上的元素返回</span></span><br><span class="line">        System.out.println(iterator2.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代器原理</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224454538.png" alt="image-20211215224454538"></p>
<blockquote>
<p>用迭代器遍历的错误写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>((iterator.next()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;<span class="comment">// 导致间隔输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(coll.iterator().hasNext())&#123;<span class="comment">// 每次循环都会产生新的迭代器</span></span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;<span class="comment">// 死循环，且只输出第一个元素</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>迭代器的<code>remove()</code></p>
</blockquote>
<p>可以在遍历的时候删除集合中的元素。此方法不同于集合直接调用<code>remove</code>方法</p>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除集合中&quot;Tom&quot;字符串</span></span><br><span class="line">    Iterator iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object obj = iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果还未调用next就调用remove，或者调用一次remove后再次调用remove，会报<code>IllegalStateException</code>异常。</p>
<h4 id="1-2-3-foreach循环遍历"><a href="#1-2-3-foreach循环遍历" class="headerlink" title="1.2.3 foreach循环遍历"></a>1.2.3 <code>foreach</code>循环遍历</h4><p><code>jdk5.0</code>新增特性，用于遍历数组和集合。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    coll.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for(集合中元素的类型 局部变量:集合对象)&#123; ... &#125;</span></span><br><span class="line">    <span class="comment">// 内部仍然调用了迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// foreach遍历数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: arr) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个练习题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String arr[] = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;MM&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式1：普通for赋值，此时能够改变原始数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i] = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：增强for循环，此时只能改变局部变量s的值，原始数组不变</span></span><br><span class="line">    <span class="keyword">for</span> (String s : arr)&#123;</span><br><span class="line">        s = <span class="string">&quot;GG&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        System.out.println(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-List接口及其实现类"><a href="#1-3-List接口及其实现类" class="headerlink" title="1.3 List接口及其实现类"></a>1.3 List接口及其实现类</h3><h4 id="1-3-1-List概述"><a href="#1-3-1-List概述" class="headerlink" title="1.3.1 List概述"></a>1.3.1 List概述</h4><ul>
<li>List接口是Collection的子接口，通常使用List来替代数组。</li>
<li>List集合中的元素有序且可重复，每个元素都有对应的索引顺序，可根据整型序号来对元素进行存取。</li>
<li>List接口的常用实现类有<code>ArrayList</code>，<code>LinkedList</code>和<code>Vector</code></li>
</ul>
<blockquote>
<p>面试题：实现类三者的异同？</p>
</blockquote>
<p>同：都是List接口的实现类，存储的都是有序可重复的数据。</p>
<p>异：</p>
<p>|——Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​        |——List接口：存储有序的，可重复的数据。“动态数组”</p>
<p>​                |——ArrayList：<code>JDK1.2</code>，作为List接口的主要实现类，线程不安全的，效率高；底层采用<code>Object[] elementData</code>存储（<code>顺序表</code>）</p>
<p>​                |——LinkedList：<code>JDK1.2</code>，底层采用的<code>双向链表</code>存储，对于频繁的插入和删除操作的效率比上者高。</p>
<p>​                |——Vector：<code>JDK1.0</code>，是List接口的古老实现类，线程安全的，效率低</p>
<h4 id="1-3-2-ArrayList源码分析"><a href="#1-3-2-ArrayList源码分析" class="headerlink" title="1.3.2 ArrayList源码分析"></a>1.3.2 ArrayList源码分析</h4><blockquote>
<p><code>JDK7</code>版本——饿汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">// 底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment">//...一系列添加操作</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 如果此次的添加导致elementData容量不够，则扩容，默认扩容为原来容量的1.5倍（新造一个数组），同时需要将原有的数据复制到新的数组中</span></span><br></pre></td></tr></table></figure>
<p>结论：实际开发中使用带参的构造器，指定出大小：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(<span class="keyword">int</span> capacity);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>JDK8</code>版本——懒汉式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();<span class="comment">// 底层Object[] elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 第一次调用add()时，底层才创建长度为10的数组，并将数据添加进去</span></span><br><span class="line"><span class="comment">// 后续的添加和扩容操作与jdk7无异</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小结</p>
</blockquote>
<p>jdk7的ArrayList对象的创建类似于单例的饿汉式，jdk8类似于单例的懒汉式，延迟了数组的创建，节省内存。</p>
<h4 id="1-3-3-LinkedList源码分析"><a href="#1-3-3-LinkedList源码分析" class="headerlink" title="1.3.3 LinkedList源码分析"></a>1.3.3 LinkedList源码分析</h4><blockquote>
<p><code>JDK8</code>版本</p>
</blockquote>
<ul>
<li>结点结构：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为LinkedList类的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    LinkedList.Node&lt;E&gt; next;</span><br><span class="line">    LinkedList.Node&lt;E&gt; prev;<span class="comment">// 体现了双向链表</span></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">    Node(LinkedList.Node&lt;E&gt; prev, E element, LinkedList.Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加元素（连接在链表尾部）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    LinkedList.Node&lt;E&gt; l = <span class="keyword">this</span>.last;</span><br><span class="line">    LinkedList.Node&lt;E&gt; newNode = <span class="keyword">new</span> LinkedList.Node(l, e, (LinkedList.Node)<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">this</span>.last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>) &#123;<span class="comment">// 链表为空</span></span><br><span class="line">        <span class="keyword">this</span>.first = newNode;<span class="comment">// 作为第一个结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 链表不空</span></span><br><span class="line">        l.next = newNode;<span class="comment">// 连接在尾部</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++<span class="keyword">this</span>.size;</span><br><span class="line">    ++<span class="keyword">this</span>.modCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>分析</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LinkedList list = <span class="keyword">new</span> LinkedList();<span class="comment">// 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">// 将123封装到Node对象</span></span><br><span class="line"><span class="comment">// 不涉及扩容</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-4-List接口的常用方法"><a href="#1-3-4-List接口的常用方法" class="headerlink" title="1.3.4 List接口的常用方法"></a>1.3.4 List接口的常用方法</h4><p>List接口除了有从Collection接口继承的方法外，还添加了一些根据索引来操作集合元素的方法。</p>
<blockquote>
<p>代码演示说明</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    list.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void add(int index,Object ele):在index位置上插入ele</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, BB, 456, Tom, false, Person&#123;name=&#x27;Jerry&#x27;, age=20&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// boolean addAll(int index,Collection eles):从index位置开始将eles的所有元素添加到list中</span></span><br><span class="line">    List list1 = Arrays.asList(<span class="string">&quot;hongyi&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">    list.addAll(<span class="number">1</span>,list1);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, hongyi, true, BB, 456, Tom, false, Person&#123;name=&#x27;Jerry&#x27;, age=20&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object get(int index):获取index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">1</span>));<span class="comment">// hongyi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int indexOf(Object obj):返回obj在集合中首次出现的索引</span></span><br><span class="line">    <span class="comment">// 没有返回-1</span></span><br><span class="line">    System.out.println(list.indexOf(<span class="string">&quot;BB&quot;</span>));<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int lastIndexOf(Object obj):返回obj在集合中最后出现的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object remove(int index):移除index位置上的元素，并返回此元素</span></span><br><span class="line">    <span class="comment">// 注意这个方法重载了Collection的remove方法</span></span><br><span class="line">    System.out.println(list.remove(<span class="number">0</span>));<span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object set(int index,Object obj):将index位置上的元素更改为obj</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// List subList(int fromIndex,int toIndex):返回从fromIndex到toIndex位置上的子集合</span></span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    List list2 = list.subList(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(list2);<span class="comment">//[true, BB, 456]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结常用方法</p>
</blockquote>
<ul>
<li><p>增：<code>add(Object obj)</code></p>
</li>
<li><p>删：<code>remove(int index)</code>/<code>remove(Object obj)</code></p>
</li>
<li><p>改：<code>set()</code></p>
</li>
<li><p>查：<code>get()</code></p>
</li>
<li><p>插：<code>add()</code></p>
</li>
<li><p>长度：<code>size()</code></p>
</li>
<li><p>遍历：1.Iterator迭代器 2.增强for循环 3.普通循环</p>
</li>
</ul>
<h4 id="1-3-5-List集合的遍历"><a href="#1-3-5-List集合的遍历" class="headerlink" title="1.3.5 List集合的遍历"></a>1.3.5 List集合的遍历</h4><blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">123</span>);<span class="comment">// 自动装箱</span></span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));<span class="comment">// 字符串</span></span><br><span class="line">    list.add(<span class="keyword">false</span>);<span class="comment">// 布尔类型（自动装箱）</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));<span class="comment">// 添加自定义类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：迭代器</span></span><br><span class="line">    Iterator iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：增强for循环</span></span><br><span class="line">    <span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：普通for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">        System.out.println(list.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一道笔试题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    list.add(<span class="number">1</span>);</span><br><span class="line">    list.add(<span class="number">2</span>);</span><br><span class="line">    list.add(<span class="number">3</span>);</span><br><span class="line">    updateList(list);</span><br><span class="line">    System.out.println(list);<span class="comment">// [1, 2]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateList</span><span class="params">(List list)</span></span>&#123;</span><br><span class="line">    list.remove(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意区分List中的<code>remove</code>方法</p>
<h3 id="1-4-Set接口及其实现类"><a href="#1-4-Set接口及其实现类" class="headerlink" title="1.4 Set接口及其实现类"></a>1.4 Set接口及其实现类</h3><h4 id="1-4-1-Set概述"><a href="#1-4-1-Set概述" class="headerlink" title="1.4.1 Set概述"></a>1.4.1 Set概述</h4><p>Set接口中没有额外定义新的方法，使用的都是Collection接口定义的方法</p>
<blockquote>
<p>框架</p>
</blockquote>
<p>|——Collection接口：单列集合，用来存储一个一个的对象</p>
<p>​        |——Set接口：存储==无序的，不可重复==的数据。高中讲的“集合”</p>
<p>​                |——HashSet：作为Set的主要实现类；线程不安全，可以存储null值</p>
<p>​                        |——LinkedHashSet：作为HashSet的子类；遍历其内部数据时可以按照添加的顺序去遍历</p>
<p>​                |——TreeSet：可以按照添加的对象的指定属性进行排序，底层采用==红黑树==</p>
<blockquote>
<p>无序和无可重复的理解</p>
</blockquote>
<ul>
<li>无序性：不等于随机性。以HashSet为例，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值添加。</li>
<li>不可重复性：保证添加的元素按照<code>equal</code>方法判断时不能返回<code>true</code>，即相同的元素只能添加一个。</li>
</ul>
<h4 id="1-4-2-HashSet添加元素的过程"><a href="#1-4-2-HashSet添加元素的过程" class="headerlink" title="1.4.2 HashSet添加元素的过程"></a>1.4.2 HashSet添加元素的过程</h4><p>向HashSet中添加元素a，首先，调用a的所在类的hashCode方法，计算出a元素的哈希值，此哈希值接着通过某种算法（例如除留余数法）计算出a在HashSet底层数组中的存放位置，即为索引位置。判断数组此位置上是否已经含有元素：</p>
<p>|—-如果此位置上没有其他元素，则a添加成功；—-&gt;情况1</p>
<p>|—-如果此位置上有其他元素b（或以链表形式存在的多个元素），首先比较a和b的哈希值：</p>
<p>​        |—-如果哈希值不相同，则a添加成功；—-&gt;情况2</p>
<p>​        |—-如果哈希值相同，则需要调用a所在类的equals方法，与链表上的元素逐一相比:</p>
<p>​                |—-如果一旦返回true，则添加失败;</p>
<p>​                |—-如果比较到最后返回false，则a添加成功；—-&gt;情况3</p>
<p>对于添加成功的情况2和情况3，元素a与已经存在指定索引位置上的数据以链表方式进行存储。在JDK7中，元素a放在数组中，指向原来的元素链；在JDK8中，原来的链尾元素指向新添加进来的元素a。（==7上8下==）</p>
<p>HashSet的底层为：==数组+链表==，实质上还是new了一个HashMap</p>
<h4 id="1-4-3-关于equals-和hashCode-方法的重写"><a href="#1-4-3-关于equals-和hashCode-方法的重写" class="headerlink" title="1.4.3 关于equals()和hashCode()方法的重写"></a>1.4.3 关于<code>equals()</code>和<code>hashCode()</code>方法的重写</h4><blockquote>
<p>idea中自动生成的重写方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    User user = (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(user.name) : user.name == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择31作为乘数的原因：选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）。并且31只占用5bits，相乘造成数据溢出的概率较小。31可以由<code>i*31== (i&lt;&lt;5)-1</code>来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）。31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</p>
<blockquote>
<p>重写原则</p>
</blockquote>
<ul>
<li><p>向set添加的元素所在的类必须重写hashCode和equals方法。</p>
</li>
<li><p>重写的两个方法要保持一致性：相等的对象必须有相等的哈希值</p>
</li>
</ul>
<blockquote>
<p>重写hashCode方法的原则</p>
</blockquote>
<ul>
<li><p>在程序运行时，同一个对象多次调用 <code>hashCode()</code> 方法应该返回相同的值。</p>
</li>
<li><p>当两个对象的 <code>equals()</code> 方法比较返回 true 时，这两个对象的 <code>hashCode()</code> 方法的返回值也应相等。</p>
</li>
<li><p>对象中用作 <code>equals()</code> 方法比较的属性，都应该用来计算 hashCode 值。</p>
</li>
</ul>
<blockquote>
<p>重写equals方法的原则</p>
</blockquote>
<p>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</p>
<p>因此，违反了“相等的对象必须具有相等的散列码”。</p>
<p>结论：==复写equals方法的时候一般都需要同时复写hashCode方法==。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</p>
<h4 id="1-4-4-LinkedHashSet的使用"><a href="#1-4-4-LinkedHashSet的使用" class="headerlink" title="1.4.4 LinkedHashSet的使用"></a>1.4.4 LinkedHashSet的使用</h4><p>LinkedHashSet是作为HashSet的子类，在添加数据的同时，还维护了每个数据的添加的先后顺序。即每个结点有前后两个指针域，指示上一个和下一个元素的位置。对于频繁的遍历操作，效率比HashSet高。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashSet的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));<span class="comment">// 重复元素不会被添加进集合</span></span><br><span class="line">    set.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224525688.png" alt="image-20211215224525688"></p>
<blockquote>
<p>原理示意图</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224534048.png" alt="image-20211215224534048"></p>
<h4 id="1-4-5-TreeSet的使用"><a href="#1-4-5-TreeSet的使用" class="headerlink" title="1.4.5 TreeSet的使用"></a>1.4.5 TreeSet的使用</h4><ol>
<li>向TreeSet中添加的数据，要求是==相同类的对象==</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">456</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AA&quot;</span>);<span class="comment">// 此处就会报错，不能添加不同类的对象</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));<span class="comment">// 这里也会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以按照排序后输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line">    set.add(<span class="number">13</span>);</span><br><span class="line">    set.add(<span class="number">6</span>);</span><br><span class="line">    set.add(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224543201.png" alt="image-20211215224543201"></p>
<ol>
<li>TreeSet的底层是==红黑树==</li>
</ol>
<blockquote>
<p>TreeSet的自然排序（要求比较对象所在类实现Comparable接口）</p>
</blockquote>
<p>在TreeSet自然排序中，比较两个对象是否相同的标准为：<code>compareTo()</code>返回值为0,不再是用<code>equals()</code>判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet();</span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">53</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照姓名，年龄从小到大排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">            User user = (User)o;</span><br><span class="line">            <span class="keyword">int</span> compare = <span class="keyword">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span>(compare != <span class="number">0</span>)&#123;<span class="comment">// 先按照姓名排序</span></span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">// 再按照年龄排序</span></span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age,user.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224551930.png" alt="image-20211215224551930"></p>
<blockquote>
<p>TreeSet的定制排序（要求TreeSet的构造器参数为实现Comparator接口的对象）</p>
</blockquote>
<p>在TreeSet定制排序中，比较两个对象是否相同的标准为：<code>compare()</code>返回值为0,不再是用<code>equals()</code>判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">        <span class="comment">// 按照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o, Object t1)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(o <span class="keyword">instanceof</span> User &amp;&amp; t1 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                User u1 = (User)o;</span><br><span class="line">                User u2 = (User)t1;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Set set = <span class="keyword">new</span> TreeSet(com);<span class="comment">// 定制排序</span></span><br><span class="line"></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">53</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mary&quot;</span>,<span class="number">53</span>));<span class="comment">// 添加不进去，因为按照age定制排序且age相同</span></span><br><span class="line">    set.add(<span class="keyword">new</span> User(<span class="string">&quot;Mike&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    Iterator iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224559647.png" alt="image-20211215224559647"></p>
<h3 id="1-5-Map接口及其实现类"><a href="#1-5-Map接口及其实现类" class="headerlink" title="1.5 Map接口及其实现类"></a>1.5 Map接口及其实现类</h3><h4 id="1-5-1-Map框架概述"><a href="#1-5-1-Map框架概述" class="headerlink" title="1.5.1 Map框架概述"></a>1.5.1 Map框架概述</h4><p>|——Map接口：双列集合，用来存储一对一对的数据。 高中讲的“函数”：y = f(x)</p>
<p>​        |——HashMap：作为Map的主要实现类。线程不安全，效率高。可以存储<code>null</code>的key和value。</p>
<p>​                |——LinkedHashMap：保证在遍历Map元素时是按照添加的顺序实现遍历。在原有的HashMap的底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类的执行效率要高于HashMap。</p>
<p>​        |——TreeMap：保证按照添加的键值对进行排序，实现排序遍历。此时考虑key的自然或定制排序。底层是<code>红黑树</code></p>
<p>​        |——Hashtable：注意t小写。Map的古老实现类。线程安全，效率低。不能存储<code>null</code>的key和value</p>
<p>​                |——Properties：常用来处理配置文件。key和value都是String类型。</p>
<blockquote>
<p>HashMap底层</p>
</blockquote>
<ul>
<li><p><code>jdk7</code>数组+链表</p>
</li>
<li><p><code>jdk8</code>数组+链表+==红黑树==</p>
</li>
</ul>
<blockquote>
<p>典型面试题</p>
</blockquote>
<ol>
<li><p>HashMap的底层实现原理</p>
</li>
<li><p>HashMap和Hashtable的异同</p>
</li>
</ol>
<h4 id="1-5-2-Map结构的理解：key和value的特点"><a href="#1-5-2-Map结构的理解：key和value的特点" class="headerlink" title="1.5.2 Map结构的理解：key和value的特点"></a>1.5.2 Map结构的理解：key和value的特点</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224608289.png" alt="image-20211215224608289"></p>
<ul>
<li><p>Map中的key：无序不可重复，使用Set存储所有的key；要求key所在类重写equals和hashCode方法。</p>
</li>
<li><p>Map中的value：无序可重复，使用Collection存储所有的value；要求key所在类重写equals方法。</p>
</li>
<li><p>一个键值对构成了一个Entry对象</p>
</li>
<li>Map中的Entry：无序不可重复，使用Set存储所有的entry</li>
</ul>
<h4 id="1-5-3-HashMap的底层实现原理"><a href="#1-5-3-HashMap的底层实现原理" class="headerlink" title="1.5.3 HashMap的底层实现原理"></a>1.5.3 HashMap的底层实现原理</h4><blockquote>
<p><code>JDK7</code>版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<p>在实例化以后，底层创建了长度是==16==的一维数组<code>Entry[] table</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能已经执行过多次put操作</span></span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure>
<p>首先，调用key1所在类的hashCode方法计算key1的哈希值，此哈希值经过某种算法后（例如取余），得到在Entry数组中的存放位置。</p>
<p>​        |——如果此位置上为空，则entry对象添加成功；情况1</p>
<p>​        |——如果此位置上不为空，意味着此位置上存在一个或多个数据（以链表形式存在），则比较key1和已经存在的数据的哈希值：</p>
<p>​                |——如果都不相同，则添加成功；情况2</p>
<p>​                |——如果与某一个数据的哈希值相同，则调用key1所在类的equals方法进行比较：</p>
<p>​                        |——如果返回false，则添加成功；情况3</p>
<p>​                        |——如果返回true，使用value1==替换==相同key的value值。</p>
<ul>
<li>对于情况2和情况3：同HashSet一样七上八下。</li>
<li>扩容：默认的扩容方式为扩容为原来容量的==2倍==（即新开辟一个原来容量2倍的数组空间），并将原有数据复制到该新数组中。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224618828.png" alt="image-20211215224618828"></p>
<blockquote>
<p><code>JDK8</code>版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap map = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<ul>
<li>底层没有创建一个长度为16的数组，并且该数组类型不是Entry了，而是Node；</li>
<li>首次调用put方法时，才创建数组。</li>
<li>底层结构新增了==红黑树==。当数组的某一个索引位置上的元素以链表形式存在的==个数大于8且当前数组的长度大于64时==，此索引位置上的所有数据改为使用红黑树存储。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224628060.png" alt="image-20211215224628060"></p>
<h4 id="1-5-4-HashMap源码分析"><a href="#1-5-4-HashMap源码分析" class="headerlink" title="1.5.4 HashMap源码分析"></a>1.5.4 HashMap源码分析</h4><blockquote>
<p><code>JDK7</code>版本</p>
</blockquote>
<h2 id="2-反射机制"><a href="#2-反射机制" class="headerlink" title="2 反射机制"></a>2 反射机制</h2><h3 id="2-1-反射机制概述"><a href="#2-1-反射机制概述" class="headerlink" title="2.1 反射机制概述"></a>2.1 反射机制概述</h3><h4 id="2-1-1-概述"><a href="#2-1-1-概述" class="headerlink" title="2.1.1 概述"></a>2.1.1 概述</h4><ul>
<li><p>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期间借助于<code>Reflection API</code>取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
</li>
<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224638775.png" alt="image-20211215224638775"></p>
</li>
</ul>
<h4 id="2-1-2-与反射有关的API"><a href="#2-1-2-与反射有关的API" class="headerlink" title="2.1.2 与反射有关的API"></a>2.1.2 与反射有关的API</h4><ul>
<li><p><code>java.lang.Class</code>:代表一个类 </p>
</li>
<li><p><code>java.lang.reflect.Method</code>:代表类的方法</p>
</li>
<li><p><code>java.lang.reflect.Field</code>:代表类的成员变量</p>
</li>
<li><p><code>java.lang.reflect.Constructor</code>:代表类的构造器</p>
</li>
</ul>
<h4 id="2-1-3-利用反射之前对Person类的操作"><a href="#2-1-3-利用反射之前对Person类的操作" class="headerlink" title="2.1.3 利用反射之前对Person类的操作"></a>2.1.3 利用反射之前对Person类的操作</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">// 私有属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;<span class="comment">// 公共属性</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 公共方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//私有方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是&quot;</span>+nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 私有构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//公共构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射之前对于Person类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建Person类的对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过对象，调用其内部的属性和方法</span></span><br><span class="line">    p1.setAge(<span class="number">24</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    p1.show();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Person类外部，不可以通过对象调用其内部私有结构</span></span><br><span class="line">    <span class="comment">// 例如：name属性，showNation私有方法，私有构造器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-利用反射对Person类操作"><a href="#2-1-4-利用反射对Person类操作" class="headerlink" title="2.1.4 利用反射对Person类操作"></a>2.1.4 利用反射对Person类操作</h4><blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射对Person类的操作</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// 1.通过反射创建Person类的对象</span></span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    Object obj = cons.newInstance(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>);</span><br><span class="line">    Person p = (Person)obj;</span><br><span class="line">    System.out.println(p);</span><br><span class="line">    <span class="comment">// 2.通过反射调用对象指定的属性和方法</span></span><br><span class="line">    <span class="comment">// 调用属性</span></span><br><span class="line">    Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(p,<span class="number">10</span>);</span><br><span class="line">    System.out.println(p);</span><br><span class="line">    <span class="comment">// 调用方法</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射，可以调用Person类的私有结构，例如私有属性，方法，构造器等</span></span><br><span class="line">    <span class="comment">// 调用私有构造器</span></span><br><span class="line">    Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons1.newInstance(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1,<span class="string">&quot;HanMeimei&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用私有方法</span></span><br><span class="line">    Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    String nation = (String)showNation.invoke(p1,<span class="string">&quot;中国&quot;</span>);<span class="comment">// 相当于String nation = p1.showNation(&quot;中国&quot;);</span></span><br><span class="line">    System.out.println(nation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-如何看待反射和封装性"><a href="#2-1-5-如何看待反射和封装性" class="headerlink" title="2.1.5 如何看待反射和封装性"></a>2.1.5 如何看待反射和封装性</h4><ul>
<li>通过直接new对象，或反射的方式都可以调用公共的结构，那么开发中到底用哪个？</li>
</ul>
<p>回答：建议直接用new的方法。</p>
<ul>
<li>反射机制与面向对象的封装性是不是矛盾的？</li>
</ul>
<p>回答：不矛盾。</p>
<h3 id="2-2-理解Class类并获取Class实例"><a href="#2-2-理解Class类并获取Class实例" class="headerlink" title="2.2 理解Class类并获取Class实例 *"></a>2.2 理解Class类并获取Class实例 *</h3><h4 id="2-2-1-Class类的理解"><a href="#2-2-1-Class类的理解" class="headerlink" title="2.2.1 Class类的理解"></a>2.2.1 Class类的理解</h4><p>1.类的加载过程：</p>
<p>程序在<code>javac.exe</code>命令后，会生成一个或多个字节码文件(<code>.class</code>结尾)，接着使用<code>java.exe</code>命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为==类的加载==。加载到内存中的类，就成为==运行时类==，此运行时类就作为Class类的一个实例对象。</p>
<p>2.换句话说，Class的实例就对应一个运行时类。</p>
<p>3.加载到内存中的运行时类，会缓存一定时间，在此时间之内，我们可以利用不同的方式来获取此运行时类。该运行时类在内存中只有一个。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224649657.png" alt="image-20211215224649657"></p>
<blockquote>
<p>代码示例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Class c1 = Object.class;</span><br><span class="line">Class c2 = Comparable.class;</span><br><span class="line">Class c3 = String[].class;</span><br><span class="line">Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">Class c5 = ElementType.class;</span><br><span class="line">Class c6 = Override.class;</span><br><span class="line">Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c10 = a.getClass();</span><br><span class="line">Class c11 = b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">System.out.println(c10 == c11);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-获取Class实例的四种方法"><a href="#2-2-2-获取Class实例的四种方法" class="headerlink" title="2.2.2 获取Class实例的四种方法"></a>2.2.2 获取Class实例的四种方法</h4><ul>
<li>调用运行时类的属性：<code>.class</code></li>
<li>通过运行时类的对象，调用<code>getClass()</code>方法</li>
<li>调用Class的静态方法：<code>forName(String classPath)</code>用的最多</li>
<li>使用类加载器：<code>ClassLoader</code> 了解，用得少</li>
</ul>
<blockquote>
<p>代码实例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取Class实例的四种方式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// 方式1：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    System.out.println(clazz);<span class="comment">// class com.hongyi.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：通过运行时类的对象，调用getClass()方法</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">    Class clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式3：调用Class的静态方法：forName(String classPath) 用的最多</span></span><br><span class="line">    <span class="comment">// classPath：全类名</span></span><br><span class="line">    Class clazz3 = Class.forName(<span class="string">&quot;com.hongyi.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">    System.out.println(clazz == clazz2);<span class="comment">// true</span></span><br><span class="line">    System.out.println(clazz2 == clazz3);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式4：使用类的加载器：ClassLoader 了解，用得少</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.hongyi.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);</span><br><span class="line">    System.out.println(clazz4 == clazz);<span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-类的加载与ClassLoader的理解"><a href="#2-3-类的加载与ClassLoader的理解" class="headerlink" title="2.3 类的加载与ClassLoader的理解"></a>2.3 类的加载与ClassLoader的理解</h3><h4 id="2-3-1-类的加载过程"><a href="#2-3-1-类的加载过程" class="headerlink" title="2.3.1 类的加载过程"></a>2.3.1 类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224659087.png" alt="image-20211215224659087"></p>
<ul>
<li><p>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与。</p>
</li>
<li><p>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。</p>
</li>
</ul>
<ol>
<li><p>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题。</p>
</li>
<li><p>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。 </p>
</li>
<li><p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。 </p>
</li>
</ol>
<ul>
<li>初始化：</li>
</ul>
<ol>
<li><p>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。 </p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 </p>
</li>
<li><p>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步</p>
</li>
</ol>
<h4 id="2-3-2-ClassLoader的理解"><a href="#2-3-2-ClassLoader的理解" class="headerlink" title="2.3.2 ClassLoader的理解"></a>2.3.2 ClassLoader的理解</h4><blockquote>
<p>类加载器</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224709444.png" alt="image-20211215224709444"></p>
<p>类加载器的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在==堆==中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。</p>
<p>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p>
<blockquote>
<p>ClassLoader</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224719025.png" alt="image-20211215224719025"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取类加载器，自定义类的加载器类型为系统类加载器</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);<span class="comment">// jdk.internal.loader.ClassLoaders$AppClassLoader@78308db1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一层的类加载器，为扩展类加载器</span></span><br><span class="line">    ClassLoader classLoader1 = classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);<span class="comment">// jdk.internal.loader.ClassLoaders$PlatformClassLoader@c818063</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取上一层的类加载器，为引导类加载器，但是获取不了，返回为null</span></span><br><span class="line">    <span class="comment">// 引导类加载器主要负责加载核心类库，无法加载自定义类</span></span><br><span class="line">    ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">    ClassLoader classLoader3 = String.class.getClassLoader();<span class="comment">//引导类加载器</span></span><br><span class="line">    System.out.println(classLoader3);<span class="comment">// null：获取不了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>ClassLoader</code>加载配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 此时的文件默认在当前的project下</span></span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">    prop.load(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：使用类加载器</span></span><br><span class="line">    <span class="comment">// 配置文件默认识别为在当前project的src下</span></span><br><span class="line">    ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">    InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    prop.load(is);</span><br><span class="line"></span><br><span class="line">    System.out.println(prop.getProperty(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    System.out.println(prop.getProperty(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-创建运行时对象"><a href="#2-4-创建运行时对象" class="headerlink" title="2.4 创建运行时对象 *"></a>2.4 创建运行时对象 *</h3><h4 id="2-4-1-newInstance"><a href="#2-4-1-newInstance" class="headerlink" title="2.4.1 newInstance()"></a>2.4.1 newInstance()</h4><p>此方法实质上是调用运行时类的空参构造器，要想此方法正确的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参构造器</li>
<li>空参构造器的访问权限必须得够，通常设置为<code>public</code></li>
</ul>
<p>在<code>javabean</code>中要求提供一个空参构造器，便于通过反射来创建运行时类对象，便于子类继承此运行时类时，默认调用<code>super()</code>时，保证父类有此构造器。</p>
<blockquote>
<p>代码演示</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    <span class="comment">// newInstance():调用此方法，创建对应的运行时类的对象</span></span><br><span class="line">    <span class="comment">// 实际上还是通过调用Person类的空参构造器来造对象</span></span><br><span class="line">    Person p = (Person) clazz.newInstance();</span><br><span class="line">    System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-2-反射的动态性理解"><a href="#2-4-2-反射的动态性理解" class="headerlink" title="2.4.2 反射的动态性理解"></a>2.4.2 反射的动态性理解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);<span class="comment">//产生0,1,2随机数</span></span><br><span class="line">    String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (num)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            classPath =  <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            classPath = <span class="string">&quot;com.hongyi.Person&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object obj = getInstance(classPath);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法要创建一个指定全类名的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classPath 全限定类名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Class clazz = Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-获取运行时类的完整结构"><a href="#2-5-获取运行时类的完整结构" class="headerlink" title="2.5 获取运行时类的完整结构"></a>2.5 获取运行时类的完整结构</h3><h4 id="2-5-1-代码准备"><a href="#2-5-1-代码准备" class="headerlink" title="2.5.1 代码准备"></a>2.5.1 代码准备</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Creature</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> gender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breath</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物呼吸&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation(value = &quot;hi&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> <span class="keyword">extends</span> <span class="title">Creature</span>&lt;<span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,<span class="title">MyInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Human</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation(value = &quot;ABC&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Human</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Human(String name,<span class="keyword">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">show</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是：&quot;</span>+nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">display</span><span class="params">(String interests)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> interests;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.CONSTRUCTOR, ElementType.LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224729258.png" alt="image-20211215224729258"></p>
<h4 id="2-5-2-获取运行时类的属性结构和内部结构"><a href="#2-5-2-获取运行时类的属性结构和内部结构" class="headerlink" title="2.5.2 获取运行时类的属性结构和内部结构"></a>2.5.2 获取运行时类的属性结构和内部结构</h4><blockquote>
<p><code>getFields()</code></p>
<p><code>getDeclaredFields()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Human.class;</span><br><span class="line">    <span class="comment">// 获取属性结构</span></span><br><span class="line">    <span class="comment">// getFields():获取当前运行时类及其父类中声明为public的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// public int com.hongyi.Human.id</span></span><br><span class="line">        <span class="comment">// public double com.hongyi.Creature.weight</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// getDeclaredFields():获取当前运行时类的所有属性，不包含父类</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">        <span class="comment">// private java.lang.String com.hongyi.Human.name</span></span><br><span class="line">        <span class="comment">// int com.hongyi.Human.age</span></span><br><span class="line">        <span class="comment">// public int com.hongyi.Human.id</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>getModifiers()</code></p>
<p><code>getType()</code></p>
<p><code>getName()</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 权限修饰符 数据类型 变量名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz = Human.class;</span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field f : declaredFields)&#123;</span><br><span class="line">        <span class="comment">// 1.获取权限修饰符</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = f.getModifiers();</span><br><span class="line">        System.out.print(<span class="string">&quot;权限修饰符:&quot;</span>+Modifier.toString(modifiers)+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="comment">// 2.数据类型</span></span><br><span class="line">        Class type = f.getType();</span><br><span class="line">        System.out.print(<span class="string">&quot;数据类型：&quot;</span>+type.getName()+<span class="string">&quot;   &quot;</span>);</span><br><span class="line">        <span class="comment">// 3.变量名</span></span><br><span class="line">        String name = f.getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;变量名：&quot;</span>+name);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://kisugitakumi.oss-cn-chengdu.aliyuncs.com/img3/image-20211215224738420.png" alt="image-20211215224738420"></p>
<h4 id="2-5-3-获取运行时类的方法结构"><a href="#2-5-3-获取运行时类的方法结构" class="headerlink" title="2.5.3 获取运行时类的方法结构"></a>2.5.3 获取运行时类的方法结构</h4><h3 id="2-6-调用运行时类的指定结构"><a href="#2-6-调用运行时类的指定结构" class="headerlink" title="2.6 调用运行时类的指定结构 *"></a>2.6 调用运行时类的指定结构 *</h3><h3 id="2-7-反射的应用——动态代理"><a href="#2-7-反射的应用——动态代理" class="headerlink" title="2.7 反射的应用——动态代理"></a>2.7 反射的应用——动态代理</h3><h2 id="3-常用类"><a href="#3-常用类" class="headerlink" title="3 常用类"></a>3 常用类</h2><h2 id="12-泛型"><a href="#12-泛型" class="headerlink" title="12 泛型"></a>12 泛型</h2><h3 id="12-1-泛型概念"><a href="#12-1-泛型概念" class="headerlink" title="12.1 泛型概念"></a>12.1 泛型概念</h3><blockquote>
<p>泛型的设计背景</p>
</blockquote>
<p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候<strong>除了元素的类型不缺定</strong>，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>，List<E>，ArrayList<E> 这个<E>就是类型参数，即泛型。</p>
<blockquote>
<p>泛型的概念</p>
</blockquote>
<ul>
<li>泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li>
<li>从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象。</li>
<li>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">Kisugi Takumi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://kisugitakumi.com">https://kisugitakumi.com</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">此文章版权归Kisugi Takumi所有，如有转载，请註明来自原作者</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/design.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/12/01/Java%E8%A1%A5%E5%85%85/"><img class="prev-cover" src="/img/juc.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java补充知识</div></div></a></div><div class="next-post pull-right"><a href="/2020/05/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="/img/leetcode.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode刷题笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/12/09/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="IDEA常用快捷键"><img class="cover" src="/img/idea.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-09</div><div class="title">IDEA常用快捷键</div></div></a></div><div><a href="/2020/12/01/Java%E8%A1%A5%E5%85%85/" title="Java补充知识"><img class="cover" src="/img/juc.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">Java补充知识</div></div></a></div><div><a href="/2020/05/20/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" title="LeetCode刷题笔记"><img class="cover" src="/img/leetcode.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-20</div><div class="title">LeetCode刷题笔记</div></div></a></div><div><a href="/2021/03/15/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Linux学习笔记"><img class="cover" src="/img/linux.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-15</div><div class="title">Linux学习笔记</div></div></a></div><div><a href="/2021/03/20/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Nginx学习笔记"><img class="cover" src="/img/nginx.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-20</div><div class="title">Nginx学习笔记</div></div></a></div><div><a href="/2021/09/08/JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="JavaWeb学习笔记"><img class="cover" src="/img/javaweb.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-08</div><div class="title">JavaWeb学习笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-text">Java基础学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88"><span class="toc-text">1 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.1 集合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.1.1 数组的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">1.1.2 集合框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-text">1.2 Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.2.1 Collection接口中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">1.2.2 集合元素的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86"><span class="toc-text">1.2.3 foreach循环遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-List%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">1.3 List接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-List%E6%A6%82%E8%BF%B0"><span class="toc-text">1.3.1 List概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1.3.2 ArrayList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1.3.3 LinkedList源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">1.3.4 List接口的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-5-List%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">1.3.5 List集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Set%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">1.4 Set接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-Set%E6%A6%82%E8%BF%B0"><span class="toc-text">1.4.1 Set概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-2-HashSet%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">1.4.2 HashSet添加元素的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-3-%E5%85%B3%E4%BA%8Eequals-%E5%92%8ChashCode-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99"><span class="toc-text">1.4.3 关于equals()和hashCode()方法的重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-4-LinkedHashSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.4.4 LinkedHashSet的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-5-TreeSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1.4.5 TreeSet的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Map%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">1.5 Map接口及其实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-Map%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">1.5.1 Map框架概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-2-Map%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9Akey%E5%92%8Cvalue%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">1.5.2 Map结构的理解：key和value的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-3-HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1.5.3 HashMap的底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-4-HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">1.5.4 HashMap源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">2 反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 反射机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%9C%89%E5%85%B3%E7%9A%84API"><span class="toc-text">2.1.2 与反射有关的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E4%B9%8B%E5%89%8D%E5%AF%B9Person%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">2.1.3 利用反射之前对Person类的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%AF%B9Person%E7%B1%BB%E6%93%8D%E4%BD%9C"><span class="toc-text">2.1.4 利用反射对Person类操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-5-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E5%8F%8D%E5%B0%84%E5%92%8C%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">2.1.5 如何看待反射和封装性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-text">2.2 理解Class类并获取Class实例 *</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2.2.1 Class类的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">2.2.2 获取Class实例的四种方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2.3 类的加载与ClassLoader的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3.1 类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-ClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">2.3.2 ClassLoader的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.4 创建运行时对象 *</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-newInstance"><span class="toc-text">2.4.1 newInstance()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7%E7%90%86%E8%A7%A3"><span class="toc-text">2.4.2 反射的动态性理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-text">2.5 获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-%E4%BB%A3%E7%A0%81%E5%87%86%E5%A4%87"><span class="toc-text">2.5.1 代码准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84%E5%92%8C%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-text">2.5.2 获取运行时类的属性结构和内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-3-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">2.5.3 获取运行时类的方法结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">2.6 调用运行时类的指定结构 *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.7 反射的应用——动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">3 常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%B3%9B%E5%9E%8B"><span class="toc-text">12 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%E6%B3%9B%E5%9E%8B%E6%A6%82%E5%BF%B5"><span class="toc-text">12.1 泛型概念</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Kisugi Takumi</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my blog!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>